Hoy os traigo una librería muy potente y muy útil, ahora que Rust compila a <strong>WebAssembly</strong> de forma nativa. Se trata de <a href="https://github.com/DenisKolodin/yew"><strong>Yew</strong></a>, una librería para diseñar frontends, single-page-applications y en general, una librería que es una alternativa a <strong>Angular, React, Vue</strong> y <strong>Elm</strong>.<br><br>En particular, <strong>Yew</strong> se basa en The Elm Architecture, por lo que los usuarios de Elm serán los que encuentren más familiar a Yew.<br><br><a href="https://files.adrianistan.eu/Tejo.jpg"><img class="size-full wp-image-1246" src="https://files.adrianistan.eu/Tejo.jpg" alt="" width="1000" height="526" /></a> Yew significa tejo. He aquí uno de los tejos más famosos de Valladolid, en la plaza del Viejo Coso<br><h2>Instalar cargo-web y el soporte a WebAssembly</h2><br>Antes de empezar a programar necesitaremos instalar un plugin para Cargo, llamado <strong>cargo-web</strong>, que nos ayudará en el desarrollo web con Rust. Por otro lado, hace falta instalar el soporte de Rust a WebAssembly. Existen tres opciones actualmente: asmjs-unknown-emscripten, wasm32-unknown-emscripten y wasm32-unknown-unknown. Para los primeras opciones hace falta tener instalado <a href="https://github.com/kripken/emscripten"><strong>Emscripten</strong></a>. Para la última, no hace falta nada, por lo que es mi opción recomendada. Por otro lado, wasm32 significa WebAssembly y asmjs es asm.js, que es simplemente JavaScript y será compatible con más navegadores.<br><pre class="lang:default decode:true">cargo install cargo-web<br>rustup target add wasm32-unknown-unknown</pre><br><h2>The Elm Architecture</h2><br>Los principios de <a href="https://guide.elm-lang.org/architecture/"><em>The Elm Architecture</em></a> se basan en: modelo, mensajes, actualización y vista.<br><br>Para este tutorial vamos a hacer la típica aplicación de una lista donde guardamos notas. Nuestro modelo se va a componer de una lista de tareas, para simplificar, pongamos que una tarea es simplemente un String y un ID. Entonces también nos hará falta almacenar un contador para ir poniendo IDs. También, al tener un campo de texto, nos hará falta una variable para ir almacenando temporalmente lo que escribe el usuario.<br><pre class="lang:rust decode:true">struct Model {<br>    id: u32,<br>    tasks: Vec&lt;Task&gt;,<br>    input: String,<br>}<br><br>struct Task{<br>    content: String,<br>    id: u32,<br>}</pre><br>Lo siguiente es diseñar los <strong>mensajes</strong>. Los mensajes interactúan con el modelo y desencadenan una actualización de la vista. En esta aplicación solo nos hacen falta dos mensajes: añadir mensaje y borrar mensaje. Pero como tenemos un campo de texto, tenemos que introducir un mensaje Change y siempre viene bien un mensaje que no haga nada.<br><pre class="lang:rust decode:true">enum Msg {<br>    Add,<br>    Remove(u32),<br>    Change(String),<br>    None,<br>}</pre><br>Una vez hecho esto pasamos a crear la función <strong>update</strong>, en la que hacemos distintas cosas según el mensaje que recibamos.<br><pre class="lang:rust decode:true ">fn update(context: &amp;mut Context&lt;Msg&gt;, model: &amp;mut Model, msg: Msg) {<br>    match msg {<br>        Msg::Add =&gt; {<br>            let task = Task{<br>                content: model.input.clone(),<br>                id: model.id,<br>            };<br>            model.tasks.push(task);<br>            model.id += 1;<br>        }<br>        Msg::Change(content) =&gt; {<br>            model.input = content;<br>        }<br>        Msg::Remove(id) =&gt; {<br>            let mut i = 0;<br>            for task in model.tasks.iter(){<br>                if task.id == id{<br>                    break;<br>                }<br>                i+=1;<br>            }<br>            model.tasks.remove(i);<br>        }<br>        _ =&gt; {<br><br>        }<br>    }<br>}</pre><br>Así pues, si se lanza un mensaje <strong>Msg::Add</strong> lo que hacemos es copiar el valor de la variable temporal input, crear una nueva tarea con su ID y añadirla a la lista de tareas. Ya está. Yew mágicamente actualizará la página para reflejar que la lista de tareas ha sido modificada. Lo mismo pasa con Remove.<br><br>Ahora vamos a las vistas. Una vista es una función que devuelve <strong>Html&lt;Msg&gt;</strong> y se pueden componer varias funciones así. En nuestro caso, tenemos una vista principal donde se ve un campo de texto y un sitio donde se ejecuta un bucle for con las tareas del modelo. Y a cada tarea se le aplica la vista <strong>view_task</strong>.<br><pre class="lang:rust decode:true">fn view(model: &amp;Model) -&gt; Html&lt;Msg&gt; {<br>    html! {<br>        &lt;div&gt;<br>            &lt;ul&gt;<br>            { for model.tasks.iter().map(view_task) }<br>            &lt;/ul&gt;<br>            &lt;input type="text", value=&amp;model.input, oninput=|e: InputData| Msg::Change(e.value), onkeypress=|e: KeyData|{<br>                if e.key == "Enter" {<br>                    Msg::Add<br>                }else{<br>                    Msg::None<br>                }<br>            }, /&gt; <br>        &lt;/div&gt;<br>    }<br>}<br><br>fn view_task(task: &amp;Task) -&gt; Html&lt;Msg&gt;{<br>    let id = task.id;<br>    html!{<br>        &lt;li&gt;&lt;span&gt;{&amp;task.content}&lt;/span&gt;&lt;button onclick=move |_| Msg::Remove(id),&gt;{format!("X")}&lt;/button&gt;&lt;/li&gt;<br>    }<br>}</pre><br>La macro <strong>html!</strong> nos permite escribir HTML directamente en Rust, con algunas diferencias (¡prestad atención a las comas!). También nos permite introducir código Rust (entre llaves) y <strong>closures</strong> (observad onclick, oninput y onkeypress).<br><br>Finalmente en el método main, inicializamos el modelo y llamamos a <strong>program</strong>, que empieza a ejecutar Yew.<br><br>El código final queda así.<br><pre class="lang:rust decode:true">#[macro_use]<br>extern crate yew;<br><br>use yew::html::*;<br><br>struct Model {<br>    id: u32,<br>    tasks: Vec&lt;Task&gt;,<br>    input: String,<br>}<br><br>struct Task{<br>    content: String,<br>    id: u32,<br>}<br><br>enum Msg {<br>    Add,<br>    Remove(u32),<br>    Change(String),<br>    None,<br>}<br><br>fn update(context: &amp;mut Context&lt;Msg&gt;, model: &amp;mut Model, msg: Msg) {<br>    match msg {<br>        Msg::Add =&gt; {<br>            let task = Task{<br>                content: model.input.clone(),<br>                id: model.id,<br>            };<br>            model.tasks.push(task);<br>            model.id += 1;<br>        }<br>        Msg::Change(content) =&gt; {<br>            model.input = content;<br>        }<br>        Msg::Remove(id) =&gt; {<br>            let mut i = 0;<br>            for task in model.tasks.iter(){<br>                if task.id == id{<br>                    break;<br>                }<br>                i+=1;<br>            }<br>            model.tasks.remove(i);<br>        }<br>        _ =&gt; {<br><br>        }<br>    }<br>}<br><br>fn view(model: &amp;Model) -&gt; Html&lt;Msg&gt; {<br>    html! {<br>        &lt;div&gt;<br>            &lt;ul&gt;<br>            { for model.tasks.iter().map(view_task) }<br>            &lt;/ul&gt;<br>            &lt;input type="text", value=&amp;model.input, oninput=|e: InputData| Msg::Change(e.value), onkeypress=|e: KeyData|{<br>                if e.key == "Enter" {<br>                    Msg::Add<br>                }else{<br>                    Msg::None<br>                }<br>            }, /&gt; <br>        &lt;/div&gt;<br>    }<br>}<br><br>fn view_task(task: &amp;Task) -&gt; Html&lt;Msg&gt;{<br>    let id = task.id;<br>    html!{<br>        &lt;li&gt;&lt;span&gt;{&amp;task.content}&lt;/span&gt;&lt;button onclick=move |_| Msg::Remove(id),&gt;{format!("X")}&lt;/button&gt;&lt;/li&gt;<br>    }<br>}<br><br>fn main() {<br>    let model = Model {<br>        id: 0,<br>        tasks: vec![],<br>        input: String::from("")<br>    };<br>    program(model, update, view);<br>}<br></pre><br><h2><a href="https://files.adrianistan.eu/Screenshot-from-2018-01-02-00-18-14.png"><img class="aligncenter size-large wp-image-1245" src="https://files.adrianistan.eu/Screenshot-from-2018-01-02-00-18-14-1024x576.png" alt="" width="840" height="473" /></a>Ejecutando la aplicación web</h2><br>Usando cargo web, es muy sencillo generar la aplicación web. Simplemente ejecuta:<br><pre class="lang:default decode:true ">cargo web start --target-webasm</pre><br>El resultado, se montará en un mini servidor web. Si accedes a la URL que indica Cargo con tu navegador web, verás algo similar a esto:<br><br><a href="https://files.adrianistan.eu/YewBlog.png"><img class="aligncenter size-full wp-image-1243" src="https://files.adrianistan.eu/YewBlog.png" alt="" width="845" height="440" /></a>Añade items y bórralos. Observa como la aplicación funciona perfectamente.<br><h2>Distribuyendo la aplicación</h2><br>Realmente cargo web ha hecho muchas cosas por nosotros. Si nosotros queremos usar Yew en la vida real, no usaremos cargo web. Para ello, compilamos la aplicación web:<br><pre class="lang:default decode:true ">cargo web build --target-webasm</pre><br>Y accedemos a la carpeta <strong>target/wasm32-unknown-unknown/release</strong>. Allí encontraremos dos archivos que vamos a necesitar. Uno acabado en .<strong>js</strong> y otro acabado en <strong>.wasm</strong>. Ambos ficheros deberemos copiarlos donde queramos usarlos. Por último, será necesario un fichero HTML. En el fichero HTML solo hace falta cargar el fichero JS. Yew hará el resto.<br><br><a href="https://github.com/aarroyoc/blog-ejemplos/tree/master/yew_todo_list">Si quieres saber más, puedes descargarte el código de ejemplo que se encuentra en GitHub.</a>