El software va creciendo poco a poco en un proyecto y es vital que esté bien organizado. Rust incluye un potente sistema de módulos para manejar estas situaciones y <strong>Cargo</strong> nos ayuda a gestionar las dependencias del proyecto.<br><h2>Módulos</h2><br>Los módulos se definen con la palabra reservada <strong>mod</strong> y por defecto todo es privado. Es necesario indicar <strong>pub</strong> para hacer esos campos públicos. Con <strong>use</strong> podemos acortar la manera con la que hacemos referencia a los componentes del módulo. Así pues, <strong>use</strong> es similar a <strong>using namespace</strong> de C++.<br><br><pre class="lang:rust decode:true"><br>mod network{<br>    pub fn version() -&gt; String{<br>        String::from(&quot;Network 1.0.0&quot;)<br>    }<br>    pub mod server{<br>        fn private_thing(){<br><br>        }<br>        pub fn public_thing(){<br><br>        }<br>    }<br>}<br><br>fn main() {<br>    println!(&quot;{}&quot;,network::version());<br>    {<br>        use network::server::public_thing;<br>        public_thing();<br>    }<br>}<br></pre><br><br>Los módulos resultan una opción más interesante si tenemos múltiples archivos. Por norma general, si un módulo se define en el fichero de entrada del compilador, este se busca en dos sitios:<br><ul><br> 	<li>Un fichero <em>nombre_del_modulo.rs</em></li><br> 	<li>Un fichero <em>nombre_del_modulo/mod.rs</em> (opción recomendada para módulos de varios archivos)</li><br></ul><br>Por lo que el código anterior puede sustituirse por esto en el fichero principal:<br><br><pre class="lang:rust decode:true"><br>mod network;<br><br>fn main() {<br>    println!(&quot;{}&quot;,network::version());<br>    {<br>        use network::server::public_thing;<br>        public_thing();<br>    }<br>}<br></pre><br><br>Y esto en un fichero <em>network.rs</em><br><br><pre class="lang:rust decode:true"><br>pub fn version() -&gt; String{<br>    String::from(&quot;Network 1.0.0&quot;)<br>}<br>pub mod server{<br>    fn private_thing(){<br><br>    }<br>    pub fn public_thing(){<br><br>    }<br>}<br></pre><br><br>Podemos usar <strong>use-as</strong> para modificar el nombre con el que se importa una función.<br><br><pre class="lang:rust decode:true"><br>mod network;<br><br>fn main() {<br>    println!(&quot;{}&quot;,network::version());<br>    {<br>        use network::server::public_thing as super_thing;<br>        super_thing();<br>    }<br>}<br></pre><br><br>&nbsp;<br><h2>Crates</h2><br>El código en Rust se organiza en <strong>crates</strong>, que son colecciones de módulos que se distribuyen. Piensa en ello como si fuesen <strong>gemas</strong> de Ruby o <strong>librerías</strong> de C++. Las <strong>crates</strong> se pueden compartir con la gente. El mayor repositorio de <strong>crates</strong> de la comunidad Rust es <a href="https://crates.io/">crates.io</a>.<br><br><a href="https://files.adrianistan.eu/CratesIO.png"><img class="aligncenter size-large wp-image-866" src="https://files.adrianistan.eu/CratesIO-1024x500.png" alt="" width="840" height="410" /></a>Las <strong>crates</strong> se pueden generar con <strong>rustc</strong> o con <strong>cargo</strong>, aunque es habitual usar la segunda opción. Vamos a ver primero como usaríamos una <strong>crate</strong> externa. En este caso voy a usar <strong>regex</strong>. Sé que en esta parte no vas a saber como descargar <strong>regex</strong> y usarla, pero voy a explicar el código.<br><br><pre class="lang:rust decode:true"><br>extern crate regex;<br><br>use regex::Regex;<br><br>fn main() {<br>    let r = Regex::new(r&quot;([A-Za-z0-9])([.]|[_]|[A-Za-z0-9])+@gmail.com&quot;).unwrap();<br>    if r.is_match(&quot;pucela_segunda@gmail.com&quot;) {<br>        println!(&quot;Correo válido de Gmail&quot;);<br>    }else{<br>        println!(&quot;Correo no válido de Gmail&quot;);<br>    }<br>}<br></pre><br><br>Básicamente se usa <strong>extern crate</strong> para importar una <strong>crate</strong> externa, en este caso regex. Con <strong>use</strong> lo único que hacemos es acortar la manera de llamar a las funciones. Si no estuviese podríamos poner perfectamente <em>regex::Regex::new</em> en vez de <em>Regex::new</em> y funcionaría.<br><h2>Cargo</h2><br><strong>Cargo</strong> es una herramienta que cumple dos funciones dentro del ecosistema Rust. Por un lado es un gestor de dependencias y por otro lado gestiona también las compilaciones.<br><br>En su parte de gestor de dependencias nos permite especificar que <strong>crates</strong> necesita el proyecto para compilar, su versión y si la <strong>crate</strong> lo soporta, con qué características activadas.<br><br>En su parte de gestor de compilaciones, realiza la compilación con <strong>rustc</strong> y añade las flags pertinentes al compilador. También se le pueden especificar cosas más complejas, aunque en Rust no suele ser habitual tener configuraciones de compilación excesivamente complejas.<br><br>Todo lo relativo a Cargo se define en el archivo <strong>Cargo.toml</strong>. Que tiene una estructura similar a esta:<br><br><pre class="lang:rust decode:true"><br>[package]<br>name = &quot;super_app&quot;<br>version = &quot;0.1.0&quot;<br>authors = [&quot;Adrián Arroyo Calle&quot;]<br><br>[dependencies]<br>regex = &quot;0.2.2&quot;<br></pre><br><br>En la sección <strong>dependencies</strong> puedes añadir línea por línea la <strong>crate</strong> que te haga falta. Consulta la documentación de cada <strong>crate</strong> para esto, pues puede haber variaciones.<br><h2>Comandos básicos de Cargo</h2><br><h3>Crear un proyecto con Cargo</h3><br><em>cargo new --bin mi_proyecto </em># si queremos que sea ejecutable<br><br><em>cargo new mi_crate</em> # si queremos que sea una crate<br><h3>Compilar y ejecutar</h3><br><em>cargo run</em><br><br><em>cargo build</em> # solo compilar<br><br><em>cargo build --release</em> # compilar en modo Release<br><br>Cargo automáticamente se encarga de obtener las dependencias en la fase de compilación.<br><h3>Instalar aplicaciones</h3><br><em>cargo install APLICACION</em><br><br>Muchas herramientas de pueden distribuir a través de Cargo. Por ejemplo, <strong>Racer</strong>, un programa que sirve de autocompletado para IDEs como Eclipse o Visual Studio.<br><h3>Ejecutar tests</h3><br><em>cargo test</em><br><h3>Generar documentación</h3><br><em>cargo doc</em><br><h2>Plugins de Cargo</h2><br>Cargo es extensible gracias a plugins. Algunos interesantes son <strong>Clippy</strong>, <strong>cargo-audit, rustfmt,</strong> ...