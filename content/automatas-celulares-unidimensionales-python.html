Estaba yo leyendo este verano un libro titulado <em>Think Complexity</em> cuando en un capítulo empezó a hablar de los autómatas celulares unidimensionales. El tema me interesó y por eso esta entrada. Veamos primero a qué nos referimos cuando hablamos de esto.<br><br>Cuando hablamos a autómatas celulares, nos referimos a pequeñas entidades independientes pero que interaccionan entre sí. Celulares porque son la unidad elemental del universo donde van a existir y autómatas porque deciden por ellas mismas, basadas en un conjunto de reglas predefinido, cuando el tiempo avanza de forma discreta (es decir, a <em>pasos</em>).<br><br>Este concepto abstracto puede visualizarse con facilidad si nos imaginamos una rejilla. Cada celda es una célula capaz de cambiar su estado según su entorno.<br><br>Los autómatas celulares fueron objeto de estudio de <strong>Stephen Wolfram</strong>, matemático conocido por haber diseñado el programa <em>Mathemathica</em> y <em>Wolfram Alpha</em>.<br><br><a href="https://files.adrianistan.eu/UpC1-Kjf.jpg"><img class="aligncenter size-full wp-image-1020" src="https://files.adrianistan.eu/UpC1-Kjf.jpg" alt="" width="400" height="400" /></a><br><br>Los autómatas celulares unidimensionales son aquellos que forman parte de un universo unidimensional. Es decir, cada célula tiene una vecina a su izquierda y a su derecha. En los bordes se pueden definir varios comportamientos pero el concepto no varía. Pensemos en ello como una tira de celdas.<br><br><a href="https://files.adrianistan.eu/Tira.png"><img class="aligncenter size-full wp-image-1001" src="https://files.adrianistan.eu/Tira.png" alt="" width="200" height="50" /></a><br><br>El estudio de estos autómatas es interesante, ya que pueden generarse patrones/situaciones muy complejas en base a unas reglas sencillas.<br><h2>¿Cómo se definen las reglas?</h2><br>Wolfram usó un sistema para definir las reglas de estos autómatas que hoy conocemos como <em>Wolfram Code</em>. Se basa en definir una tabla con los estados presentes de la célula y sus vecinas así como el valor que deberá adoptar en esa situación la célula. Como Wolfram usó células con solo dos estados, todo está en binario, y la parte baja de la tabla es un número de 8 bits. Este número se suele pasar a decimal y así se identifica.<br><table><br><tbody><br><tr><br><th>Estados presentes</th><br><td>111</td><br><td>110</td><br><td>101</td><br><td>100</td><br><td>011</td><br><td>010</td><br><td>001</td><br><td>000</td><br></tr><br><tr><br><th>Estado futuro</th><br><td>0</td><br><td>0</td><br><td>1</td><br><td>1</td><br><td>0</td><br><td>0</td><br><td>1</td><br><td>0</td><br></tr><br></tbody><br></table><br>Esta tabla representa la Regla 50, porque 00110010 en binario es 50.<br><h2>¿Cómo se representan?</h2><br>Una manera muy interesante de representar estos autómatas es poner cada <em>paso</em> en una fila distinta dentro de una imagen.<br><br><a href="https://files.adrianistan.eu/TiempoCA.png"><img class="aligncenter size-full wp-image-1002" src="https://files.adrianistan.eu/TiempoCA.png" alt="" width="300" height="200" /></a>Una vez que sabemos esto vamos a hacer un programa en Python que nos permita observar la evolución de estos autómatas.<br><br>Usaremos el procedimiento original, que es empezar con todos los estados de los autómatas en 0 salvo el del autómata central, que será 1.<br><h2>La clase Automata</h2><br>La clase autómata va a contener las reglas, así como un ID y el estado que posee. Además, por cuestiones técnicas conviene guardar el estado anterior que tuvo.<br><br><pre class="lang:python decode:true"><br>class Automata(object):<br><br>    rules = list()<br><br>    def __init__(self,idx=0):<br>        self.idx = idx<br>        self.state = False<br>        self.statePrev = False<br></pre><br><br>Como podéis ver, <strong>rules</strong> no lleva self, es decir, va a ser una variable compartida entre todas las instancias de Automata. Esto es porque las reglas son idénticas a todos los autómatas.<br><h2>La clase World</h2><br>Ahora vamos a definir el universo donde residen estos autómatas. Este universo almacena una lista con los autómatas, se encarga de actualizarlos según las normas y de dibujarlos usando <strong>PIL</strong>. También he insertado el código que codifica las normas según el número en decimal.<br><br><pre class="lang:python decode:true"><br>class World(object):<br>    def __init__(self,rule=50):<br>        self.rule = rule<br>        self.im = Image.new(&quot;L&quot;,(WIDTH,HEIGHT))<br>        self.data = np.zeros(WIDTH*HEIGHT,dtype=np.uint8)<br>        b = bin(rule)[2:].zfill(8)<br>        Automata.rules = [True if c == &quot;1&quot; else False for c in b]<br>        self.list = list()<br>        self.step = 0<br>    <br>    def add(self):<br>        automata = Automata(len(self.list))<br>        self.list.append(automata)<br><br>    def update(self):<br>        for automata in self.list:<br><br>            automata.statePrev = automata.state<br>            p = self.list[automata.idx - 1].statePrev if automata.idx &gt; 0 else False<br>            n = self.list[automata.idx + 1].state if automata.idx &lt; len(self.list)-1 else False<br>            s = automata.state<br><br>            if p and s and n:<br>                automata.state = automata.rules[0]<br>            elif p and s and not n:<br>                automata.state = automata.rules[1]<br>            elif p and not s and n:<br>                automata.state = automata.rules[2]<br>            elif p and not s and not n:<br>                automata.state = automata.rules[3]<br>            elif not p and s and n:<br>                automata.state = automata.rules[4]<br>            elif not p and s and not n:<br>                automata.state = automata.rules[5]<br>            elif not p and not s and n:<br>                automata.state = automata.rules[6]<br>            elif not p and not s and not n:<br>                automata.state = automata.rules[7]<br>            <br><br>    def draw_row(self):<br>        if self.step == 0:<br>            middle = len(self.list) // 2<br>            self.list[middle].state = True<br>        for i,automata in enumerate(self.list):<br>            if automata.state:<br>                self.data[self.step*HEIGHT+i] = 255<br>        self.step += 1<br>    def save(self):<br>        self.im.putdata(self.data)<br>        self.im.save(&quot;RULE-%d.png&quot; % self.rule)<br></pre><br><br>Con esto ya lo tenemos casi todo. Ahora faltaría poner en marcha todo. La idea es simplemente crear una instancia de World, hacer unas cuantas llamadas a add, y después ir haciendo el ciclo update/draw_row. Una vez hayamos acabado, hacemos save y obtendremos un PNG con la imagen.<br><h2>Código completo</h2><br><br><pre class="lang:python decode:true"><br>import numpy as np<br>from PIL import Image<br><br>WIDTH = 5001<br>HEIGHT = 5001<br><br>class Automata(object):<br><br>    rules = list()<br><br>    def __init__(self,idx=0):<br>        self.idx = idx<br>        self.state = False<br>        self.statePrev = False<br><br>class World(object):<br>    def __init__(self,rule=50):<br>        self.rule = rule<br>        self.im = Image.new(&quot;L&quot;,(WIDTH,HEIGHT))<br>        self.data = np.zeros(WIDTH*HEIGHT,dtype=np.uint8)<br>        b = bin(rule)[2:].zfill(8)<br>        Automata.rules = [True if c == &quot;1&quot; else False for c in b]<br>        print(Automata.rules)<br>        self.list = list()<br>        self.step = 0<br>    <br>    def add(self):<br>        automata = Automata(len(self.list))<br>        self.list.append(automata)<br><br>    def update(self):<br>        for automata in self.list:<br><br>            automata.statePrev = automata.state<br>            p = self.list[automata.idx - 1].statePrev if automata.idx &gt; 0 else False<br>            n = self.list[automata.idx + 1].state if automata.idx &lt; len(self.list)-1 else False<br>            s = automata.state<br><br>            if p and s and n:<br>                automata.state = automata.rules[0]<br>            elif p and s and not n:<br>                automata.state = automata.rules[1]<br>            elif p and not s and n:<br>                automata.state = automata.rules[2]<br>            elif p and not s and not n:<br>                automata.state = automata.rules[3]<br>            elif not p and s and n:<br>                automata.state = automata.rules[4]<br>            elif not p and s and not n:<br>                automata.state = automata.rules[5]<br>            elif not p and not s and n:<br>                automata.state = automata.rules[6]<br>            elif not p and not s and not n:<br>                automata.state = automata.rules[7]<br>            <br><br>    def draw_row(self):<br>        if self.step == 0:<br>            middle = (len(self.list) // 2)<br>            self.list[middle].state = True<br>        for i,automata in enumerate(self.list):<br>            if automata.state:<br>                self.data[self.step*HEIGHT+i] = 255<br>        self.step += 1<br>    def save(self):<br>        self.im.putdata(self.data)<br>        self.im.save(&quot;RULE-%d.png&quot; % self.rule)<br>    def __str__(self):<br>        s = str()<br>        for l in self.list:<br>            s += &quot;T&quot; if l.state else &quot;F&quot;<br>        return s<br><br>def world_run(rule):<br>    world = World(rule)<br>    for _ in range(WIDTH):<br>        world.add()<br><br>    for _ in range(HEIGHT):<br>        world.draw_row()<br>        world.update()<br>    world.save()<br><br>def main():<br>    rule = input(&quot;Rule: &quot;)<br>    try:<br>        rule = int(rule)<br>        if 255 &gt;= rule &gt;= 0:<br>            world_run(rule)<br>            print(&quot;Check for the generated RULE-%d.png file&quot; % rule)<br>        else:<br>            raise ValueError<br>    except ValueError:<br>        print(&quot;Please, insert a number between 0 and 255&quot;)<br>        main()<br><br>if __name__ == &quot;__main__&quot;:<br>    main()<br></pre><br><br><h2>Algunas reglas importantes</h2><br><h3>Regla 30</h3><br>Una de las más importantes a nivel matemático. Ha sido objeto de mucho estudio, sin embargo no vamos a entrar en detalles más allá de su aspecto visual.<br><br><a href="https://files.adrianistan.eu/Rule-30.png"><img class="aligncenter size-large wp-image-1004" src="https://files.adrianistan.eu/Rule-30-1024x1024.png" alt="" width="840" height="840" /></a><br><br><a href="https://files.adrianistan.eu/Rule-30-detalle.png"><img class="size-full wp-image-1005" src="https://files.adrianistan.eu/Rule-30-detalle.png" alt="" width="744" height="744" /></a> Vista ampliada<br><h3>Regla 110</h3><br>Esta regla es también muy interesante. ¡Se demostró que era Turing completa!<br><br><a href="https://files.adrianistan.eu/Rule-110.png"><img class="aligncenter size-large wp-image-1006" src="https://files.adrianistan.eu/Rule-110-1024x1024.png" alt="" width="840" height="840" /></a><br><br><a href="https://files.adrianistan.eu/Rule-110-detalle.png"><img class="size-large wp-image-1007" src="https://files.adrianistan.eu/Rule-110-detalle-1024x1024.png" alt="" width="840" height="840" /></a> Vista en detalle<br><h2>Regla 126</h2><br>Esta regla no es tan importante, pero personalmente me parece muy bonita.<br><br><a href="https://files.adrianistan.eu/Rule-126.png"><img class="aligncenter size-large wp-image-1008" src="https://files.adrianistan.eu/Rule-126-1024x1024.png" alt="" width="840" height="840" /></a><br><br><a href="https://files.adrianistan.eu/Rule-126-detalle.png"><img class="size-full wp-image-1009" src="https://files.adrianistan.eu/Rule-126-detalle.png" alt="" width="500" height="500" /></a> Vista ampliada<br><h3>Reglas 57 y 99</h3><br>Son dos reglas isomorfas. Es decir, son en realidad la misma regla pero aplicada a lados distintos. Elijo estas dos porque se aprecia muy bien el isomorfismo.<br><br><a href="https://files.adrianistan.eu/Rule-57.png"><img class="size-large wp-image-1010" src="https://files.adrianistan.eu/Rule-57-1024x1024.png" alt="" width="840" height="840" /></a> Regla 57<br><br><a href="https://files.adrianistan.eu/Rule-99.png"><img class="size-large wp-image-1011" src="https://files.adrianistan.eu/Rule-99-1024x1024.png" alt="" width="840" height="840" /></a> Regla 99<br><h2>Regla 169</h2><br><a href="https://files.adrianistan.eu/Rule-169.png"><img class="aligncenter size-large wp-image-1012" src="https://files.adrianistan.eu/Rule-169-1024x1024.png" alt="" width="840" height="840" /></a><br><br><a href="https://files.adrianistan.eu/Rule-169-detalle.png"><img class="size-full wp-image-1013" src="https://files.adrianistan.eu/Rule-169-detalle.png" alt="" width="500" height="500" /></a> Vista en detalle<br><h3>Regla 129</h3><br><h2><a href="https://files.adrianistan.eu/Rule-129.png"><img class="aligncenter size-large wp-image-1014" src="https://files.adrianistan.eu/Rule-129-1024x1024.png" alt="" width="840" height="840" /></a>Regla 90</h2><br>Es el famoso <a href="https://blog.adrianistan.eu/2017/05/24/triangulo-sierpinski-javascript/">triángulo de Sierpinski</a>.<br><h3><a href="https://files.adrianistan.eu/Rule-90.png"><img class="aligncenter size-large wp-image-1015" src="https://files.adrianistan.eu/Rule-90-1024x1024.png" alt="" width="840" height="840" /></a>Regla 150</h3><br><h2><a href="https://files.adrianistan.eu/Rule-150.png"><img class="aligncenter size-large wp-image-1016" src="https://files.adrianistan.eu/Rule-150-1024x1024.png" alt="" width="840" height="840" /></a>Regla 105</h2><br>Esta regla no tiene isomorfo.<br><br><a href="https://files.adrianistan.eu/Rule-105.png"><img class="aligncenter size-large wp-image-1017" src="https://files.adrianistan.eu/Rule-105-1024x1024.png" alt="" width="840" height="840" /></a>En este artículo no he querido entrar en las complejidades matemáticas de todo esto. Es algo que todavía no entiendo así que no sería sincero por mi parte exponerlo.<br><h2>Bonus: Richard Feynman y Steve Jobs</h2><br>Quien me conoce sabe de sobra que uno de los personajes de la historia que más ha influido en mi vida es <a href="https://blog.adrianistan.eu/2017/02/16/esta-usted-broma-sr-feynman/">Richard Feynman</a>. Debo reconocer que entré en un estado de éxtasis al descubrir que Feynman y Wolfram no solo trabajaron juntos, sino que lo hicieron alrededor de la regla 30 antes mostrada. También me sorprendió que Steve Jobs y Wolfram resultasen ser <em>amigos de toda la vida</em>. No dejo de sorprenderme de los contactos de ciertos personajes históricos entre sí.<br><br><a href="https://files.adrianistan.eu/Slide006.jpg"><img class="size-full wp-image-1019" src="https://files.adrianistan.eu/Slide006.jpg" alt="" width="700" height="637" /></a> Feynman a la izquierda, Wolfram a la derecha