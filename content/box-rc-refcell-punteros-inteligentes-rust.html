Hasta ahora hemos trabajado con tipos primitivos, con estructuras o con tipos de la librería estándar como <strong>String</strong> o <strong>Vec</strong>. Sin embargo, ¿si queremos implementar algo similar a <strong>String</strong> como lo haríamos? Aquí entran en juego, los punteros inteligentes, punteros con capacidades extra. Los más importantes son <strong>Box,</strong> <strong>Rc y RefCell</strong>.<br><h2>Box, reservar memoria en el heap</h2><br>Box es parecido a malloc de C. Reservan memoria en la parte alta de la memoria. El uso principal de Box en Rust es el de implementar estructuras de datos cíclicas o recursivas.<br><br><pre class="lang:rust decode:true"><br>fn main() {<br>    let n = Box::new(42);<br>    println!(&quot;n = {}&quot;, n);<br>}<br></pre><br><br>No es muy útil usarlo así. Solo compensa usarlo en situaciones donde es necesario que la variable ocupe un tamaño fijo, que a priori es indeterminado.<br><h2>Rc, ¡viva la multipropiedad!</h2><br><strong>Rc</strong> es un puntero inteligente algo más interesante. Permite que un dato sea propiedad de varias variables a la vez. Funciona con un mecanismo de recolector de basura. La clave está en que cuando hagamos <strong>clone</strong> de un <strong>Rc</strong> no obtendremos una copia exacta, sino una referencia más al dato original. Esto permite ahorrar memoria. Veamos en un ejemplo, como Regex se comparte entre varias variables. Se trata del mismo Regex, en ningún momento ocurre una duplicidad en memoria.<br><br><pre class="lang:rust decode:true"><br>extern crate regex;<br><br>use regex::Regex;<br>use std::rc::Rc;<br><br><br>fn main() {<br>    let r = Rc::new(Regex::new(r&quot;([A-Za-z0-9])([.]|[_]|[A-Za-z0-9])+@gmail.com&quot;).unwrap());<br>    if r.is_match(&quot;pucela_segunda@gmail.com&quot;) {<br>        println!(&quot;Correo válido de Gmail&quot;);<br>    }else{<br>        println!(&quot;Correo no válido de Gmail&quot;);<br>    }<br><br>    let puntero = r.clone();<br>    println!(&quot;Reference Count: {}&quot;,Rc::strong_count(&amp;puntero));<br>    puntero.is_match(&quot;perro@gmail.com&quot;);<br>    r.is_match(&quot;_pepe@gmail.com&quot;);<br>}<br></pre><br><br>La línea <em>Reference Count</em> nos dice cuantas variables tienen ahora mismo acceso a ese dato. <strong>Rc</strong> funciona a la perfección en un solo hilo, pero si quieres hacer lo mismo entre hilos debes usar <strong>Arc</strong>. <strong>Rc</strong> por sí mismo, solo permite lecturas, es cuando lo juntamos con <strong>RefCell</strong> cuando obtenemos soporte de escritura.<br><h2>RefCell, saltándonos las normas</h2><br>En primer lugar, <strong>RefCell</strong> es muy interesante y poderoso, pero no es recomendable usarlo si se pueden usar otros métodos. Digamos que <strong>RefCell</strong> permite llevar las normas del compilador de Rust sobre préstamos y dueños al runtime. Esto puede provocar crasheos así que normalmente se usa con <strong>Rc</strong> que previene estas situaciones.<br><br><pre class="lang:rust decode:true"><br>use std::rc::Rc;<br>use std::cell::RefCell;<br><br>fn main(){<br>    let n = Rc::new(RefCell::new(42));<br>    let x = n.clone();<br>    let y = n.clone();<br>    *x.borrow_mut() += 10;<br>    *y.borrow_mut() += 10;<br>    println!(&quot;N: {:?}&quot;,n.borrow());<br>}<br></pre><br><br>El resultado de este código es 62. Por tanto, hemos conseguido que distintas variables pudiesen mutar el dato.<br><br>Con esto ya hemos visto los punteros inteligentes más importantes de Rust. Existe alguno más como <strong>Cell</strong> que sin embargo, no es tan usado.<br><br>&nbsp;