Seguimos en <a href="https://blog.adrianistan.eu/rust-101-tutorial-rust-espanol/">Rust 101, el tutorial de Rust en español</a>, y ahora vamos a ver como trabaja Rust con las variables. En este aspecto no se distingue demasiado de otros lenguajes imperativos, aunque vamos a ver que la inferencia de tipos nos va a ayudar. También vamos a ver tipos de datos más complejos.<br><h2>Declaración de variables</h2><br>En Rust las variables de declaran usando la palabra reservada <strong>let</strong>. El tipo de la variable puede inferirse pero en ocasiones podemos ayudar al compilador indicando el tipo del que queramos que sea la variable.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let x = 42;<br>    let url = &quot;http://adrianistan.eu&quot;;<br><br>    println!(&quot;{}&quot;,url);<br>}<br></pre><br><br>Sin embargo hay una diferencia importante respecto a otros lenguajes y es que aquí las variables serán por defecto inmutables. Tratar de hacer esto:<br><br><pre class="lang:rust decode:true"><br>x += 5;<br></pre><br><br>causará un error de compilación. No obstante, esta limitación puede saltarse aplicando el modificador <strong>mut</strong>. Aunque las variables puedan volverse mutables esto ya nos avisa de que Rust tiene muy presente conceptos de programación funcional más pura (como podemos tener en <a href="http://haskell.org">Haskell</a>, <a href="http://elm-lang.org">Elm</a>, F# u OCaml).<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let mut x = 42;<br>    x += 5;<br>    println!(&quot;{}&quot;,x);<br>}<br><br>Para espeficicar un tipo usamos una notación de dos puntos después de &lt;strong&gt;let&lt;/strong&gt;.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let x: i32 = 5; // int 32 bits<br>    let y: f64 = 5; // float 64 bits<br>}<br></pre><br><br><h2>Arrays y vectores</h2><br>Hasta ahora hemos podido ver en acción variables de tipos de datos más o menos primitivos. Ahora vamos a ver dos estructuras de datos similares, aunque diferentes. Digamos para simplificar, que los arrays tienen tamaño fijo y los vectores no.<br><br><pre class="lang:rust decode:true"><br>fn main() {<br>        let mut notas_array: [i32;5] = [0;5];<br>        notas_array[0] = 1;<br>        notas_array[1] = 6;<br><br>        let mut notas_vec: Vec&lt;i32&gt; = vec!();<br>        notas_vec.push(1);<br>        notas_vec.push(6);<br><br>        println!(&quot;Nota 2: {}&quot;,notas_array[1]);<br>        println!(&quot;Nota 2: {}&quot;,notas_vec[1]);<br>}<br></pre><br><br>En este caso inicializamos un array todo a cero de 5 posiciones y también un vector. He dejado las marcas de los tipos, aunque no son necesarias.<br><h2>Constantes, let shadowing y casting</h2><br>Rust soporta constantes con la palabra reservada <strong>const</strong>. La convención es usar SCREAMING_SNAKE_CASE para las constantes. El valor de una constante es inmutable y a diferencia de <strong>let</strong>, no se puede reescribir. ¿Espera, las variables con <strong>let</strong> se pueden reescribir? En efecto, es posible definir una variable posteriormente, de tipo totalmente distinto con el mismo nombre. En este ejemplo vamos a ver el uso de <strong>const</strong> y el uso de <em>let shadowing</em>.<br><br><pre class="lang:rust decode:true"><br>const PI: f64 = 3.14;<br><br>fn main(){<br>    let x = 42;<br>    let x = (x as f64) + PI;<br>    println!(&quot;{}&quot;,x);<br><br>}<br></pre><br><br>Además podemos apreciar como se realiza <strong>casting</strong> en Rust. Se usa la palabra reservada <strong>as</strong> y se indica el tipo al que queremos hacer cast. En este ejemplo de <em>let shadowing</em> podemos apreciar como no solo hemos redefinido x, sino que lo hemos hecho de otro tipo. En la primera línea, x es de tipo i32, en la segunda pasa a ser f64.<br><h2>Tuplas</h2><br>Las tuplas pueden resultar algo novedoso a quien venga de ciertos lenguajes, pero no son elementos realmente nuevos. Podría entenderse una tupla como una estructura sin nombre. Se trata de una especie de array donde cada elemento puede ser de un tipo, pero espeificado de antemano. Lo veremos mejor con ejemplos.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let tupla = (42,&quot;Adrianistán&quot;,true);<br>    let (random,country,has_beers) = tupla;<br>    println!(&quot;{}&quot;,random);<br>    let (_,country,_) = tupla;<br>    println!(&quot;{}&quot;,country);<br>    let has_beers = tupla.2;<br><br>}<br></pre><br><br>Aquí podemos observar como se forma una tupla, compuesta por un entero, un texto y un booleano. La sentencia con let desestructura la tupla y se obtienen 3 variables con los valores de los 3 campos de la tupla. Es posible que en algunas situaciones no nos importe algún campo. Para ignorar algún campo, dejamos una barra baja. También existe la sintaxis punto para acceder a elementos de la tupla. Para ello indicamos el orden dentro de la tupla del elemento que queremos. No obstante, no es tan claro como desestructurar la tupla.<br><h2>Expresiones avanzadas con let</h2><br>let admite cualquier expresión. Esto es una práctica habitual en muchos lenguajes imperativos, sin embargo, las expresiones en Rust son más amplias de lo que vemos a simple vista.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let age = 65;<br>    let x = if age &gt; 17 {<br>        &quot;Mayor de edad&quot;<br>    }else{<br>        &quot;Menor de edad&quot;<br>    };<br>    println!(&quot;{}&quot;,x);<br><br>}<br></pre><br><br>Por ejemplo, una estructura condicional if-else es una expresión. Un ojo avizado podría decir que este código está mal, que falta el punto y coma. Realmente no es así, en Rust si algo no lleva punto y coma se vuelve una expresión. Más bien, al no llevar punto y coma no se vuelve un <em>statement</em>. Esto puede aplicarse a cualquier tipo de código que no deja de ser una expresión.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let age = 65;<br>    let a = 10;<br>    let b = 25;<br>    let x = {<br>        let u = a*b;<br>        u+age<br>    };<br>    println!(&quot;{}&quot;,x);<br><br>}<br></pre><br><br>Y como véis, se puede complicar hasta niveles muy elevados. Al principio puede no ser muy natural, pero es bastante cómodo en muchas situaciones.<br><br>Con esto acabamos nuestra visita a las variables.