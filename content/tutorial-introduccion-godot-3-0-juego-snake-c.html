Llegó el día. <a href="https://godotengine.org/article/godot-3-0-released">Godot 3.0 salió a la luz</a>. Se trata de una versión con muchas mejoras respecto a Godot 2.x. Se trata de un motor de videojuegos software libre, compatible con la mayoría de sistemas operativos (y consolas a través de una compañía privada). Aprovechando la ocasión voy a explicar como hacer un juego simple, usando C# y el motor 2D de Godot. Este tutorial sirve para familiarizarse con el motor.<br><h2>Instalando Godot</h2><br>Lo primero que tenemos que hacer es instalar Godot. Para ello vamos a la <a href="https://godotengine.org/download">página de descarga</a> y descargamos la versión que corresponda a nuestro sistema con Mono.<br><br><a href="https://files.adrianistan.eu/GodotDownload.png"><img class="aligncenter size-large wp-image-1300" src="https://files.adrianistan.eu/GodotDownload-1024x567.png" alt="" width="840" height="465" /></a>Es requisito indispensable tener instalado <strong>Mono SDK</strong>, tanto en Linux como en Windows. El Mono SDK se descarga desde <a href="http://www.mono-project.com/download/">http://www.mono-project.com/download/</a>.<br><br>Una vez descargado tendremos un fichero con tres archivos. Descomprímelos en una carpeta. Ahora simplemente puedes ejecutar el fichero ejecutable.<br><h2>Ventana de proyectos</h2><br>Nada más arrancar tendremos una ventana de proyectos. Desde ahí podemos abrir proyectos que hayamos creado, descargar demos y plantillas o simplemente crear un proyecto nuevo.<br><br><a href="https://files.adrianistan.eu/GodotProyectos.png"><img class="aligncenter size-large wp-image-1301" src="https://files.adrianistan.eu/GodotProyectos-1024x576.png" alt="" width="840" height="473" /></a>Si le damos a <em>Proyecto nuevo</em> procederemos a la creación de un nuevo proyecto (¡¿qué complicado, verdad?!).<br><br>Una vez hecho esto ya estaríamos en el editor propiamente dicho.<br><br><a href="https://files.adrianistan.eu/GodotEditor.png"><img class="aligncenter size-large wp-image-1302" src="https://files.adrianistan.eu/GodotEditor-1024x576.png" alt="" width="840" height="473" /></a><br><h2>Editor</h2><br>Rápidamente cambiamos al modo 2D y hacemos zoom hacia atrás. Vamos a ajustar la pantalla. Para ello vamos a <em>Proyecto-&gt;Ajustes de proyecto</em>. Buscamos el apartado <em>Display-&gt;Window</em> y ajustamos la resolución base. Esta será la que usaremos para poner los elementos en pantalla. Después vamos a <em>Stretch </em>y configuramos el modo 2D y mantener el aspect ratio.<br><br>Esta configuración sirve para empezar con juegos simples en 2D puedan escalar fácilmente a distintas pantallas sin tener problemas de descuadres.<br><br><a href="https://files.adrianistan.eu/GodotWindowSettings.png"><img class="aligncenter size-large wp-image-1303" src="https://files.adrianistan.eu/GodotWindowSettings-1024x576.png" alt="" width="840" height="473" /></a>Ahora hacemos click en el más (+) para añadir un nodo a la escena.<br><br>Para nuestro juego, voy a añadir un <strong>Node2D</strong>, que hereda de <strong>CanvasItem</strong> y tiene APIs para dibujar rectángulos y círculos..<br><br><a href="https://files.adrianistan.eu/GodotNode2D.png"><img class="aligncenter size-large wp-image-1304" src="https://files.adrianistan.eu/GodotNode2D-1024x575.png" alt="" width="840" height="472" /></a>No lo tocamos y hacemos click derecho en el Nodo. Damos click a Attach Script:<br><br><a href="https://files.adrianistan.eu/GodotAttachScript.png"><img class="aligncenter size-large wp-image-1305" src="https://files.adrianistan.eu/GodotAttachScript-1024x576.png" alt="" width="840" height="473" /></a>Es importante tener un nombre de script <strong>distinto</strong> a Node2D. Esto puede dar problemas. Una vez hecho esto, se nos mostrará esta pantalla, que nos permite escribir el código en C#. A partir de ahora voy a usar Visual Studio Code, porque lo considero mejor para escribir código en C# que el editor de Godot. Creamos también dos Sprite hijos del Node2D. Apple y SnakeBody van a llamarse y les creamos scripts de C# también.<br><br><a href="https://files.adrianistan.eu/GodotNodes.png"><img class="aligncenter size-large wp-image-1306" src="https://files.adrianistan.eu/GodotNodes-1024x576.png" alt="" width="840" height="473" /></a><br><h2>Dibujar en pantalla</h2><br>Abrimos con el VS Code el fichero .cs que hemos creado, en mi caso, Snake.cs.<br><br>Dentro veremos una clase con dos funciones, <strong>_Ready</strong> y <strong>_Process</strong>. Estas son solo un ejemplo de las funciones que podemos sobreescribir en las clases asociadas a nodos. Otras funciones serían: <strong>_Draw, _Input</strong>. ¿Cuándo tenemos que usar cada una? Ready es una especie de constructor, ahí inicializamos todo lo que haga falta. Process es llamada constantemente, ahí hacemos las actualizaciones y comprobaciones pertinentes. Draw permite dibujar (si no trabajamos con imágenes es muy útil). Draw no se llama útil. ¿Qué tenemos que hacer en Snake.cs? Bueno, hay que tener un timer para ir generando manzanas, así como comprobar que la serpiente se ha comido la manzana.<br><pre class="lang:c# decode:true" title="Snake.cs">using Godot;<br>using System;<br>using System.Timers;<br><br>public class Snake : Node2D<br>{<br>    // 640x360<br>    // casillas de 40x40 (mcd 640,360)<br>    private System.Timers.Timer timer; // usamos los timers de .NET<br>    private static readonly Random rnd = new Random(); // random de .NET<br>    private Apple apple; // manzana activa<br>    private SnakeBody body; // serpiente<br>    public override void _Ready()<br>    {<br>        body = GetNode("SnakeBody") as SnakeBody; // obtenemos el nodo SnakeBody<br>        body.Position = new Vector2(0,0); // arriba a la izquierda<br>        timer = new System.Timers.Timer(10000); // cada 10 s<br>        timer.Elapsed += NewApple; // se llama a NewApple<br>        timer.AutoReset = true; // de forma infinita<br>        timer.Start(); // y empezamos a contar ya!<br>        apple = GetNode("Apple") as Apple; // obtenemos el nodo Apple<br>        apple.Position = new Vector2(rnd.Next(15)*40,rnd.Next(8)*40); // posicion aleatoria<br>    }<br><br>    public void NewApple(object src ,ElapsedEventArgs e)<br>    {<br>        if(apple != null){<br>            RemoveChild(apple); // quita el nodo de la escena si estaba<br>        }<br>        apple = new Apple();<br>        apple.Position = new Vector2(rnd.Next(0,15)*40,rnd.Next(0,8)*40);<br>        AddChild(apple); // anade motor a la escena<br>    }<br><br>    public override void _Process(float delta)<br>    {<br>        // siempre se comprueba si la serpiente se come la manzana<br>        if(apple != null){<br>            if(body.TryEat(apple)){<br>                RemoveChild(apple);<br>                apple = null;<br>            }<br>        }<br>        <br>    }<br>}</pre><br>En este código ya vemos cosas interesantes. La primera es que podemos usar cualquier librería de .NET, en este caso he usado clases que forman parte de .NET Standard pero cualquier librería que funcione con Mono debería funcionar. También se puede usar NuGet, al final, Godot tiene un fichero SLN y un CSPROJ, por lo que no es más que un proyecto normal de C#.<br><br>La segunda cosa es que hay varias funciones para interactuar con Godot en sí: <strong>GetNode</strong> (para obtener un nodo, hay que hacer casting), <strong>AddChild</strong> (para añadir un nodo a una escena) y <strong>RemoveChild</strong> (para quitar un nodo a una escena).<br><pre class="lang:c# decode:true" title="SnakeBody.cs">using Godot;<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br><br>public class SnakeBody : Sprite<br>{<br>    private float time = 0;<br>    private enum Direction{<br>        LEFT,<br>        RIGHT,<br>        UP,<br>        DOWN<br>    };<br>    private Direction direction;<br>    private List&lt;Rect2&gt; body;<br>    private bool eat = false;<br>    public override void _Ready()<br>    {<br>        // Called every time the node is added to the scene.<br>        // Initialization here<br>        direction = Direction.RIGHT;<br>        body = new List&lt;Rect2&gt;();<br>        body.Add(new Rect2(0,0,40,40));<br>        body.Add(new Rect2(40,0,40,40));<br>        SetZIndex(1);<br>    }<br><br>    public override void _Draw()<br>    {<br>        var color = new Color(1,0,0);<br>        foreach(var rect in body){<br>            this.DrawRect(new Rect2(rect.Position.x+2,rect.Position.y+2,36,36),color);<br>        }<br>    }<br><br>    public bool TryEat(Apple apple)<br>    {<br>        if(body[0].Position.x == apple.Position.x &amp;&amp; body[0].Position.y == apple.Position.y){<br>            Console.WriteLine("EAT!");<br>            eat = true;<br>        }<br><br>        return eat;<br>    }<br><br>    public bool Crash()<br>    {<br>        return body.Skip(1).Any(t=&gt;{<br>            return t.Position.x == body[0].Position.x &amp;&amp; t.Position.y == body[0].Position.y;<br>        });<br>    }<br><br>    public override void _Process(float delta)<br>    {<br>        // Called every frame. Delta is time since last frame.<br>        // Update game logic here.<br>        time += delta;<br>        if(time &gt; 0.5){<br>            Vector2 translation;<br>            switch(direction){<br>                case Direction.RIGHT: translation=new Vector2(40,0);break;<br>                case Direction.LEFT: translation=new Vector2(-40,0);break;<br>                case Direction.UP: translation = new Vector2(0,-40);break;<br>                default: translation = new Vector2(0,40);break;<br>            }<br>            if(body.Count &gt; 0){<br>                var newRect = new Rect2(body[0].Position,body[0].Size);<br>                newRect.Position += translation;<br>                if(newRect.Position.x &lt; 0){<br>                    newRect.Position = new Vector2(600,newRect.Position.y);<br>                }<br>                if(newRect.Position.x &gt; 600){<br>                    newRect.Position = new Vector2(0,newRect.Position.y);<br>                }<br>                if(newRect.Position.y &lt; 0){<br>                    newRect.Position = new Vector2(newRect.Position.x,320);<br>                }    <br>                if(newRect.Position.y &gt; 320){<br>                    newRect.Position = new Vector2(newRect.Position.x,0);<br>                }<br><br>                body.Insert(0,newRect);<br>                if(!eat){<br>                    body.RemoveAt(body.Count-1);<br>                }<br>                if(Crash()){<br>                    Console.WriteLine("CRASH! Game Over");<br>                }<br>            }<br>            this.Update();<br>            time = 0;<br>            eat = false;<br>        }<br>    }<br><br>    public override void _Input(InputEvent @event)<br>    {<br>        if(@event.IsAction("move_left") &amp;&amp; direction != Direction.RIGHT)<br>        {<br>            direction = Direction.LEFT;<br>            return;<br>        }<br>        if(@event.IsAction("move_right") &amp;&amp; direction != Direction.LEFT)<br>        {<br>            direction = Direction.RIGHT;<br>            return;<br>        }<br>        if(@event.IsAction("move_up") &amp;&amp; direction != Direction.DOWN)<br>        {<br>            direction = Direction.UP;<br>            return;<br>        }<br>        if(@event.IsAction("move_down") &amp;&amp; direction != Direction.UP)<br>        {<br>            direction = Direction.DOWN;<br>            return;<br>        }<br>    }<br>}</pre><br>El código de <strong>SnakeBody.cs</strong> es más largo, pero no más complejo. Como vemos la serpiente la represento como <strong>List&lt;Rect2&gt;</strong>. Además hay una variable <strong>time</strong> puesta para que la serpiente vaya a trompicones (como el snake auténtico).<br><br>Se puede ver como la función <strong>DrawRect</strong> nos sirve para dibujar un rectángulo. La API no tiene pérdida y es parecida a la API de Cairo o la Canvas de HTML5.<br><br>También se puede ver como se puede usar LINQ para comprobar las intersecciones de la serpiente consigo misma (en realidad se comprueba la cabeza con el resto de trozos, ya que la cabeza es la parte que va a estar presente en todos los golpes).<br><br>Con <strong>Update</strong> se fuerza una nueva llamada a _Draw.<br><br>Por último tenemos <strong>_Input</strong>. En Godot, la entrada se maneja por <strong>acciones</strong>, una capa de abstracción. Esto quiere decir que no es recomendable comprobar si una tecla ha sido pulsada, simplemente se asignan teclas a acciones desde Godot (o desde el juego en un panel de configuración) y en nuestro código comprobar las acciones.<br><h2>Crear acciones</h2><br>Para crear acciones vamos a <em>Proyecto-&gt;Ajustes de Proyecto-&gt;Mapa de entrada</em> y creamos las acciones que creamos convenientes. Yo las he llamado <strong>move_left, move_right, move_down</strong> y<strong> move_up</strong>. Luego las asignamos teclas de forma muy intuitiva.<br><br><a href="https://files.adrianistan.eu/GodotKeymap.png"><img class="aligncenter size-large wp-image-1307" src="https://files.adrianistan.eu/GodotKeymap-1024x576.png" alt="" width="840" height="473" /></a>Con esto ya tendríamos todo para un snake completito. Si le damos a ejecutar, podemos ver el juego en acción.<br><br><a href="https://files.adrianistan.eu/GodotSnake.png"><img class="aligncenter size-large wp-image-1308" src="https://files.adrianistan.eu/GodotSnake-1024x576.png" alt="" width="840" height="473" /></a><a href="https://files.adrianistan.eu/GodotSnake-2.png"><img class="aligncenter size-large wp-image-1309" src="https://files.adrianistan.eu/GodotSnake-2-1024x576.png" alt="" width="840" height="473" /></a> <a href="https://files.adrianistan.eu/GodotSnake-3.png"><img class="aligncenter size-large wp-image-1310" src="https://files.adrianistan.eu/GodotSnake-3-1024x576.png" alt="" width="840" height="473" /></a>Todo el código del juego lo tenéis en el <a href="https://github.com/aarroyoc/blog-ejemplos/tree/master/snake">GitHub de ejemplos del blog</a> y se puede importar a vuestro Godot.<br><br>&nbsp;<br><br>Al juego le faltan muchas cosas, como una pantalla de game over cuando se produce un choque. Y puntuación. Y más detalles. Pero eso ya os lo dejo a vosotros.<br><br>&nbsp;