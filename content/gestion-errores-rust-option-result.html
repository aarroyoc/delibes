¿Conoces el error del billón de dólares? Tony Hoare es un reputado estudioso de la ciencia de la computación. Cuando se encontraba diseñando ALGOL W, se le ocurrió incorporar la referencia a NULL. Sin embargo, los errores informáticos que ha propiciado su existencia han supuesto pérdidas económicas superiores al billón de dólares. Es por ello que él mismo denominó a su creación, el error del billón de dólares.<br><br>El uso de NULL puede traer muchas consecuencias negativas, pero como el propio Hoare dijo: <em>era tan fácil de implementar que no pude resistirme</em>. Además, usarlo es fácil. Existen lenguajes sin NULL desde hace tiempo pero su uso no es muy frecuente y ciertamente, añaden complejidad a la programación. Rust soluciona esto con dos objetos muy sencillos de utilizar, Option y Result.<br><h2>Option y Result</h2><br>Ambos son objetos que sirven para llevar cualquier otro valor. Hemos de desempapelarlos para sacar el verdadero valor, si es que existe. Option en realidad es un <strong>enum</strong> con dos posibles valores: <strong>Some</strong> y <strong>None</strong>. Result también es un <strong>enum</strong> con dos posibles valores: <strong>Ok</strong> y <strong>Err</strong>.<br><h2>¿Cuándo usar Option y cuándo usar Result?</h2><br>Esta duda es muy frecuente ya que funcionan de manera muy similar. La regla general es que Result tiene que usarse con errores y si no se tratan, cerrar el programa, mientras que Option lleva cosas que pueden estar o no, pero su inexistencia no conlleva un error.<br><h2>Uso</h2><br>Option es algo más sencilla de usar.<br><br><pre class="lang:rust decode:true"><br>let opt: Option&lt;i32&gt; = Some(42);<br>let opt: Option&lt;i32&gt; = None;<br></pre><br><br>En Result hay que indicar el tipo del valor correcto y del valor de error que se comunique.<br><br><pre class="lang:rust decode:true"><br>let operacion_peligrosa: Result&lt;i32,String&gt; = Ok(42);<br>let operacion_peligrosa: Result&lt;i32,String&gt; = Err(String::from(&quot;La operación ha fallado&quot;));<br></pre><br><br><h2>if-let</h2><br>Option y Result pueden integrarse con estructuras de control para un manejo idomático de estas situaciones. Un ejemplo es <strong>if-let</strong>. Imagina un perfil de una aplicación web. Hay campos obligatorios, como usuario y contraseña, pero otros no, como la página web.<br><br><pre class="lang:rust decode:true"><br>struct Perfil{<br>    username: String,<br>    password: String,<br>    url: Option&lt;String&gt;<br>}<br><br>impl Perfil{<br>    fn new(u: String, p: String) -&gt; Self{<br>        Perfil {username: u, password: p, url: None}<br>    }<br>}<br><br>fn main(){<br>    let mut p1 = Perfil::new(String::from(&quot;aarroyoc&quot;),String::from(&quot;1234&quot;));<br>    let mut p2 = Perfil::new(String::from(&quot;The42&quot;),String::from(&quot;incorrect&quot;));<br><br>    p1.url = Some(String::from(&quot;https://blog.adrianistan.eu&quot;));<br><br>    for perfil in [p1,p2].iter() {<br>        let url = perfil.url.clone();<br>        if let Some(url) = url{<br>            println!(&quot;URL: {}&quot;,url);<br>        }<br>    }<br><br>}<br></pre><br><br><h2>try!</h2><br><strong>try!</strong> es una macro que permite manejar con mayor claridad las operaciones que puedan generar muchos errores. <strong>try!</strong> solo se puede usar en funciones que devuelvan Result. Básicamente, <strong>try!</strong> devuelve inmediatamente el Err correspondiente si la operación resultante no ha sido exitosa, permitiendo una salida antes de tiempo y un código mucho más limpio.<br><br><pre class="lang:rust decode:true"><br>fn peligro() -&gt; Result&lt;i32,String&gt;{<br>    Err(String::from(&quot;Operación inválida&quot;))<br>}<br><br>fn funcion_error() -&gt; Result&lt;i32,String&gt;{<br>    let n = try!(peligro()); // aquí ya se sale de la función<br>    Ok(n)<br>}<br><br>fn main(){<br>    let n = funcion_error().unwrap();<br>    <br>}<br></pre><br><br>La macro <strong>try!</strong> es tan usada dentro de Rust que dispone de azúcar sintáctico, el símbolo de interrogación <strong>?</strong>.<br><br><pre class="lang:rust decode:true"><br>fn peligro() -&gt; Result&lt;i32,String&gt;{<br>    Err(String::from(&quot;Operación inválida&quot;))<br>}<br><br>fn funcion_error() -&gt; Result&lt;i32,String&gt;{<br>    let n = peligro()?;<br>    Ok(n)<br>}<br><br>fn main(){<br>    let n = funcion_error().unwrap();<br>}<br></pre><br><br>&nbsp;<br><h2>Unwrap</h2><br>Vamos a observar las operaciones de desempapelado que existen para Option y Result. La más básica es <strong>unwrap</strong>. Intenta desempapelar el valor, si resulta que el Result/Option era un Err/None, el programa crashea.<br><br><strong>unwrap_or</strong> intenta desempapelar y si el valor no existe, se sustituye por el valor indicado en el or.<br><br><strong>unwrap_or_else</strong> es similar a <strong>unwrap_or</strong> pero toma una función como parámetro. Así es posible crear una cadena de intentos.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    // let n = function_error().unwrap(); crash<br>    let n = function_error().unwrap_or(7);<br>    let n = funcion_error().unwrap_or_else(|t|{<br>        7<br>    });<br>    println!(&quot;{}&quot;,n);<br>}<br></pre><br><br>Existen muchas más opciones, como <strong>and, </strong><strong>expect</strong> o iterar sobre un Option/Result.<br><h2>panic!</h2><br>Si nos gustan los crasheos (!) podemos forzarlos con la macro <strong>panic!</strong>. Crashea el programa con el mensaje que indiquemos<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    panic!(&quot;Adiós muy buenas&quot;);<br>}<br></pre><br><br>Y con esto hemos visto lo suficiente del manejo de errores en Rust.