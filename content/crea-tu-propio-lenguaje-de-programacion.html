Esta entrada la escribí en <a href="http://blog.desdelinux.net/crea-tu-propio-lenguaje-de-programacion/">DesdeLinux</a> hace ya un tiempo y la quiero conservar aquí. La entrada no es la original sino que la he modificado para que siga vigente - <strong>MAYO DE 2015</strong><br><br><img class="alignnone size-full wp-image-63" src="https://files.adrianistan.eu/LenguajesProgramacion.jpg" alt="LenguajesProgramacion" width="600" height="250" /><br><br>Después de escribir el primer artículo sobre cómo crear tu propio sistema operativo, alguien me dijo que si podía hacer un artículo sobre cómo crear un lenguaje de programación. Al principio no hice mucho caso, pero ahora y por otros caminos he aprendido bastante más sobre la creación de los lenguajes de programación. Así pues, vamos a hacer un lenguaje de programación básico, fácilmente empotrable en otros programas y que funcione con una máquina virtual que también diseñaremos. Hoy nos toca hacer la máquina virtual más básica.<br><br>Probablemente te preguntes: “¿una máquina virtual? ¿Pero eso no es muy difícil y además ralentiza los programas?” Al contrario, una máquina virtual simple es muy sencilla y relativamente rápida. He elegido Rust como lenguaje para la máquina virtual. Pero, ¿qué es <a href="http://rust-lang.org">Rust</a>?<br><blockquote><a href="http://rust-lang.org">Rust</a> es un lenguaje de programación que está enfocado en la seguridad en las ejecuciones, así que utilizándolo será prácticamente imposible que alguien consiga cerrar la máquina virtual. Es un lenguaje compilado en desarrollo creado por Mozilla. Servo, el sustituto de Gecko, se está desarrollando en él. Todavía puede cambiar su sintaxis pero el código que voy a usar va a mantenerse hasta la primera versión estable.</blockquote><br>Rust se instala en Linux de manera sencilla. Antes se podía usar un PPA pero ahora el script de RustUp es muy bueno y se encarga de todo.<br><pre class="lang:default decode:true">curl -s https://static.rust-lang.org/rustup.sh | sudo sh<br></pre><br><h3>¿Cómo funciona una máquina virtual?</h3><br>Si sabes como funciona el mundo en ensamblador es exactamente igual, con el stack o la pila. Si no, te lo explico. Imaginémonos el siguiente código:<br><pre class="lang:default decode:true">print 2+3<br></pre><br>El ordenador no entiende lo que significa 2+3, ni tampoco sabe qué orden hay que seguir. Los ordenadores funcionan con pilas o stacks en los que se van acumulando datos y se van sacando continuamente. Ese código en nuestra máquina virtual debería ser algo parecido a esto:<br><pre class="lang:default decode:true">PUSH 2<br>PUSH 3<br>ADD<br>PRINT<br></pre><br>Básicamente, pondríamos el 2 en la pila en lo alto, el 3 también. ADD sacaría (es decir, lo elimina de la pila y obtiene su valor) los 2 últimos elementos de la pila y añadiría el resultado en lo alto de la pila. PRINT cogería el último elemento de la pila y lo usaría para mostrárnoslo. Ahora hagamos eso en Rust.<br><blockquote>Ahora es cuando deberías descargarte el código fuente que está en GitHub. Voy a empezar por el archivo <em>vm.rs</em></blockquote><br>Primeramente deberemos definir un lenguaje para el Bytecode, podríamos usar uno ya existente como el de Java o el CLR de .NET/Mono, pero vamos a crear nosotros uno más básico.<br><pre class="lang:rust decode:true ">#[deriving(FromPrimitive)]<br>enum Instruction {<br>  INTEGER = 0x00,<br>  STRING = 0x01,<br>  ADD = 0x02,<br>  SHOWINTEGER = 0x0A,<br>  SHOWVERSION = 0x0E,<br>  EXITVM = 0x0F<br>}</pre><br>&nbsp;<br><br>Usamos notación hexadecimal para cada instrucción. Para hacer la traducción entre el código hexadecimal y la instrucción voy a usar la librería (crate en el argot de Rust) de enum_primitive. Antes se podía usar #[derive(FromPrimitive)] pero en Rust 1.0 no está disponible.<br><br>Ahora debemos hacer una función que ejecute cada una de esas instrucciones. Para ello debemos leer un byte y compararlo con las instrucciones que tenemos en la enumeración. Si se encuentra alguna que exista se debe ejecutar su acción.<br><pre class="lang:rust decode:true ">pub fn interpreter(&amp;mut self,bytecode: &amp;'static str) -&gt; (){<br>  for execbyte in bytecode.chars() {<br>    self.execute(execbyte as u8);<br>  }<br>}</pre><br>&nbsp;<br><br>Eso hacemos para leer cada byte individualmente y para ejecutarlas:<br><pre class="lang:rust decode:true ">fn execute(&amp;mut self, execbyte: u8) -&gt; () {<br>  if self.push {<br>    self.push(execbyte);<br>    self.push=false;<br>  }else{<br>    let op: Option&lt;Instruction&gt; = FromPrimitive::from_u8(execbyte);<br>    match op{<br>      None =&gt; {<br>        println!("Unknown instruction, skipping...");<br>      },<br>      Some(bc) =&gt; {<br>        match bc{<br>          INTEGER =&gt; {<br>            self.push=true;<br>          },<br>          ADD =&gt; {<br>            let a=self.pop() as int;<br>            let b=self.pop() as int;<br>            let c=a+b;<br>            self.push(c as u8);<br>          },<br>          SHOWINTEGER =&gt; {<br>            println!("Integer value {}",self.pop() as int);<br>          },<br>          SHOWVERSION =&gt; {<br>            println!("PerinVM v0.1.0");<br>          },<br>          EXITVM =&gt; {<br>            println!("Exit VM");<br>          },<br>          STRING =&gt; {<br>            println!("Unsupported instruction 'STRING' ");<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</pre><br>&nbsp;<br><br>Como ven, diferenciamos si antes se nos dio la orden de PUSH (nuestra orden INTEGER), el siguiente byte será llevado completamente a la pila. Ahí estamos usando dos funciones que no les he enseñado, self.pop() y self.push(), que se encargan obviamente de manejar el stack.<br><pre class="lang:rust decode:true ">fn push(&amp;mut self, value: u8) -&gt; (){<br>  self.stack.push(value);<br>}<br>fn pop(&amp;mut self) -&gt; u8{<br>  let a: Option&lt;u8&gt;=self.stack.pop();<br>  match a{<br>    None =&gt; {<br>      println!("Failed to pop");<br>      0<br>    },<br>    Some(result) =&gt; {<br>      result<br>    }<br>  }<br>}</pre><br>&nbsp;<br><br>No son muy complejas, pero la función de pop tiene mecanismos de detección de errores. De hecho, en Rust, si quitásemos esos mecanismos nos daría un error de compilación. Ahora simplemente debemos llamar en un programa a Perin (nuestra máquina virtual) y que ejecute un bytecode.<br><pre class="lang:rust decode:true ">mod vm;<br><br>fn main(){<br>  let bytecode = "\x0E\x00\x02\x00\x03\x02\x0A";<br>  let mut perin = vm::PerinVM::new();<br>  perin.interpreter(bytecode);<br>}</pre><br>&nbsp;<br><br>Ese bytecode puede ser leído de un fichero, pero aquí para simplificar lo he almacenado en una variable. Si lo ejecutamos nos dará el resultado esperado:<br><pre class="lang:default decode:true">Perin v0.1<br>Perin VM executes FlopFlip bytecode<br>Starting PerinVM instance<br>PerinVM v0.1.0<br>Integer value 5<br></pre><br>Todo el código está disponible en GitHub bajo la Apache License 2.0: <a href="https://github.com/AdrianArroyoCalle/perin">https://github.com/AdrianArroyoCalle/perin</a>. Para compilar deben tener Cargo instalado y poner:<br><pre class="lang:default decode:true">cargo run<br></pre>