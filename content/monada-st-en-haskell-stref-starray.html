Haskell tiene una librería muy completa, con muchas estructuras de datos y, en este caso, mónadas muy interesantes. En este caso vamos a hablar de la mónada <strong>ST</strong>. <strong>ST</strong> son las siglas de <em>State Threads</em>. Fueron definidas por Simon Peyton-Jones en <a href="https://www.microsoft.com/en-us/research/publication/lazy-functional-state-threads/">un paper de 1994</a> y son una forma muy curiosa que tiene Haskell de permitirnos escribir código con estructuras de datos mutables. La gracia está en que se garantiza que es imposible que la mutabilidad interna que hay dentro de la mónada ST salga al exterior, de modo que de cara al exterior son funciones puras igualmente. Esta mónada no sirve para comunicarse con el exterior como sí sirve <strong>IO</strong> pero si podemos usar ST antes que IO, mejor.<br><h2>STRef</h2><br>La estructura más fundamental es STRef, que permite tener una variable mutable dentro de Haskell. Las funciones que permiten su manejo son <strong>newSTRef</strong>, <strong>readSTRef</strong>, <strong>writeSTRef</strong> y <strong>modifySTRef</strong>. Creo que es bastante evidente para qué sirve cada una, pero veamos un ejemplo práctico.<br><br>Vamos a hacer una función que sume todos los elementos de una lista. Existen varias formas de hacerlo de forma pura en Haskell:<br><pre class="lang:haskell decode:true ">sumar :: Num a =&gt; [a] -&gt; a<br>sumar [] = 0<br>sumar (x:xs) = x+sumar xs</pre><br><em>Una versión recursiva</em><br><pre class="lang:haskell decode:true ">sumar :: Num a =&gt; [a] -&gt; a<br>sumar = foldr1 (+)</pre><br><em>Una versión más compacta</em><br><br>En un lenguaje de programación imperativo sin embargo posiblemente haríamos algo parecido a esto:<br><pre class="lang:java decode:true ">int sumar(int[] nums){<br>    int suma = 0;<br>    for(int i=0;i&lt;nums.length;i++){<br>        suma += nums[i];<br>    }<br>    return suma;<br>}</pre><br>Con ST podemos hacer código que se parezca a la versión imperativa, lo cuál es útil en determinados algoritmos y también si queremos ganar eficiencia.<br><pre class="lang:haskell decode:true">import Control.Monad.ST<br>import Control.Monad<br>import Data.STRef<br><br>sumar :: Num a =&gt; [a] -&gt; a<br>sumar xs = runST $ do<br>	x &lt;- newSTRef 0<br>	<br>	forM_ xs $ \n -&gt; <br>		modifySTRef x $ \x -&gt; x+n<br><br>	readSTRef x<br></pre><br>Lo primero que tenemos que hacemos es ejecutar la mónada ST con <strong>runST</strong> y a continuación la función. Allí creamos una <em>variable mutable</em> con valor inicial 0. Después lanzamos <strong>forM_</strong> que itera sobre cada elemento de la lista xs ejecutando para cada elemento la función que llama a modifySTRef que ejecuta a su vez la función que suma el valor del acumulador con el valor del elemento actual de la lista.<br><br>Por último, la función finaliza devolviendo el valor de x.<br><br>Como veis, el código no tiene nada que ver a las otras versiones de Haskell y tiene un gran parecido con la versión de Java. No obstante, el código sigue siendo puro, sin efectos colaterales.<br><h2>STArray</h2><br>Pero no solo tenemos STRef, también tenemos <strong>STArray</strong> que es un array de tamaño fijo con estas mismas propiedades. Las funciones básicas son <strong>newListArray, readArray, writeArray </strong>y <strong>getElems</strong>.<br><br>Por ejemplo, podemos implementar <a href="https://es.wikipedia.org/wiki/Ordenamiento_de_burbuja">el algoritmo de Bubble Sort</a> de forma imperativa con STArray:<br><br><a href="https://files.adrianistan.eu/Sorting_bubblesort_anim.gif"><img class="aligncenter size-full wp-image-1401" src="https://files.adrianistan.eu/Sorting_bubblesort_anim.gif" alt="" width="277" height="257" /></a><br><pre class="lang:haskell decode:true ">import Control.Monad<br>import Control.Monad.ST<br>import qualified Data.Array.ST as ST<br>import Data.STRef<br><br>bubblesort :: [Int] -&gt; [Int]<br>bubblesort xs = runST $ do<br>	let l = length xs<br>	temp &lt;- newSTRef $ head xs<br>	array &lt;- ST.newListArray (0,l-1) xs :: ST s (ST.STArray s Int Int)<br><br>	forM_ [0..l] $ \i -&gt; do<br>		forM_ [1..(l-1)] $ \j -&gt; do<br>			prev &lt;- ST.readArray array (j-1)<br>			actual &lt;- ST.readArray array j	<br>			if prev &gt; actual then do<br>				writeSTRef temp prev<br>				ST.writeArray array (j-1) actual<br>				t &lt;- readSTRef temp<br>				ST.writeArray array j t<br>			else do<br>				return ()<br><br>	ST.getElems array<br>			<br>main :: IO ()<br>main = do<br>	let orden = bubblesort [3,4,1,2]			<br>	putStrLn ("Orden: "++(show orden))</pre><br><a href="https://files.adrianistan.eu/BubblesortHaskell.png"><img class="aligncenter size-full wp-image-1400" src="https://files.adrianistan.eu/BubblesortHaskell.png" alt="" width="727" height="109" /></a>La mónada ST junto con las funciones de Control.Monad nos permiten escribir código que parece imperativo y con mutabilidad, sin perder la pureza y la seguridad de Haskell.