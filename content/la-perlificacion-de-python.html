<blockquote><br><div class="col-xs-12"><br><br>You know, FOX turned into a hardcore sex channel so gradually I didn't even notice<br><br></div></blockquote><br><div class="col-xs-12"><br><p style="text-align: right;"><strong>Marge Simpson, <em>Los Simpson</em></strong></p><br><br></div><br><a href="https://files.adrianistan.eu/Simpsons.jpg"><img class="aligncenter size-full wp-image-1493" src="https://files.adrianistan.eu/Simpsons.jpg" alt="" width="640" height="480" /></a>Recientemente <a href="https://blog.python.org/2018/06/python-3.html">ha salido Python 3.7</a>, con interesantes novedades. También han salido los primeros artículos hablando de <a href="https://hackernoon.com/7-features-proposed-so-far-in-python-3-8-acb0d97c83c8">las novedades que podrá traer Python 3.8</a>. Como muchos ya conoceréis, y si no es así explico, Python funciona a base de PEPs (Python Enhancement Proposal). Cualquier persona puede abrir un PEP, que es un documento que describe la funcionalidad que se quiere añadir/modificar/eliminar. Estas PEPs se discuten y finalmente Guido, creador de Python, las aprueba y se codifican.<br><br>Dentro de las PEP relacionadas con Python 3.8 hay algunas bastante controvertidas que han hecho saltar la voz de alarma. No ha faltado gente que ha opinado que cada vez Python se parece más a Perl. Este proceso habría empezado con Python 3 pero se habría ido haciendo más evidente hasta llegar a hoy. Cada vez con más sintaxis poco utilizada, con más elementos, más cómodo de escribir para el experimentado aunque menos legible si no dominas el lenguaje.<br><br>Y resulta curioso, porque Python es en parte una respuesta a la excesiva complejidad que podían tener los programas hechos en Perl. Su popularidad se debe a que es fácil de aprender y eso parece que ya no está tan claro.<br><br><a href="https://files.adrianistan.eu/Perl.gif"><img class="aligncenter size-full wp-image-1494" src="https://files.adrianistan.eu/Perl.gif" alt="" width="643" height="326" /></a><br><br>Con la introducción de operadores como := o ?? o anotaciones como @dataclass se va, en cierta medida, perdiendo el espíritu original de Python. Y es cierto que otros lenguajes tienen algo similar, pero precisamente Python había sido muy selecto en incluir un conjunto bastante reducido de características, que todo el mundo pudiese dominar. Al final se sacrifica legibilidad y facilidad de aprendizaje por una ergonomía que beneficia a unos pocos en unos casos concretos.<br><h2>Lenguajes de programación barrocos</h2><br><a href="https://files.adrianistan.eu/PlazaUniversidad.jpg"><img class="size-large wp-image-1495" src="https://files.adrianistan.eu/PlazaUniversidad-1024x685.jpg" alt="" width="840" height="562" /></a> Universidad de Valladolid, ejemplo de barroco civil. Foto: https://artevalladolid.blogspot.com<br><br>Python lleva un tiempo entrando en un proceso de perlificación pero en mi opinión no es el único lenguaje que ha entrado en una espiral parecida. Cada vez más lenguajes han pasado del renacimiento, donde se buscaba la consistencia, la simetría, la sencillez sin perder la funcionalidad, hacia el barroco, donde los lenguajes son más recargados, con más elementos sintácticos, que cubren mejor casos concretos, pero que de por sí no son tan esenciales, no cambian aspectos fundamentales del lenguaje y normalmente introducen diversas formas de hacer algo en un mismo lenguaje.<br><br>Veamos más ejemplos: en C++20 se propuso añadir funcionalidad de dibujado 2D a la librería estándar (propuesta que fue rechazada en una historia bastante larga para este post) y se han propuesto conceptos, módulos, comparación de tres vías, reflexión, metaclases,... En C# 8.0 se han propuesto también bastantes cosas como records, tipos non-nullable, interfaces con métodos ya implementados (traits) y rangos. Y eso sin contar con las características que estos dos lenguajes ya tienen, que son bastante más extensos que Python.<br><br><a href="https://files.adrianistan.eu/RetabloSanMiguelSanJulian.jpg"><img class="wp-image-1496 size-large" src="https://files.adrianistan.eu/RetabloSanMiguelSanJulian-790x1024.jpg" alt="" width="790" height="1024" /></a> Retablo lateral de la Iglesia de San Miguel y San Julián (Valladolid). Barroco puro. Foto: https://commons.wikimedia.org/wiki/File:San_Miguel_-_retablo_relicario.jpg<br><br>Hay un <em>horror vacui</em>, horror al vacío, a funcionalidades. Siempre se añade y casi nunca se elimina. ¿Pero es realmente necesario? Es evidente que durante mucho tiempo, los lenguajes evolucionaban de forma muy lenta y muchos de los cambios que han hecho eran necesarios. Desde hace unos años, se ha aumentado la velocidad de los cambios, pero esto no puede seguir así eternamente, porque el ritmo que llevan muchas veces es superior al de los avances en lenguajes de programación y la retrocompatibilidad impide ir quitando cosas al mismo ritmo que se añaden. De este modo, todos los lenguajes que entran en esta espiral crecen y crecen. No se llegan a pulir, simplemente crecen.<br><blockquote><span class="st">La perfección no se alcanza cuando no hay nada más que añadir, sino cuando no hay nada más que quitar</span></blockquote><br><p style="text-align: right;"><strong><span class="st"><em>Antoine de Saint</em>-<em>Exupéry</em></span></strong></p><br>Uno podría comparar esto con lenguajes naturales, como el español o el inglés. En estos idiomas, pese a existir reglas, existen numerosas excepciones. Es posible que lenguajes como Python se estén viendo influenciados por las mismas mecánicas humanas que rigen los lenguajes naturales y que han hecho que existan excepciones. Tendría bastante sentido que ocurriese así. Pero personalmente, me gustaría que aprender Python no costase tanto como aprender alemán o francés.<br><h2>Los procesos comunitarios</h2><br>Para mí, gran parte de esta sobrecarga viene dada por los procesos comunitarios. En un proceso comunitario como PEP, comité de C++ o similares es mucho más fácil añadir que eliminar. En C++ la situación ha llegado a un punto en el que Bjarne Stroustrup, creador de C++, ha pedido que se relajen con las propuestas en <em><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0977r0.pdf">Remember the Vasa!</a>, </em>en honor a un bonito barco sueco que se hundió por exceso de carga. No tanto por su peso, sino por su disposición y las reformas que hubo que hacer para que todo encajase.<br><br><a href="https://files.adrianistan.eu/Vasa.jpg"><img class="size-full wp-image-1497" src="https://files.adrianistan.eu/Vasa.jpg" alt="" width="810" height="634" /></a> El Vasa fue recuperado después de su naufragio y se expone en Estocolmo. Foto: https://rachelannsblog.wordpress.com/2016/08/03/set-sail-set-at-the-bottom-of-the-sea/<br><br>Es por ello que las personas encargadas de elegir que se añade al lenguaje o no deben de ser muy conscientes de lo que supone, ya que una vez se introduzca, va a ser casi imposible eliminarlo.<br><br>No estoy en contra de añadir nuevas características (¡al contrario!) pero se debe respetar la visión de conjunto del lenguaje, que todo cuadre y esté cohesionado. No siempre tener más es mejor.<br><h2>¿Te ha gustado el artículo?</h2><br>Si es así, puedes ayudar al blog. Dentro de unos días es el Amazon Prime Day. Como muchos de vosotros seguro que os compraréis algo, no quiero dejar la oportunidad de deciros que este blog tiene enlace de referidos y que por cada cosa que compréis con el enlace, me llevo una pequeña parte (a vosotros no os va a costar más caro).<br><br><a href="https://www.amazon.es//ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll2&amp;tag=adrarrcal-21&amp;linkId=31c59cde3f5f4b573208e29a0a776f7d">Enlace Amazon.es</a><br><br>Será muy bien recibido<br><br>&nbsp;