<p>Primer Teletexto del año. Veamos los enlaces más interesantes que me han llegado desde el último teletexto.</p>
<div style="text-align:center">
<img src="https://files.adrianistan.eu/TeletextDivisas.jpg" width="400">
</div>
<ul>
<li>En <a href="https://tryolabs.com/blog/2020/12/21/top-10-python-libraries-of-2020/">Top 10 Python libraries of 2020</a> veremos un listado de las 10 mejores librerías para Python creadas en 2020. Algunas de ellas son muy interesantes, échalas un ojo.</li>
<li>A día de hoy, seguimos usando sistemas operativos, que conceptualmente, son muy similares a aquellos de los años 70, pero ya han pasado 50 años. ¿Cómo debería ser el sistema operativo del siglo XXI, ahora que ya tenemos más experiencia? tomaka es un usuario activo de la comunidad Rust y ha escrito en un post algunas cosas que él considera necesarias (por ejemplo, eliminar el concepto de "programas", solo tener librerías, tener una shell que sea tipada, direccionamiento basado en contenido, sandboxing,...) en este artículo: <a href="https://tomaka.medium.com/the-future-of-operating-systems-efa31e17d66d">The future of operating systems</a>. Él intenta poner en práctica algunas de estas ideas en el sistema operativo <a href="https://github.com/tomaka/redshirt">redshirt</a>.</li>
<li>El testing es muy importante si queremos software de calidad. Sin embargo, cuando programamos código a veces, sin darnos cuenta, nos dificultamos a nosotros mismos la facilidad y calidad del testeo. <a href="https://www.youtube.com/watch?v=acjvKJiOvXw">En esta charla de Google</a>, vemos como programar en estilo OOP de modo que el código que hagamos sea fácil y robusto de testear.</li>
<li>Existe un patrón de diseño, capaz de sustituir tanto herencia como composición en OOP llamado ECS (Entity-Component-System). Vendría a ser similar a la composición vía Traits o Interfaces salvo que es dinámico y los sistemas (la lógica) está más desacoplada. Es relativamente popular en videojuegos, pero el famoso motor Godot, no la usa y explican por qué en: <a href="https://godotengine.org/article/why-isnt-godot-ecs-based-game-engine">Why isn't Godot an ECS-based engine?</a>. Es interesante, aunque os recomiendo echar un vistazo a ECS también (lo tengo en la lista de asuntos a hablar en el blog). En lenguajes como Rust, es de hecho una opción muy buena ya que no tenemos el set de herramientas clásico de la OOP (clases, herencia, etc). Para ello existen varias librerías como <a href="https://github.com/Ralith/hecs">hecs</a> o el motor (todavía en progreso) <a href="https://bevyengine.org/">Bevy</a>, que sí usa ECS de forma central.</li>
<li><a href="https://elronnd.net/writ/2021-02-13_att-asm.html">No deberías usar la sintaxis AT&T nunca, bajo ninguna circunstancia</a>. Así de contundente es este artículo que explica porque la sintaxis AT&T es una mala opción (para quién no lo sepa, en ensamblador de x86, existen dos sintaxis populares, la Intel y la AT&T). Lo cierto es que este artículo me generó la duda de ¿por qué esta sintaxis es así? Y hay una respuesta a StackOverflow que <a href="https://stackoverflow.com/questions/42244028/what-was-the-original-reason-for-the-design-of-att-assembly-syntax">examina los motivos históricos.</a> Como siempre, sale a la luz el pasado de UNIX y C, que fueron originalmente sistemas para arquitecturas PDP-11, diferentes a las x86 de Intel.</li>
<li>He empezado a colaborar más activamente en Scryer Prolog, el intérprete de Prolog hecho en Rust que aspira a ser rápido y compatible con el estándar ISO. Algunas de mis aportaciones recientes, y que animo a todo el mundo a probar son: <a href="https://github.com/mthom/scryer-prolog/pull/726">el servidor HTTP en Prolog</a> y el <a href="https://github.com/mthom/scryer-prolog/pull/829">generador de UUIDv4 en Prolog</a>.</li>
<li>Por último, no quería dejar pasar un debate que se ha formado en las distros respecto a como hay que empaquetar el software programado en lenguajes como Go y Rust. Las técnicas que se venían utilizando con C y C++ están empezando a dar bastantes quebraderos de cabeza. Hay quien opina que debería seguir el modelo actual, ya que es más seguro, lleva funcionando mucho tiempo, etc... Sin embargo, yo me inclino más por el lado de que las distros no pueden tratar de imponer sus modelos a los lenguajes, ya que herramientas como Cargo son multiplataforma, están mucho mejor integradas, añaden funcionalidad específica, mientras que un DEB/RPM no te ofrece realmente nada extra y es válido solo para una parte más reducida de los usuarios. También está el tema de la reproducibilidad. Todo el mundo lo quiere, tanto devs como distros, pero me parece que cada uno lo quiere a un nivel diferente y eso causa conflictos. Esto podría intentar desarrollarlo más en un post si veo que hay interñes. En todo caso:  <a href="https://lwn.net/Articles/842319/">aquí un artículo sobre parte del asunto desde el lado de Debian</a> y aquí <a href="https://fy.blackhats.net.au/blog/html/2021/02/16/against_packaging_rust_crates.html">alguien que piensa que empaquetar librerías en Rust ahora mismo en las distros no tiene sentido</a></li>
</ul>
<p>Para despedirme vamos con una canción de William Hart que encontré hace poco en la radio</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/fiQCTlSy7SQ" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>