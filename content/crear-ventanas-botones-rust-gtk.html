Cuando salió el Macintosh allá por 1984, fue novedosa su interfaz gráfica. En efecto, fue la primera interfaz gráfica popular y ha servido de inspiración para muchos otros sistemas de ventanas.<br><br>Hoy vamos a introducir una manera de crear interfaces gráficas de usuario (GUI) con Rust. Para ello usaremos GTK. GTK funciona sobre GNU/Linux, macOS y Windows (aunque es un poco más complicado de lo que debiera).<br><br>Para ello usaremos la fantástica crate <strong>gtk</strong> del proyecto <a href="http://gtk-rs.org/">Gtk-rs</a>.<br><h2>Instalando gtk</h2><br>Añade al fichero Cargo.toml las siguiente líneas:<br><br><pre class="lang:default decode:true"><br>[dependencies]<br>gtk = &quot;0.2.0&quot;<br></pre><br><br>Y ejecuta cargo build.<br><h2>Creando una ventana</h2><br>Lo primero que vamos a hacer es crear una ventana.<br><br>Importamos gtk e iniciamos GTK.<br><br><pre class="lang:rust decode:true"><br>extern crate gtk;<br><br>use gtk::prelude::*;<br><br>fn main() {<br>    if gtk::init().is_err() {<br>        println!(&quot;Failed to initialize GTK.&quot;);<br>        return;<br>    }<br></pre><br><br>Ahora podemos crear una ventana. <strong>GtkWindow</strong> es un <strong>struct</strong> con métodos asociados, por lo que podemos ajustar ciertos parámetros. En este código parece que estamos usando orientación a objetos, pero recuerdo que Rust técnicamente no tiene <strong>clases</strong> ni <strong>herencia</strong>.<br><br><pre class="lang:rust decode:true"><br>    let window = gtk::Window::new(gtk::WindowType::Toplevel);<br><br>    window.set_title(&quot;Adrianistan - GTK - Rust&quot;);<br>    window.set_border_width(10);<br>    window.set_position(gtk::WindowPosition::Center);<br>    window.set_default_size(350, 70);<br></pre><br><br>Ahora vamos a añadir un evento para que cuando se pulse la X en nuestra ventana, se cierre el programa. Para ello tenemos que entender como funciona GTK. Cuando programamos en GTK lo que hacemos es configurar la aplicación y posteriormente ceder la ejecución a una función <strong>gtk_main</strong> que procesa todos los eventos según haya sido configurado. Para configurar los eventos usaremos callbacks, que en Rust se pueden implementar con <strong>closures</strong>. Las funciones que en GTK nos permiten conectar eventos siempre tienen el prefijo <strong>connect</strong>.<br><br><pre class="lang:rust decode:true"><br>    window.connect_delete_event(|_, _| {<br>        gtk::main_quit();<br>        Inhibit(false)<br>    });<br></pre><br><br>Ahora vamos a mostrar la ventana. Por defecto en GTK todos los widgets (todo lo que se muestra en pantalla) está oculto. Para mostrar todos los widgets que se han añadido a la ventana se suele usar <strong>show_all</strong>, que va a haciendo <strong>show</strong> de forma recursiva. Por último, le damos el control de la aplicación a <strong>gtk::main</strong>.<br><br><pre class="lang:rust decode:true"><br>    window.show_all();<br>    gtk::main();<br>}<br></pre><br><br>Una vez hecho esto, si compilamos con <strong>cargo run</strong> ya deberíamos ver una preciosa ventana GTK.<br><br><a href="https://files.adrianistan.eu/Captura-de-pantalla-19.png"><img class="aligncenter size-large wp-image-1043" src="https://files.adrianistan.eu/Captura-de-pantalla-19-1024x576.png" alt="" width="840" height="473" /></a>Y por supuesto, si pulsamos la X, la aplicación se cierra.<br><h2>Layouts y botones en GTK</h2><br>Vamos ahora a añadir dos cosas: un botón y un label que nos de un número del dado. Para poner varios elementos en una aplicación GTK es recomendable usar un layout. Voy a usar el layout Box, que permite agrupar los widgets de forma vertical u horizontal. Para los números aleatorios voy a usar la crate <strong>rand</strong>. El código final sería así:<br><br><pre class="lang:rust decode:true"><br>extern crate gtk;<br>extern crate rand;<br><br>use gtk::prelude::*;<br>use rand::distributions::{IndependentSample, Range};<br><br>fn pick(a: i32, b: i32) -&gt; i32 {<br>    let between = Range::new(a, b);<br>    let mut rng = rand::thread_rng();<br>    between.ind_sample(&amp;mut rng)<br>}<br><br>fn main() {<br>    if gtk::init().is_err() {<br>        println!(&quot;Failed to initialize GTK.&quot;);<br>        return;<br>    }<br><br>    let window = gtk::Window::new(gtk::WindowType::Toplevel);<br><br>    window.set_title(&quot;Adrianistán - GTK - Rust&quot;);<br>    window.set_border_width(10);<br>    window.set_position(gtk::WindowPosition::Center);<br>    window.set_default_size(350, 70);<br><br>    window.connect_delete_event(|_, _| {<br>        gtk::main_quit();<br>        Inhibit(false)<br>    });<br><br>    let vbox = gtk::Box::new(gtk::Orientation::Vertical,10);<br><br>    let button = gtk::Button::new_with_label(&quot;Tirar el dado&quot;);<br><br>    let label = gtk::Label::new(&quot;No has tirado el dado todavía&quot;);<br><br>    let l = label.clone();<br>    button.connect_clicked(move |_| {<br>        let dado = pick(1,7);<br>        let text: String = format!(&quot;Dado: {}&quot;,dado);<br>        l.set_text(text.as_str());<br>    });<br>    <br>    vbox.add(&amp;button);<br>    vbox.add(&amp;label);<br>    window.add(&amp;vbox);<br><br>    window.show_all();<br>    gtk::main();<br>}<br></pre><br><br>Aquí pasan varias cosas interesantes. La primera es que usamos <strong>add</strong> para ir añadiendo de forma jerárquica los widgets. Debajo de Window está Box y debajo de Box tenemos Button y Label.<br><br>Por otra parte, vemos que la función asociada al evento del click de los botones es <strong>connect_clicked</strong>. Bien, en este ejemplo he introducido algo importante. Estoy modificando un widget desde un evento relacionado a otro widget. ¿Esto como se lleva con las reglas de propiedad/ownership de Rust? Bastante mal. Rust no puede saber si cuando se ejecuta el evento tenemos acceso al widget en cuestión que vamos a modificar. Afortunadamente, la API de gtk-rs ha sido diseñada con esto en cuenta y simplemente podemos hacer una llamada a <strong>clone</strong> para obtener otra referencia al objeto, que podemos pasar al closure (con <strong>move</strong>). Este clonado no lo es tal, sino que hace uso de <strong>Rc</strong>. Simplemente se nos presenta de forma transparente.<br><h2>El ejemplo final: dibujando con Cairo</h2><br>En este último ejemplo voy a añadir un widget donde se podrá ver la cara del dado que ha salido. Para ello uso un <strong>GtkDrawingArea</strong>, que permite usar la API de <strong>Cairo</strong>.<br><br><pre class="lang:rust decode:true"><br>extern crate gtk;<br>extern crate rand;<br><br>use gtk::prelude::*;<br>use rand::distributions::{IndependentSample, Range};<br>use std::rc::Rc;<br>use std::cell::Cell;<br><br>fn pick(a: i32, b: i32) -&gt; i32 {<br>    let between = Range::new(a, b);<br>    let mut rng = rand::thread_rng();<br>    between.ind_sample(&amp;mut rng)<br>}<br><br>fn main() {<br>    if gtk::init().is_err() {<br>        println!(&quot;Failed to initialize GTK.&quot;);<br>        return;<br>    }<br><br>    let window = gtk::Window::new(gtk::WindowType::Toplevel);<br><br>    window.set_title(&quot;Adrianistán - GTK - Rust&quot;);<br>    window.set_border_width(10);<br>    window.set_position(gtk::WindowPosition::Center);<br>    window.set_default_size(350, 70);<br><br>    window.connect_delete_event(|_, _| {<br>        gtk::main_quit();<br>        Inhibit(false)<br>    });<br><br>    let vbox = gtk::Box::new(gtk::Orientation::Vertical,10);<br><br>    let button = gtk::Button::new_with_label(&quot;Tirar el dado&quot;);<br><br>    let label = gtk::Label::new(&quot;No has tirado el dado todavía&quot;);<br><br>    let r = Rc::new(Cell::new(0));<br><br>    let random = r.clone();<br>    let drawingarea = gtk::DrawingArea::new();<br>    drawingarea.set_size_request(300,300);<br>    drawingarea.connect_draw(move |widget,cr|{<br>        let width: f64 = widget.get_allocated_width() as f64;<br>        let height: f64 = widget.get_allocated_height() as f64;<br>        cr.rectangle(0.0,0.0,width,height);<br>        cr.set_source_rgb(1.0,1.0,1.0);<br>        cr.fill();<br><br>        cr.set_source_rgb(0.,0.,0.);<br>        let random = random.get();<br>        if random == 1 || random == 3 || random == 5{<br>            cr.arc(width/2.0,height/2.,height/10.,0.0,2.0*std::f64::consts::PI);<br>        }<br>        cr.fill();<br>        if random == 2 || random == 3 || random == 4 || random == 5 || random == 6 {<br>            cr.arc(width/4.,height/4.,height/10.,0.0,2.0*std::f64::consts::PI);<br>            cr.arc(3.*width/4.,3.*height/4.,height/10.,0.0,2.0*std::f64::consts::PI);<br>        }<br>        cr.fill();<br><br>        if random == 4 || random == 5 || random == 6 {<br>            cr.arc(3.*width/4.,height/4.,height/10.,0.0,2.0*std::f64::consts::PI);<br>            cr.arc(width/4.,3.*height/4.,height/10.,0.0,2.0*std::f64::consts::PI);<br>        }<br>        cr.fill();<br>        <br>        if random == 6 {<br>            cr.arc(width/2.,height/4.,height/10.,0.0,2.0*std::f64::consts::PI);<br>            cr.arc(width/2.,3.*height/4.,height/10.,0.0,2.0*std::f64::consts::PI);<br>        }<br>        cr.fill();<br>        Inhibit(false)<br>    });<br><br>    let l = label.clone();<br>    let dado = r.clone();<br>    let da = drawingarea.clone();<br>    button.connect_clicked(move |_| {<br>        dado.set(pick(1,7));<br>        let text: String = format!(&quot;Dado: {}&quot;,dado.get());<br>        l.set_text(text.as_str());<br>        da.queue_draw();<br>    });<br>    <br>    vbox.add(&amp;button);<br>    vbox.add(&amp;label);<br>    vbox.add(&amp;drawingarea);<br>    window.add(&amp;vbox);<br><br>    window.show_all();<br>    gtk::main();<br>}<br></pre><br><br><a href="https://files.adrianistan.eu/SinTirarDado.png"><img class="aligncenter size-full wp-image-1044" src="https://files.adrianistan.eu/SinTirarDado.png" alt="" width="383" height="460" /></a><a href="https://files.adrianistan.eu/Dado3.png"><img class="aligncenter size-full wp-image-1045" src="https://files.adrianistan.eu/Dado3.png" alt="" width="386" height="454" /></a><a href="https://files.adrianistan.eu/Dado5.png"><img class="aligncenter size-full wp-image-1046" src="https://files.adrianistan.eu/Dado5.png" alt="" width="395" height="471" /></a> <a href="https://files.adrianistan.eu/Dado6.png"><img class="aligncenter size-large wp-image-1047" src="https://files.adrianistan.eu/Dado6.png" alt="" width="390" height="467" /></a>Con esto tenemos lo básico para empezar a diseñar GUIs con GTK y Rust.<br><br>&nbsp;