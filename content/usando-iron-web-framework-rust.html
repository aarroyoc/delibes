<blockquote>Actualmente, si quiéres hacer una aplicación web con Rust, te recomiendo <a href="https://blog.adrianistan.eu/2017/04/15/tutorial-rocket-echa-volar-tus-webapps-rust/">Rocket</a>, es mucho más sencillo de usar, más potente, más rápido y tiene más usuarios.</blockquote><br><a href="https://blog.adrianistan.eu/rust-101-tutorial-rust-espanol/">Rust</a> cada día atrae a más desarrolladores. Es eficiente y es robusto. Mozilla ha sido la principal impulsora de este lenguaje para ser usado en entornos tan complejos como el propio Firefox.<br><br>Hoy vamos a introducirnos en el mundo del desarrollo web con Rust. Cuando la gente oye desarrollo web normalmente se piensa en lenguajes como PHP, Python, Ruby o JavaScript. Estos son lenguajes con los que es rápido desarrollar algo, aunque son mucho menos eficientes y es más fácil cometer errores debido a que son interpretados directamente. Un paso por encima tenemos a Java y C#, que cubren en parte las carencias de los otros lenguajes mencionados. Ha llegado la hora de hablar de Rust. Si bien es cierto que hay web frameworks en C++, nunca han sido muy populares. ¿Será Rust la opción que finalmente nos permita tener aplicaciones web con una eficiencia nativa?<br><br>Existen varios web frameworks en Rust, para este tutorial vamos a usar <a href="http://ironframework.io">Iron</a>, el más popular según Crates.io. Quizá te interese echar un vistazo también a <a href="https://blog.adrianistan.eu/2017/04/15/tutorial-rocket-echa-volar-tus-webapps-rust/">Rocket</a>, mi preferido.<br><br><img class="alignnone size-large wp-image-578" src="https://files.adrianistan.eu/IronFramework-1024x499.png" alt="ironframework" width="840" height="409" /><br><h2>Crear proyecto e instalar Iron</h2><br>Lo primero que hay que hacer es crear un nuevo proyecto en Rust, lo hacemos gracias a Cargo.<br><pre class="lang:default decode:true">cargo new --bin MundoRust<br><br>cd MundoRust<br></pre><br>Ahora editamos el fichero Cargo.toml para añadir las dependencias que vamos a usar.<br><pre class="lang:default decode:true">[package]<br>name = "MundoRust"<br>version = "0.1.0"<br>authors = ["Adrián Arroyo Calle"]<br><br>[dependencies]<br>iron = "0.4.0"<br>router = "0.4.0"<br>staticfile = "0.3.1"<br>mount = "0.2.1"<br><br></pre><br>Ahora obtenemos las dependencias especificadas con Cargo.<br><pre class="lang:default decode:true">cargo run<br></pre><br><h2>Hola Mundo con Iron</h2><br>Vamos a empezar a programar en Rust. Vamos a hacer una simple aplicación que devuelva "Hola Rustáceos" por HTTP.<br><br>Editamos el archivo src/main.rs<br><pre class="lang:rust decode:true">extern crate iron;<br><br>use iron::prelude::*;<br><br>fn hola(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {<br>    Ok(Response::with((iron::status::Ok, "Hola Rustaceos")))<br>}<br><br>fn main() {<br>    Iron::new(hola).http("0.0.0.0:80").unwrap();<br>}<br></pre><br><img class="alignnone size-large wp-image-577" src="https://files.adrianistan.eu/HolaRustaceos-1024x523.png" alt="holarustaceos" width="840" height="429" /><br><h2>Usando router para el enrutamiento</h2><br>Hemos hecho un pequeño servidor HTTP con Iron. Pero nos falta algo, que sea capaz de manejar rutas. Que miweb.com/hola no sea lo mismo que miweb.com/adios. Iron por defecto no trae enrutador, pero es muy habitual usar Router, que ya hemos instalado antes por conveniencia.<br><pre class="lang:rust decode:true">extern crate iron;<br>extern crate router;<br><br>use iron::prelude::*;<br>use router::Router;<br><br>fn get_page(r: &amp;mut Request) -&gt; IronResult&lt;Response&gt;{<br>    let path = r.url.path();<br>    Ok(Response::with((iron::status::Ok, format!("Hola, peticion GET {}",path[0]))))<br>}<br><br>fn submit(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt;{<br>    Ok(Response::with((iron::status::Ok, "Peticion POST")))<br>}<br><br>fn main() {<br>    let mut router = Router::new();<br><br>    router.get("/:page", get_page, "page");<br>    router.post("/submit", submit, "subdmit");<br><br>    Iron::new(router).http("0.0.0.0:80").unwrap();<br><br>}<br></pre><br><img class="alignnone size-large wp-image-579" src="https://files.adrianistan.eu/GetIron-1024x541.png" alt="getiron" width="840" height="444" /><br><h2>Archivos estáticos</h2><br>Para gestionar los ficheros estáticos vamos a usar staticfile y mount, otras dos librerías para Iron.<br><pre class="lang:rust decode:true">extern crate iron;<br>extern crate router;<br>extern crate staticfile;<br>extern crate mount;<br><br>use iron::prelude::*;<br>use router::Router;<br>use staticfile::Static;<br>use mount::Mount;<br><br>fn get_page(r: &amp;mut Request) -&gt; IronResult&lt;Response&gt;{<br>    let path = r.url.path();<br>    Ok(Response::with((iron::status::Ok, format!("Hola, peticion GET {}",path[0]))))<br>}<br><br>fn main() {<br>    let mut router = Router::new();<br><br>    router.get("/:page", get_page, "page");<br><br>    let mut mount = Mount::new();<br>    mount.mount("/public",Static::new("static/"));<br>    mount.mount("/",router);<br><br>    Iron::new(mount).http("0.0.0.0:80").unwrap();<br>}<br></pre><br><img class="alignnone size-large wp-image-580" src="https://files.adrianistan.eu/IronStaticFile-1024x524.png" alt="ironstaticfile" width="840" height="430" /><br><br>&nbsp;<br><br>Hemos dado nuestros primeros pasos en Iron, un web framework para Rust. Iron es completamente modular y soporta muchas más cosas que aquí no hemos visto. Gran parte de su funcionalidad se implementa a través de middleware, como en otros web frameworks populares.