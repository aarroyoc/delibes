<blockquote>Este post usa Emscripten para generar WebAssembly con Rust. Hoy día Emscripten no es necesario, pero no he podido actualizar el tutorial</blockquote><br>Una de las cosas que más me han sorprendido del mundo web en estos años fue el proyecto WebAssembly. Un proyecto que pretendía traer un bytecode unificado para navegadores. Un proyecto que permitiría compilar prácticamente cualquier lenguaje a la web sin necesidad de tocar JavaScript.<br><br>El proyecto surgía de iniciativas fracasadas de Google (PNaCl) y de Mozilla (asm.js). Pero a este proyecto se unieron Microsoft y Apple, por lo que la compatibilidad estaba asegurada.<br><br>WebAssembly es un bytecode (como el de Java o el de .NET) que puede ser ejecutado por un navegador, cada navegador implementa su máquina virtual. También es posible usarlo en otros entornos relacionados con el mundo JavaScript como Node.js. Sin embargo entre los objetivos de WebAssembly está no estar atado a JavaScript, por lo que la especificación puede ser implementada por cualquier otro tipo de entorno. Actualmente WebAssembly no tiene recolector de basura y no tiene acceso directo a las Web API. No obstante, sigue siendo un proyecto interesante. Vamos a ver como usar WebAssembly con Rust.<br><h2>Instalando Rust y Emscripten</h2><br>Instala Rust, la versión estable es compatible con lo que queremos. Recomiendo usar Rustup.<br><pre id="5b07" class="graf graf--pre graf-after--p">curl <a class="markup--anchor markup--pre-anchor" href="https://sh.rustup.rs" target="_blank" rel="noopener noreferrer" data-href="https://sh.rustup.rs">https://sh.rustup.rs</a> -sSf | sh</pre><br>El paso clave es instalar un nuevo target, el target de WASM32 (WebAssembly de 32 bits).<br><pre id="832e" class="graf graf--pre graf-after--p">rustup target add wasm32-unknown-emscripten</pre><br>Por supuesto también hace falta instalar Emscripten.<br><br><a href="https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html#download-and-install">Descarga la versión portable de Emscripten aquí</a>. Descomprime y ejecuta<br><pre class="graf graf--pre graf-after--p">source .<strong class="markup--strong markup--pre-strong">/</strong>emsdk_env.sh<br>emsdk update<br>emsdk install latest<br>emsdk activate latest<br>source ./emsdk_env.sh<br>emcc -v (para comprobar)</pre><br>Emscripten ya estará instalado junto con Clang y las piezas claves de LLVM necesarias.<br><h2>Escribiendo el programa en Rust</h2><br>Vamos a escribir un programa simple. Un hola mundo.<br><br>&nbsp;<br><pre class="lang:rust decode:true">fn main(){<br>    println!("Hola mundo - WebAssembly + Rust");<br>}<br></pre><br>Compilamos con rustc<br><br>&nbsp;<br><pre class="lang:default decode:true">rustc --target=wasm32-unknown-emscripten main.rs -o main.html<br></pre><br>Esto genera diversos archivos: main.html, main.js, main.wasm y main.asm.js (para compatibilidad con navegadores que no tienen WebAssembly). El fichero .wasm contiene el bytecode, si intentas abrirlo verás que es ilegible. Sin embargo, Chrome, Firefox, Edge, Safari y Node.js entenderán ese archivo. Probamos el fichero main.html en Firefox (cuya última versión soporta WebAssembly por defecto):<br><br><a href="https://files.adrianistan.eu/WebASM-Rust.png"><img class="aligncenter size-large wp-image-811" src="https://files.adrianistan.eu/WebASM-Rust-1024x480.png" alt="" width="840" height="394" /></a><br>Usando este sistema compilamos aplicaciones enteras. Si se ajustan ciertos parámetros de Emscripten y se usa una crate adecuada en Rust puede usarse para generar juegos 3D usando WebGL escritos 100% en Rust.<br><h2>Cargas librerías en Rust desde JavaScript</h2><br>En el paso anterior vimos como compilar a WASM aplicaciones enteras. Ahora vamos a compilar el código de Rust a una librería y vamos a cargarlo con JavaScript.<br><br>La librería va a ser muy simple:<br><pre class="lang:rust decode:true">#[no_mangle]<br>pub fn random_number() -&gt; i32 {<br>    42<br>}<br><br>fn main() {<br><br>}<br><br></pre><br>Ahora compilamos el fichero a WebAssembly<br><pre class="lang:default decode:true">rustc --target=wasm32-unknown-emscripten random.rs<br></pre><br>Ahora vamos a cargar el fichero random.wasm. Para ello usaremos la ayuda de random.js, que contiene el código necesario para cargar el fichero WASM así como definir los imports que el código Rust espera (variables de entorno, funciones globales, etc).<br><br>&nbsp;<br><pre class="lang:default decode:true">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset="utf-8"/&gt;<br>	&lt;/head&gt;<br>	&lt;body&gt;<br>		&lt;script&gt;<br>		var Module = {<br>			wasmBinaryFile: "random.wasm",<br>			onRuntimeInitialized: main,<br>		};<br>		function main() {<br>			var random_number = Module.cwrap("random_number","number",[]);<br>			alert(random_number());<br>		}<br>		&lt;/script&gt;<br>		&lt;script src="random.js"&gt;&lt;/script&gt;<br>	&lt;/body&gt;<br>&lt;/html&gt;<br></pre><br><a href="https://files.adrianistan.eu/Rust42.png"><img class="aligncenter size-large wp-image-812" src="https://files.adrianistan.eu/Rust42-1024x495.png" alt="" width="840" height="406" /></a>Usando este sistema, podemos ir añadiendo código WASM poco a poco en nuestras webs.<br><br>&nbsp;<br><h2>Conclusión</h2><br>Como vemos, ya es posible hoy día usar WebAssembly en nuestros proyectos. Para crear el código WebAssembly podemos usar Rust. El código WASM puede interactuar con el código JavaScript existente. ¿Qué opináis de WebAssembly? ¿Creéis que puede suponer un antes y un después en el mundo web o se seguirá usando JavaScript de forma masiva?<br><br>&nbsp;