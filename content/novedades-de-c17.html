Después de tres años de trabajo, C++17 ha sido finalmente estandarizado. Esta nueva versión de C++ incorpora y elimina elementos del lenguaje, con el fin de ponerlo al día y convertirlo en un lenguaje moderno y eficaz. El comité ISO de C++ se ha tomado muy en serio su labor, C++11 supuso este cambio de mentalidad, que se ha mantenido en C++14 y ahora en C++17, la última versión de C++.<br><br><a href="https://files.adrianistan.eu/c17-programming-language.jpg"><img src="https://files.adrianistan.eu/c17-programming-language.jpg" alt="" width="900" height="500" class="aligncenter size-full wp-image-756" /></a><br><br>Repasemos las noveades que incorpora C++17 respecto a C++14<br><h3>if-init</h3><br>Ahora podemos incluir una sentencia de inicialización antes de la condición en sentencias if y switch. Esto es particularmente útil si queremos operar con un objeto y desconocemos su validez.<br><br><pre class="lang:c++ decode:true"><br>// ANTES<br>Device dev = get_device();<br>if(dev.isOk()){<br>    dev.hacerCosas();<br>}<br><br>// AHORA<br>if(Device dev = get_device(); dev.isOk()){<br>    dev.hacerCosas();<br>}<br></pre><br><br><h3>Declaraciones de descomposición</h3><br><br>Azúcar sintántico que permite mejorar la legibiliad en ciertas situaciones. Por ejemplo, en el caso de las tuplas, su uso se vuelve trivial.<br><br><pre class="lang:c++ decode:true"><br>// FUNCIÓN QUE DEVUELVE TUPLA<br>std::tuple&lt;int, std::string&gt; funcion();<br><br>// C++14<br>auto tup = funcion();<br>int i = std::get&lt;0&gt;(tup);<br>std::string s = std::get&lt;1&gt;(tup);<br><br>// C++17<br>auto [i,s] = funcion();<br><br></pre><br><br>Esto funciona para multitud de estructuras de datos, como estructuras, arrays, std::array, std::map,...<br><br><pre class="lang:c++ decode:true"><br>std::map m = ...;<br>for(auto &amp;&amp; [key, value] : m){<br><br>}<br></pre><br><br><h3>Deduction Guides</h3><br><br>Ahora es menos necesario que nunca indicar los tipos en ciertas expresiones. Por ejemplo, al crear pares y tuplas:<br><br><pre class="lang:c++ decode:true"><br>// ANTES<br>auto p = std::pair&lt;int,std::string&gt;(42,&quot;Adrianistan&quot;);<br><br>// AHORA<br>auto p = std::pair(42,&quot;Adrianistan&quot;);<br></pre><br><br>Esto por supuesto también sirve para estructuras y otras construcciones:<br><br><pre class="lang:c++ decode:true"><br>template&lt;typename T&gt;<br>struct Thingy<br>{<br>  T t;<br>};<br><br>// Observa<br>Thingy(const char *) -&gt; Thingy&lt;std::string&gt;;<br><br>Thingy thing{&quot;A String&quot;}; // thing.t es de tipo std::string<br></pre><br><br><h3>template auto</h3><br><br><pre class="lang:c++ decode:true"><br>// ANTES<br>template &lt;typename T, T v&gt;<br>struct integral_constant<br>{<br>   static constexpr T value = v;<br>};<br>integral_constant&lt;int, 2048&gt;::value<br>integral_constant&lt;char, 'a'&gt;::value<br><br>// AHORA<br>template &lt;auto v&gt;<br>struct integral_constant<br>{<br>   static constexpr auto value = v;<br>};<br>integral_constant&lt;2048&gt;::value<br>integral_constant&lt;'a'&gt;::value<br></pre><br><br><h3>Fold expressions</h3><br><br>Imagina que quieres hacer una función suma, que admita un número ilimitado de parámetros. En C++17 no se necesita apenas código.<br><br><pre class="lang:c++ decode:true"><br>template &lt;typename... Args&gt;<br>auto sum(Args&amp;&amp;... args) {<br>   return (args + ... + 0);<br>}<br></pre><br><br><h3>Namespaces anidados</h3><br><br>Bastante autoexplicativo<br><br><pre class="lang:c++ decode:true"><br>// ANTES<br><br>namespace A{<br>    namespace B {<br>        bool check();<br>    }<br>}<br><br>// AHORA<br><br>namespace A::B {<br>    bool check();<br>}<br></pre><br><br><h3>Algunos [[atributos]] nuevos</h3><br><br><h4>[[maybe_unused]]</h4><br>Se usa para suprimir la advertencia del compilador de que no estamos usando una determinada variable.<br><br><pre class="lang:c++ decode:true"><br>int x = 5;<br>[[maybe_unused]] bool azar = true;<br>x = x + 10<br></pre><br><br><h4>[[fallthrough]]</h4><br><br>Permite usar los switch en cascada sin advertencias del compilador.<br><pre class="lang:c++ decode:true"><br>switch (device.status())<br>{<br>case sleep:<br>   device.wake();<br>   [[fallthrough]];<br>case ready:<br>   device.run();<br>   break;<br>case bad:<br>   handle_error();<br>   break;<br>}<br></pre><br><br><h3>Variables inline</h3><br><br>Ahora es posible definir variables en múltiples sitios con el mismo nombre y que compartan una misma instancia. Es recomendable definirlas en un fichero de cabecera para luego reutilizarlas en ficheros fuente.<br><br><pre class="lang:c++ decode:true"><br>// ANTES<br>// en una cabecera para que la usasen los demás<br>extern int x;<br><br>// solo en un fichero fuente, para inicializarla<br>int x = 42;<br>// AHORA<br><br>// en la cabecera<br>inline int x = 42;<br><br></pre><br><br><h3>if constexpr</h3><br><br>Ahora es posible introducir condicionales en tiempo de compilación (similar a las macros #IFDEF pero mejor hecho). Estas expresiones con constexpr, lo que quiere decir que son código C++ que se evalúa en tiempo de compilación, no de ejecución.<br><br><pre class="lang:c++ decode:true"><br>template&lt;class T&gt;<br>void f (T x)<br>{<br>    if  constexpr(std:: is_integral &lt;T&gt;::value)  {<br>        implA(x);<br>    }<br>    else  if  constexpr(std:: floating_point &lt;T&gt;::value)  {<br>        implB(x);<br>    }<br>    else<br>    {<br>        implC(x);<br>    }<br>}<br></pre><br><br><h3>std::optional</h3><br><br>Tomado de la programación funcional, se incorpora el tipo optional, que representa un valor que puede existir o no. Este tipo ya existe en Rust bajo el nombre de Option y en Haskell como Maybe.<br><br><pre class="lang:c++ decode:true"><br>std::optional opt = f();<br>if(opt)<br>    g(*opt);<br><br>// otra opción de uso si queremos proveer de un reemplazo<br>std::optional opt = f();<br>std::cout &lt;&lt; opt.value_or(0) &lt;&lt; std::endl;<br></pre><br><br><h3>std::variant</h3><br><br>Descritas como las unions pero bien hechas. Pueden contener variables de los tipos que nosotros indiquemos.<br><br><pre class="lang:c++ decode:true"><br>std::variant&lt;int, double, std::vector&gt; precio; // precio puede ser un int, un double o un std::vector<br><br>// comprobar si el valor en un variant es de un determinado tipo<br>if(std::holds_alternative&lt;double&gt;(precio))<br>    double x = std::get&lt;double&gt;(precio);<br></pre><br><br><h3>std::any</h3><br><br>Si con std::variant restringimos los posibles tipos de la variable a los indicados, con std::any admitimos cualquier cosa.<br><br><pre class="lang:c++ decode:true"><br>std::any v = ...;<br>if (v.type() == typeid(int)) {<br>   int i = any_cast&lt;int&gt;(v);<br>}<br></pre><br><br><h3>std::filesystem</h3><br>Se añade a la librería estándar este namespace con el tipo path y métodos para iterar y operar con directorios. Dile adiós a las funciones POSIX o Win32 equivalentes.<br><br><pre class="lang:c++ decode:true"><br>#include &lt;filesystem&gt;<br>#include &lt;iostream&gt;<br>namespace fs = std::filesystem;<br><br>void main(){<br>  fs::path dir = &quot;/&quot;;<br>  dir /= &quot;sandbox&quot;;<br>  fs::path p = dir / &quot;foobar.txt&quot;;<br>  std::cout &lt;&lt; p.filename() &lt;&lt; &quot;\n&quot;;<br>  fs::copy(dir, &quot;/copy&quot;, fs::copy_options::recursive);<br>}<br></pre><br><br><h3>Algoritmos en paralelo</h3><br><br>Muchos de los algoritmos de STL ahora pueden ejecutarse en paralelo bajo demanda. Con std::execution::par indicamos que queremos que el algoritmo se ejecute en paralelo.<br><br><pre class="lang:c++ decode:true"><br>std::sort(std::execution::par, first, last);<br></pre><br><br><h3>¿Qué novedades se esperan en C++20?</h3><br>Ya hemos visto lo que trae C++17. Ahora veremos que se espera que traiga C++20 en 2020.<br><ul><br>    <li>Módulos. Reemplazar el sistema de includes</li><br>    <li>Corrutinas. Mejorar la programación asíncrona</li><br>    <li>Contratos. Mejorar la calidad del código</li><br>    <li>Conceptos. Mejorar la programación genérica</li><br>    <li>Redes. Estandarizar la parte de red en C++ tal y como se ha hecho con std::filesystem</li><br>    <li>Rangos. Nuevos contenedores</li><br></ul><br><br><h2>Referencias:</h2><br><br><ul><br><li><a href="https://usingstdcpp.org/using-stdcpp-2016/programa-2016/cpp17-ya-esta-aqui-o-casi/">https://usingstdcpp.org/using-stdcpp-2016/programa-2016/cpp17-ya-esta-aqui-o-casi/</a></li><br><li><a href="https://github.com/tvaneerd/cpp17_in_TTs/blob/master/ALL_IN_ONE.md">https://github.com/tvaneerd/cpp17_in_TTs/blob/master/ALL_IN_ONE.md</a></li><br></ul><br><br>&nbsp;