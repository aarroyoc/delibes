Los lenguajes de programación imperativos no serían nada sin sus estructuras de control. En Rust no son muy diferentes respecto a otros lenguajes. Ya hemos visto de pasada que existe <strong>if-else</strong> y <strong>for-in</strong>. Ahora veamos la lista entera junto con un operador muy importante en Rust, <strong>match</strong>.<br><h2>Condicionales, if, if-else, if-let</h2><br>En Rust <strong>if-else</strong> funciona de forma parecida a otros lenguajes, quizá lo único destacable sea que no hacen falta los paréntesis.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let ano = 1998;<br>    if ano &gt; 1975{<br>        println!(&quot;Deberías escuchar a Ennio Morricone&quot;);<br>    }else if ano &gt; 1600{<br>        println!(&quot;Deberías escuchar a Bach&quot;);<br>    }else{<br>        println!(&quot;Deberías escuchar a tu monje benedictino más próximo&quot;);<br>    }<br>}<br></pre><br><br>En realidad la sintaxis del <strong>if</strong> no es tan simple, ya que existe una versión vitaminada, pensada para tratar con Option y Result. Se trata de <strong>if-let</strong>, una construcción tomada de Swift y que sirve para ejecutar una porción de código sólo si el valor existe (en el caso de Option) o no ha habido fallos (con Result).<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let url = Some(&quot;https://blog.adrianistan.eu&quot;);<br><br>    if let Some(url) = url {<br>        println!(&quot;{}&quot;,url);<br>    }<br><br>    let magic_box: Result&lt;String,String&gt; = Ok(String::from(&quot;Aquí no hay nada&quot;));<br>    if let Ok(magic_box) = magic_box {<br>        println!(&quot;{}&quot;,magic_box);<br>    }<br><br>    let url: Option&lt;&amp;'static str&gt; = None;<br>    if let Some(url) = url {<br>        println!(&quot;{}&quot;,url);<br>    }<br>    <br>    let magic_box: Result&lt;String,String&gt; = Err(String::from(&quot;No tienes la llave de la caja&quot;));<br>    if let Ok(magic_box) = magic_box {<br>        println!(&quot;{}&quot;,magic_box);<br>    }<br><br>}<br></pre><br><br><h2>Condicionales, match</h2><br><strong>match</strong> es un potente condicional en Rust basado en concordancia de patrones. Podemos pensar en ello como un <strong>switch</strong> vitaminado, pero realmente es capaz de hacer muchas más cosas. Como curiosidad, mencionar que ciertos lenguajes de programación como Haskell usan la concordancia de patrones muy a menudo y consiguen obtener un código muy claro.<br><br>Para demostrar el uso del match primero vamos a construir una tupla con cuatro valores.<br><br><pre class="lang:rust decode:true"><br>fn buscar(t: (bool,&amp;'static str,&amp;'static str,i32)) -&gt; &amp;'static str{<br>    match t {<br>        (true,&quot;Mike Oldfield&quot;,&quot;The Bell&quot;,1992) =&gt; &quot;Gran canción&quot;,<br>        (true,&quot;Mike Oldfield&quot;,_,1992) =&gt; &quot;Tubular Bells II probablemente&quot;,<br>        (true,autor,_,_) =&gt; autor,<br>        (false,..) =&gt; &quot;Disco no existente&quot;,<br>        _ =&gt; &quot;¿Qué me has pasado exactamente?&quot;<br>    }<br>}<br><br>fn main(){<br>    let tupla = (true,&quot;Mike Oldfield&quot;,&quot;The Bell&quot;,1992);<br><br>    let busqueda = buscar(tupla);<br>    println!(&quot;{}&quot;,busqueda);<br><br>}<br></pre><br><br><strong>match</strong> realiza comparaciones de arriba a abajo y devuelve la expresión después de la flecha. Como os habréis imaginado, al ser una expresión directamente no se pone punto y coma y no hace falta hacer return en la función de ningún tipo.<br><br>La primera condición del match es clara: si es exactamente igual la tupla a la descrita se devuelve <em>Gran canción</em>. En la segundo vemos una barra baja. Ya hemos hablado de él, pero vamos a recordarlo. Se trata del operador que usamos cuando algo nos da igual. Similar a un asterisco en la terminal de Linux.<br><br>El tercer caso es interesante pues nos permite comprobar concordancia en el primer campo y a su vez nos permite extraer el valor del segundo campo, que queda en la variable autor.<br><br>El cuarto caso es para los perezosos, simplemente con que cumpla una condición, el resto ni nos molestamos en escribir. Usando los dos puntos hacemos que todos los false vayan al mismo sitio.<br><br>Por último pero no menos importante, tenemos la barra baja. Cualquier tupla que no haya caído antes en otro caso caerá en este. (En este ejemplo no puede llegar a funcionar, pues con los casos anteriores ya hemos cubierto el espectro. El compilador de Rust nos avisa de que no hay posibilidad de que alguna vez se alcance ese código).<br><br>Existen más opciones, una barra horizontal <strong>|</strong> nos servirá para hacer un OR. Si trabajamos con números, <strong>1..10</strong> representa un intervalo en el que caen los valores admitidos.<br><br>Por descontando, <strong>match</strong> no solo funciona en tuplas, sino que tiene una gran variedad de usos.<br><h2>Bucles, loop y while</h2><br>Estos bucles funcionan prácticamente igual que en otros lenguajes. <strong>loop</strong> es un bucle infinito que solo se rompe con <strong>break</strong>. <strong>while </strong>tiene una condición que se comprueba al inicio.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let mut n = 0;<br>    loop {<br>        if n &gt; 100{<br>            break;<br>        }<br>        println!(&quot;No soy pesado&quot;);<br>        n+=1;<br>    }<br><br>    while n &lt; 200{<br>        println!(&quot;No soy pesado&quot;);<br>        n+=1;<br>    }<br>}<br></pre><br><br>Es conveniente usar los bucles <strong>while</strong> cuando tenemos una bandera o una condición inesperada, pero nunca para recorrer elementos de una lista o similares.<br><h2>Bucles, for-in</h2><br>En Rust se toma el ejemplo de lenguajes como Python y se deja atrás el bucle <strong>for</strong> de C. El bucle <strong>for-in</strong> recorre todos los elementos de un <strong>Iterable</strong>. Un <strong>Iterable</strong> es cualquier cosa que implemente la trait <strong>Iterable</strong>, y que como en lenguajes como Python y JavaScript con los generadores, puede no ser necesariamente una lista, simplemente algo sobre lo que se pueda iterar. Estos elementos son perezosos y solo se calculan cuando son necesarios, abriendo la posibilidad a listas infinitas. Los vectores son <strong>Iterables</strong>, veamos como usarlos.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let v = vec![&quot;Haskell&quot;,&quot;Elm&quot;,&quot;Python&quot;,&quot;C++&quot;,&quot;JavaScript&quot;,&quot;Rust&quot;,&quot;Java&quot;];<br>    for s in v{<br>        println!(&quot;{}&quot;,s);<br>    }<br>}<br></pre><br><br>Como vemos, es bastante simple. Este programa imprime cada lenguaje de programación por pantalla. El código no es muy complicado.<br><br>¿Y si resulta que quiero iterar N veces y no tengo un <strong>Iterable</strong> a mano? Similar al <strong>range</strong> de Python, existe una sintaxis compacta y clara.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let n = 100;<br>    for i in 0..n{<br>        println!(&quot;{}&quot;,i);<br>    }<br>}<br></pre><br><br>La sintaxis de dos puntos permite iterar en un rango en Z cerrado por la izquierda y abierto por la derecha. Muchas cosas de la librería estándar son iterables y cualquier array o vector puede serlo, así que este será probablemente el bucle que más uses.<br><br>Con esto acabamos las estructuras de control, listos para entrar en temas más avanzados.<br><br>&nbsp;