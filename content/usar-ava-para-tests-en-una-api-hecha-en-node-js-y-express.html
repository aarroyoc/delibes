Testear nuestras aplicaciones es algo fundamental si queremos garantizar un mínimo de calidad. En este breve post, explicaré como he usado <a href="https://github.com/avajs/ava">AVA</a> para crear tests para mis APIs: tanto unitarios como de integración con AVA.<br><br><a href="https://files.adrianistan.eu/ava.png"><img class="aligncenter size-large wp-image-1500" src="https://files.adrianistan.eu/ava-1024x640.png" alt="" width="840" height="525" /></a><br><br>AVA es una herramienta de testing, que nos permite describir los tests de forma muy sencilla. De todas las herramientas que he probado, AVA es muy preferida. Es muy sencilla, ejecuta los tests en paralelo y permite escribir código en ES6 (usa Babel por debajo). Además tiene bastante soporte siendo el framework de testing usando por muchos proyectos ya.<br><br>Instalamos AVA de la forma típica:<br><pre class="lang:default decode:true ">npm install ava --save-dev</pre><br>A continuación creamos un fichero cuya terminación sea .test.js, por ejemplo, <em>suma.test.js</em>. El lugar da igual.<br><br>Una opción de diseño es poner los test unitarios al lado de las funciones en sí, otra opción es crear una carpeta para todos los tests, ya que los de integración van a ir casi siempre ahí. Para ejecutar los tests, simplemente:<br><pre class="lang:default decode:true">ava</pre><br><a href="https://files.adrianistan.eu/AvaTest.png"><img class="aligncenter size-full wp-image-1501" src="https://files.adrianistan.eu/AvaTest.png" alt="" width="571" height="151" /></a>El interior de <em>suma.test.js</em> debe importar la función <strong>test</strong> de AVA y las funciones que quiera probar.<br><br>Los tests se definen como una llamada a la función test con la descripción del test y a continuación un callback (asíncrono si queremos) con el objeto que controla los tests (llamado t normalmente). Veamos un ejemplo simple:<br><pre class="lang:js decode:true">import test from "ava";<br>import {suma} from "./operaciones";<br><br>test("Suma",t =&gt; {<br>    t.is(suma(1,2),3);<br>});</pre><br>El objeto t soporta múltiples operaciones, siendo <strong>is</strong> la más básica. Is pide que sus dos argumentos sean iguales entre sí, como Assert.Equal de xUnit.<br><br>Veamos que más soporta Ava.<br><ul><br> 	<li><em>t.pass()</em>: Continúa el test (sigue)</li><br> 	<li><em>t.fail()</em>: Falla el test (no sigue)</li><br> 	<li><em>t.truthy(val)</em>: Continúa el test si val es <em>verdaderoso</em> (usando la lógica de JavaScript) o falla el test</li><br> 	<li><em>t.true(val)</em>: Continúa el test si val es <em>verdadero</em> (más estricto que el anterior) o falla.</li><br> 	<li><em>t.is(val1,val2)</em>: Continúa el test si val1 y val2 son iguales (superficialmente) o falla.</li><br> 	<li><em>t.deepEqual(val1,val2)</em>: Continúa el test si val1 y val2 son iguales (profundamente) o falla.</li><br> 	<li><em>t.throws(funcion)</em>: Ejecuta la función especificada esperando que lance una excepción. Si no lo hace, falla el test. Se puede especificar el tipo de excepción que esperamos en el segundo argumento.</li><br> 	<li><em>t.notThrows(funcion)</em>: Exactamente lo contrario que la anterior.</li><br></ul><br>Y algunas más, pero estas son las esenciales.<br><pre class="lang:js decode:true ">import test from "ava";<br><br>function sum(a,b){<br>    return a+b;<br>}<br><br>function login(username,password){<br>    if(username === null || password === null){<br>        throw new Error("Missing username or password");<br>    }<br>}<br><br>test("Test example: Sum",t =&gt; {<br>    t.is(sum(1,2),3);<br>});<br><br>test("Login fail username null", t =&gt; {<br>    t.throws(()=&gt;{<br>        login(null,"123456");<br>    });<br>});<br>test("Login fail password null", t =&gt; {<br>    t.throws(()=&gt;{<br>        login("username",null);<br>    });<br>});</pre><br>También podemos definir funciones que se ejecuten antes y después de nuestros tests, y una sola vez o con cada test. Podemos usar <strong>test.before, test.beforeEach, test.after</strong> y <strong>test.afterEach</strong> en vez de <strong>test</strong>. Por ejemplo, si tienes una base de datos que necesita inicialización, puedes definir ese código en <strong>test.before</strong> y la limpieza en <strong>test.after</strong>.<br><pre class="lang:js decode:true ">import test from "ava";<br>import db from "../db";<br><br>test.before(async () =&gt; {<br>    // Iniciar el ORM Sequelize<br>    await db.sync();<br>});<br></pre><br>&nbsp;<br><br>Con esto ya podemos hacer tests unitarios, pero no podemos probar la aplicación web al 100%. Entra en acción <strong>supertest</strong> que nos permitirá tener un servidor Express simulado para que los tests puedan probar la aplicación al completo.<br><h2>Supertest</h2><br>Instalamos supertest<br><pre class="lang:default decode:true ">npm install supertest --save-dev</pre><br>En el fichero de test necesitamos crear un objeto de tipo aplicación de Express. Este objeto puede ser el mismo que usas en tu aplicación real o ser una versión simplificada con lo que quieras probar.<br><pre class="lang:js decode:true">import test from "ava";<br>import request from "supertest";<br>import auth from "http-auth";<br>import express from "express";<br><br>function setup(){<br>    const app = express();<br><br>    let basic = auth.basic({<br>        realm: "Upload Password"<br>    }, function (username, password, callback) {<br>        callback(username === "admin" &amp;&amp; password === "123456");<br>    });<br><br>    app.get("/upload",auth.connect(basic),function(req,res){<br>        res.sendFile("upload.html");       <br>    });<br>    return app;<br>}<br><br>test("Página upload requiere autenticación HTTP Basic", async t =&gt; {<br>    let res = await request(setup())<br>        .get("/upload")<br>        .send();<br>    t.is(res.status,401);<br>    t.true(res.header["www-authenticate"] !== undefined);<br>});</pre><br>Aquí la función de test es asíncrona, AVA es compatible con ambos tipos. Supertest es muy completo y permite probar APIs enteras con su sencilla interfaz que junto con AVA, se convierte en algo casi obligatorio para una aplicación que vaya a producción.