Rust es un lenguaje con muchas posibilidades pero existe mucho código ya escrito en librerías de C y C++. Código que ha llevado mucho tiempo, que ha sido probado en miles de escenarios, software maduro y que no compensa reescribir. Afortunadamente podemos reutilizar ese código en nuestras aplicaciones Rust a través de bindings. Los bindings no son más que trozos de código que sirven de pegamento entre lenguajes. Esto es algo que se ha podido hacer <em>desde siempre</em> pero dependiendo de la librería podía llegar a ser muy tedioso. Afortunadamente tenemos <a href="https://github.com/rust-lang-nursery/rust-bindgen"><strong>bindgen</strong></a>, un programa que permite generar estos bindings de forma automática analizando el código de la librería de C o C++.<br><br><a href="https://files.adrianistan.eu/glue-304256_1280.png"><img class="aligncenter wp-image-1452 size-medium" src="https://files.adrianistan.eu/glue-304256_1280-279x300.png" alt="" width="279" height="300" /></a><br><br>En este post veremos como usar <strong>SQLite</strong> desde Rust usando bindgen.<br><h2>Instalando bindgen</h2><br>En primer lugar necesitamos tener instalado <strong>Clang 3.9</strong> o superior. En Ubuntu o Debian necesitamos estos paquetes:<br><pre class="lang:default decode:true ">sudo apt install llvm-3.9-dev libclang-3.9-dev clang-3.9</pre><br>Para el resto de plataformas puedes descargar el binario desde la <a href="https://releases.llvm.org/download.html">página de descargas de LLVM</a>.<br><br>Bindgen permite dos modos de uso: línea de comandos o desde el código Rust. El más habitual es desde código Rust pero antes veremos el modo en línea de comandos.<br><h2>Modo línea de comandos</h2><br>Para bindings sencillos podemos usar el modo línea de comandos. Instalamos binden con Cargo:<br><pre class="lang:default decode:true">cargo install bindgen</pre><br>Su uso es muy sencillo:<br><pre class="lang:default decode:true ">bindgen /usr/include/sqlite3.h -o sqlite.rs</pre><br>Simplemente indicamos el fichero de cabecera que queremos traducir y su correspondiente fichero de salida en Rust. Este fichero será el pegamento. Vamos a crear un programa que use este pegamento:<br><pre class="lang:rust decode:true">mod sqlite;<br><br>use sqlite::{sqlite3_open, sqlite3_exec, sqlite3_close, SQLITE_OK};<br>use std::ffi::CString;<br>use std::ptr::{null_mut,null};<br><br>fn main(){<br>    let mut db = null_mut();<br>    let database_name = CString::new("test.db").unwrap().into_raw();<br>    let sql = CString::new("<br>    CREATE TABLE contacts (name TEXT, tel TEXT);<br>    INSERT INTO contacts VALUES ('Adrian','555-555-555');").unwrap().into_raw(); <br>    let mut error_msg = null_mut();<br>    unsafe{<br>        sqlite3_open(database_name,&amp;mut db);<br>        let rc = sqlite3_exec(db,sql,None,null_mut(),&amp;mut error_msg);<br>        if rc != SQLITE_OK as i32 {<br>            let error = CString::from_raw(error_msg);<br>            println!("ERROR: {}",error.into_string().unwrap());<br>        }<br>        sqlite3_close(db);<br>    }<br>}</pre><br>Como se puede apreciar, las llamadas al módulo de pegamento de hacen desde un bloque <strong>unsafe</strong> ya que se van a usar punteros al estilo C, de forma insegura. <a href="https://blog.adrianistan.eu/2017/10/12/diversion-punteros-rust-bloques-unsafe/">Hace tiempo escribí sobre ello</a> así que voy a saltarme esa parte.<br><br>Compilamos enlazando de forma manual <strong>libsqlite3</strong> de la siguiente forma:<br><pre class="lang:default decode:true ">rustc main.rs -lsqlite3</pre><br>Si todo va bien, compilará aunque con numerosos warnings. En principio no son importantes.<br><br>Ahora si ejecutamos el programa resultante debería crear una base de datos nueva con una tabla contacts y los datos insertados.<br><br><a href="https://files.adrianistan.eu/SQliteBindgen.png"><img class="aligncenter size-full wp-image-1451" src="https://files.adrianistan.eu/SQliteBindgen.png" alt="" width="725" height="266" /></a>¡Hemos conseguido llamar a una librería de C desde Rust y no hemos escrito ningún binding!<br><h2>Build.rs</h2><br>El sistema anterior funciona, pero no es lo más práctico, además no usa Cargo que es el sistema estándar de construcción de programas y crates un Rust. Lo habitual es dejar este proceso automatizado en el fichero <strong>build.rs</strong> que se ejecuta con Cargo.<br><br>Lo primero es añadir la siguiente línea al fichero Cargo.toml:<br><pre class="lang:default decode:true ">[build-requires]<br>bindgen = "0.26.3"</pre><br>El siguiente paso consiste en crear un archivo cabecera de C que a su vez haga referencia a todos los archivos de cabecera que necesitamos. En el caso de SQLite es bastante simple.<br><pre class="lang:c decode:true ">#include &lt;sqlite3.h&gt;</pre><br>Y lo llamamos wrapper.h<br><br>Ahora viene lo interesante. Dentro de build.rs creamos un programa que gracias a la API de bindgen haga lo mismo que la línea de comandos.<br><pre class="lang:rust decode:true " title="build.rs">extern crate bindgen;<br><br>use std::env;<br>use std::path::PathBuf;<br><br>fn main() {<br>    // indicamos al linker que necesitamos sqlite3<br>    println!("cargo:rustc-link-lib=sqlite3");<br><br><br>    let bindings = bindgen::Builder::default()<br>        .header("wrapper.h")<br>        .generate()<br>        .expect("Unable to generate bindings");<br><br>    // escribir los bindings en $OUT_DIR/bindings.rs<br>    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());<br>    bindings<br>        .write_to_file(out_path.join("bindings.rs"))<br>        .expect("Couldn't write bindings!");<br>}</pre><br>El archivo build.rs debe estar en la misma carpeta que Cargo.toml para que funcione.<br><br>Finalmente para hacer accesible nuestros bindings creamos un módulo llamado sqlite.rs con el siguiente contenido.<br><pre class="lang:rust decode:true " title="sqlite.rs">#![allow(non_upper_case_globals)]<br>#![allow(non_camel_case_types)]<br>#![allow(non_snake_case)]<br><br>include!(concat!(env!("OUT_DIR"), "/bindings.rs"));</pre><br>Lo único que hace es desactivar unos warnings molestos e incluir el texto de bindings.rs al completo.<br><br>Una vez hecho esto podemos usar desde el programa principal la librería de la misma forma que hemos visto antes.<br><br>Ahora podríamos usar estos bindings directamente en nuestro programa o <em>rustizarlos</em> (darles una capa segura alrededor e idiomática) y subirlo a Crates.io.<br><br><a href="https://github.com/aarroyoc/blog-ejemplos/tree/master/sqlite-bindgen"><em>El código del post está en GitHub</em></a>