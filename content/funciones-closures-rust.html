Rust posee una sintaxis para definir funciones muy similar a la de otros lenguajes. Veamosla en acción.<br><h2>Funciones simples</h2><br>Las funciones se definen con la palabra reservada <strong>fn</strong>. Posteriormente indicamos el nombre de la función y los argumentos de entrada. Si la función devuelve un valor se debe poner una flecha y el tipo del valor de devolución. Para devolver un valor se puede usar <strong>return</strong> o se puede dejar la última línea sin punto y coma. Funciona de forma similar a como vimos con <strong>let</strong> y las asignaciones complejas.<br><br><pre class="lang:rust decode:true"><br>fn suma(a: i32, b: i32) -&gt; i32{<br>    a+b<br>}<br><br>fn main(){<br>    let a = 5;<br>    let b = 42;<br>    let c = suma(a,b);<br>    println!(&quot;{}&quot;,c);<br>}<br></pre><br><br>Rust como tal no admite devolver varios valores a la vez, pero es posible usar tuplas y simularlo.<br><br><pre class="lang:rust decode:true"><br>fn string_length_and_lines(txt: &amp;String) -&gt; (usize,usize) {<br>    (txt.len(),txt.lines().count())<br>}<br><br>fn main(){<br>    let s = String::from(&quot;Europe's Skies - Alexander Rybak\nSuper Strut - Deodato\nEl Cóndor Pasa - Uña Ramos&quot;);<br>    let (length,lines) = string_length_and_lines(&amp;s);<br>    println!(&quot;La lista de canciones tiene una longitud de {} caracteres y {} líneas&quot;,length,lines);<br>}<br></pre><br><br><h2>Funciones de primer nivel</h2><br>En Rust las funciones son elementos de primer nivel, lo que quiere decir que pueden pasarse por argumentos entre funciones. Veamos un ejemplo. En este caso uso un <strong>for-in</strong> que todavía no hemos visto, pero la idea es comprobar como se puede pasar una función a través de un argumento.<br><br><pre class="lang:rust decode:true"><br>fn ladrar(){<br>    println!(&quot;Guau&quot;)<br>}<br><br>fn hacer_n_veces(f: fn(), n: i64){<br>    for _ in 0..n{<br>        f();<br>    }<br>}<br><br>fn main(){<br>    hacer_n_veces(ladrar,42);<br>}<br></pre><br><br>&nbsp;<br><h2>Genericidad</h2><br>Las funciones en Rust admiten genericidad, lo que quiere decir que la misma función es compatible con distintos tipos, siempre respetando las normas. Usualmente, para denominar al tipo genérico se usa T. T se sustituye en cada caso por el tipo en cuestión. Entonces si en el primer parámetro de la función hemos puesto un i32 y T también está en el segundo, este también tiene que ser i32.<br><br><pre class="lang:rust decode:true"><br>fn mayor&lt;T: PartialOrd + Copy&gt;(n: &amp;Vec&lt;T&gt;) -&gt; T{<br>    let mut max: T = n[0];<br>    for &amp;i in n.iter(){<br>        if i &gt; max{<br>            max = i;<br>        }<br>    }<br>    max<br>}<br><br>fn main(){<br>    let v: Vec&lt;i32&gt; = vec![1,2,7,8,123,4];<br>    let max = mayor(&amp;v);<br>    println!(&quot;{}&quot;,max);<br>}<br></pre><br><br>En este ejemplo además vemos genericidad restringida, la cuál es la más habitual. Básicamente T puede ser cualquier tipo pero debe de implementar las <strong>traits</strong> PartialOrd (para hacer la comparación) y <strong>Copy</strong> (elementos que se copian, en vez de moverse). La genericidad en Rust es un campo muy extenso, no obstante para entenderla bien, tendremos que entrar en las <strong>traits</strong>, ya en otro capítulo.<br><h2>Closures</h2><br>Los closures o funciones anónimas son funciones sin nombre que se definen y se consumen. En lenguajes como Python existen bajo la palabra reservada <strong>lambda</strong>. En Rust se definen con barras verticales.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let potencia = |x| x*x;<br>    let pot_5 = potencia(5);<br>    println!(&quot;{}&quot;,pot_5);<br>}<br></pre><br><br>Como es de imaginar podemos usar expresiones más complejas entre llaves.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let potencia_sup = |x| {<br>        let y = x+1;<br>        y*y<br>    }; <br>    let pot_5 = potencia_sup(5);<br>    println!(&quot;{}&quot;,pot_5);<br>}<br></pre><br><br>Con esto sabemos lo suficiente de funciones y genericidad para avanzar a otros temas.