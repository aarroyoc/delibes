Llevo varios años usando de forma habitual CMake. Sin embargo me doy cuenta que alguien que quiera empezar a usar este sistema va a encontrarse con documentación confusa.<br><blockquote>1º Regla de CMake. La documentación puede ser confusa</blockquote><br><h2>¿Qué es CMake?</h2><br>CMake se trata de una herramienta multiplataforma para generar instrucciones de compilación del código. No sustituye a las herramientas de compilación como Make o MSBuild, sino que nos proporciona un único lenguaje que será transformado a las instrucciones del sistema operativo donde nos encontremos. Sería un sustituto de Autotools.<br><br><img class="alignnone size-large wp-image-310" src="https://files.adrianistan.eu/cmake-dia-1024x425.png" alt="cmake-dia" width="840" height="349" /><br><br>Las ventajas son que no tenemos que tener varios archivos para gestionar la compilación. Usando CMake podemos generar el resto. Actualmente CMake (3.2.3) soporta:<br><ul><br> 	<li>Unix Make</li><br> 	<li>Ninja</li><br> 	<li>CodeBlocks</li><br> 	<li>Eclipse CDT</li><br> 	<li>KDevelop</li><br> 	<li>Sublime Text 2</li><br> 	<li>Borland Make</li><br> 	<li>MSYS Make</li><br> 	<li>MinGW Make</li><br> 	<li>NMake</li><br> 	<li>NMake JOM</li><br> 	<li>Watcom WMake</li><br> 	<li>Kate</li><br> 	<li>CodeLite</li><br> 	<li>Xcode</li><br> 	<li>Visual Studio (desde el 6 hasta 2013)</li><br></ul><br><h2>Usando CMake</h2><br>En CMake las configuraciones estan centralizadas por defecto en un archivo llamado CMakeLists.txt. Este se encuentra en la carpeta central del proyecto. Normalmente con CMake los proyectos se construyen en una carpeta diferente de la que tenemos el código fuente. Es corriente crear una carpeta <em>build</em> en lo alto del proyecto. Así si tenemos un proyecto con CMake ya descomprimido haríamos lo siguiente.<br><pre class="lang:default decode:true">mkdir build<br>cd build<br>cmake ..<br># make o ninja o nmake o lo que toque<br></pre><br>También puedes usar la aplicación gráfica. Muy cómoda cuando debamos modificar las configuraciones.<br><br><img class="alignnone size-large wp-image-21" src="https://files.adrianistan.eu/cmake-gui-1024x578.png" alt="cmake-gui" width="840" height="474" /><br><br>Podemos ajustar las variables de CMake desde la interfaz de usuario, usando el modo interactivo de la línea de comandos (`cmake .. -i`) o usando flags cuando llamamos a CMake (`cmake .. -DCMAKE_CXX_FLAGS=-std=c++11`)<br><h2>El archivo CMakeLists.txt</h2><br>Ya estamos listos para crear nuestro primer archivo de configuración de CMake.<br><br><img class="alignnone size-large wp-image-311" src="https://files.adrianistan.eu/proyecto-1024x788.png" alt="proyecto" width="840" height="646" /><br><br>Vamos a ir viendo distintas versiones del archivo donde voy a ir añadiendo diferentes tareas. Estate atento a los comentarios de los archivos<br><h4>Compilar como programa main.cpp</h4><br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br># Indicamos la versión mínima que necesitamos de CMake<br><br>SET(MiProyecto_SRC "src/main.cpp")<br># Creamos la variable MiProyecto_SRC y le asignamos el valor "src/main.cpp" que es la ubicación de nuestro archivo.<br># Por defecto las variables son listas o arrays<br># Si tenemos dos archivos sería SET(MiProyecto_SRC "src/main.cpp"<br>"src/segundo.cpp")<br># Se permite multilínea<br><br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br><br># Se creará un ejecutable llamado MiProyecto en Linux o MiProyecto.exe en Windows.<br># Se hace referencia a las variables con ${NOMBRE_VARIABLE}.<br></pre><br>Y ya está.<br><h2>Trabajar con opciones y condicionales</h2><br>CMake permite ajustar muchas opciones como hemos visto con el asistente gráfico de CMake. Sin embargo no todas las variables se muestran ahí. Solo son modificables las que nosotros marquemos explícitamente. Se usa OPTION()<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(MiProyecto_SRC "src/main.cpp")<br><br>OPTION(EXPERIMENTAL_FEATURE "Activar característica experimental" OFF)<br># OPTION(NOMBRE_VARIABLE DESCRIPCION_LEGIBLE VALOR_POR_DEFECTO)<br># ON/OFF es la pareja de valores booleanos en CMake. TRUE/FALSE también es correcto<br><br>IF(EXPERIMENTAL_FEATURE) # El condicional más básico<br>LIST(APPEND MiProyecto_SRC "experimental_feature.cpp")<br># Añadimos un elemento a la lista<br># También se puede hacer con<br># SET(MiProyecto_SRC ${MiProyecto_SRC} "experimental_feature.cpp")<br>ENDIF()<br><br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br></pre><br><h2>Usar librería estática</h2><br><pre class="lang:default decode:true">PROJECT(MiProyecto C CXX)<br># Podemos marcar opcionalmente los lenguajes para que CMake busque los compiladores<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(MiProyecto_SRC "src/main.cpp")<br>SET(Lib_SRC "lib/lib.cpp")<br><br>ADD_LIBRARY(Lib STATIC ${Lib_SRC})<br># El comando es exactamente igual que ADD_EXECUTABLE, pero marcamos si STATIC o SHARED<br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br>TARGET_LINK_LIBRARIES(MiProyecto ${Lib})<br># Necesitamos "unir" la librería con nuestro ejecutable<br># Si necesitamos una librería tal cual usamos su nombre<br># TARGET_LINK_LIBRARIES(MiProyecto pthread)<br># Se pueden hacer las llamadas que se quiera a TARGET_LINK_LIBRARIES<br></pre><br><h2>Usar librería dinámica</h2><br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(MiProyecto_SRC "src/main.cpp")<br>SET(Lib_SRC "lib/lib.cpp")<br><br>ADD_LIBRARY(Lib SHARED ${Lib_SRC})<br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br>TARGET_LINK_LIBRARIES(MiProyecto ${MiProyecto_SRC})<br></pre><br><h2>Seleccionar archivos de forma masiva</h2><br>Usar SET para los archivos es muy fácil de entender, pero es posible que no queramos mantener una lista explícita del código fuente.<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>FILE(GLOB MiProyecto_SRC "src/*.cpp")<br># FILE GLOB selecciona todos los archivos que cumplan la característica y los almacena en MiProyecto_SRC<br># GLOB no es recursivo. Si lo necesitas, usa GLOB_RECURSE<br><br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br></pre><br>Esto tiene un inconveniente y es que CMake no detecta automáticamente si hay nuevos archivos que cumplen la característica, por lo que hay que forzar la recarga.<br><h2>Copiar, crear, eliminar y descargar archivos</h2><br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>FILE(GLOB MiProyecto_SRC "src/*.cpp")<br><br># Copiar archivos<br>FILE(COPY "MiArchivo.cpp" DESTINATION mi-carpeta)<br># COPY usa como destino siempre una carpeta<br># Se puede crear con FILE(MAKE_DIRECTORY mi-carpeta)<br><br># Crear archivos<br><br>FILE(WRITE "Generado.txt" "Este archivo ha sido generado por CMake\nLos archivos son: ${MiProyecto_SRC}")<br><br># Borrar archivos<br><br>FILE(REMOVE "Generado.txt")<br># No es recursivo, REMOVE_RECURSE sí lo es<br><br># Descargar archivos<br><br>FILE(DOWNLOAD http://mi-servidor.com/archivo.tar.gz archivo.tar.gz)<br># Podemos mostrar el progreso<br># FILE(DOWNLOAD http://mi-servidor.com/archivo.tar.gz archivo.tar.gz SHOW_PROGRESS)<br># Comprobar la suma MD5<br># FILE(DOWNLOAD http://mi-servidor.com/archivo.tar.gz archivo.tar.gz EXPECTED_MD5 LaSumaMD5)<br># Usar SSL<br># FILE(DOWNLOAD http://mi-servidor.com/archivo.tar.gz archivo.tar.gz TLS_VERIFY ON)<br># Guardar la información en un archivo de log<br># FILE(DOWNLOAD http://mi-servidor.com/archivo.tar.gz archivo.tar.gz LOG descarga.log)<br><br># Calcular suma de control<br><br>FILE(SHA256 archivo.tar.gz VARIABLE_CON_EL_HASH)<br><br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br></pre><br><h2>Incluir archivos de cabecera</h2><br>A veces es necesario incluir archivos de cabecera en localizaciones no estándar<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(MiProyecto_SRC<br>"src/main.cpp"<br>"src/algo_mas.cpp")<br><br>INCLUDE_DIRECTORIES("src/includes")<br># Se añade el directorio a la ruta de búsqueda del compilador de turno<br><br>ADD_EXECUTABLE(MiProyecto ${MiProyecto_SRC})<br></pre><br><h2>Plugins de CMake</h2><br>CMake es extensible a través de módulos. La instalación por defecto de CMake trae unos cuantos módulos, no obstante, podemos añadir módulos solo para nuestro proyecto. Los módulos tienen extensión .cmake. Normalmente se dejan en una carpeta llamada `cmake`.<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>LIST(APPEND CMAKE_PLUGIN_PATH "cmake")<br># Simplemente añadimos un nuevo lugar a buscar. Veremos como se usan los módulos más adelante<br><br>ADD_EXECUTABLE(MiProyecto_SRC "src/main.cpp")<br></pre><br><h2>Mostrar información y generar errores</h2><br>En ciertas situaciones querremos que no se pueda compilar el proyecto. MESSAGE es la solución.<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>MESSAGE("Información relevante")<br>MESSAGE(STATUS "Información sin relevancia")<br>MESSAGE(WARNING "Alerta, continúa la configuración y generación")<br>MESSAGE(SEND_ERROR "Error, continúa la configuración pero no generará")<br>MESSAGE(FATAL_ERROR "Error grave, detiene la configuración")<br><br>ADD_EXECUTABLE(MiProyecto "src/main.cpp")<br></pre><br><h2>Condicionales avanzados</h2><br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>## Con variables booleanas, es decir, ON/OFF, TRUE/FALSE<br><br>IF(NOMBRE_VARIABLE)<br>MESSAGE("Algo es cierto")<br>ENDIF()<br><br>IF(NOT NOMBRE_VARIABLE)<br>MESSAGE("Algo no es cierto")<br>ENDIF()<br><br># La estructura completa es algo así<br><br>IF(CONDICION)<br><br>ELSEIF(CONDICION_2)<br><br>ELSE()<br><br>ENDIF()<br><br># Se pueden aplicar operadores lógicos<br><br>IF(CONDICION AND CONDICION_2)<br><br>IF(CONDICION OR CONDICION_2)<br><br># Con números y texto<br><br>IF(VAR_1 LESS VAR_2) # VAR_1 &amp;lt; VAR_2 IF(VAR_1 GREATER VAR_2) # VAR_1 &amp;gt; VAR_2<br><br>IF(VAR_1 EQUAL VAR_2) # VAR_1 === VAR_2<br><br>IF(VAR_1 MATCHES REGEX) # Se comprueba la expresión regular<br><br># Además, CMake provee operadores para trabajar directamente con archivos, comandos y ejecutables<br><br>IF(DEFINED VAR_1) # ¿Está definida VAR_1?<br><br>IF(COMMAND CMD_1) # ¿CMD_1 es un comando de CMake?<br><br>IF(POLICY POL_1) # ¿La directiva POL_1 está activada?<br><br>IF(TARGET MiProyecto) # ¿Está definido el ejecutable MiProyecto?<br><br>IF(EXISTS src/main.cpp) # ¿Existe el archivo src/main.cpp?<br><br>IF(src/main.cpp IS_NEWER_THAN src/old/main.cpp) # ¿Es src/main.cpp más nuevo que src/old/main.cpp?<br><br>IF(IS_DIRECTORY src/includes) # ¿src/includes es un archivo o una carpeta?<br><br></pre><br><h2>Bucles</h2><br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(MiProyecto_SRC<br>"src/main.cpp"<br>"src/list.cpp"<br>"src/algomas.cpp")<br><br>FOREACH(Archivo_SRC IN MiProyecto_SRC)<br>MESSAGE(STATUS "Procesando archivo ${Archivo_SRC}")<br>ENDFOREACH()<br></pre><br><h2>Submódulos</h2><br>CMake usa un único archivo, pero quizá nos conviene repartir la configuración de CMake por varias carpetas entre zonas diferenciadas.<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ADD_SUBDIRECTORY(lib)<br>ADD_SUBDIRECTORY(src)<br><br># src y lib tienen un CMakeLists.txt cada uno<br></pre><br><h2>Librerías externas</h2><br>Una de las características más interesantes de CMake es que es capaz de encontrar librerías externas que necesite nuestro programa. Esta característica se implementa con plugins de CMake. Aquí voy a necesitar wxWidgets.<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>FIND_PACKAGE(wxWidgets)<br># El plugin debe llamarse FindPackagewxWidgets.cmake, este esta incluido en la distribución estándar de CMake<br># En grandes librerías como wxWidgets, podemos pedir solo ciertos componentes<br># FIND_PACKAGE(wxWidgets COMPONENTS core gl html base net)<br># Podemos hacer que CMake no continúe si no encuentra la librería<br># FIND_PACKAGE(wxWidgets REQUIRED)<br># Si todo va bien, tenemos las variables wxWidgets_FOUND, wxWidgets_LIBRARIES y wxWidgets_INCLUDE_DIR<br><br>INCLUDE_DIRECTORIES(${wxWidgets_INCLUDE_DIR})<br>TARGET_LINK_LIBRARIES(MiProyecto ${wxWidgets_LIBRARIES})<br></pre><br><h2>Definiciones</h2><br>Podemos añadir directivas del preprocesador de C++ con CMake<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ADD_DEFINITIONS(-DPREMIUM_SUPPORT)<br># Ahora #ifdef PREMIUM_SUPPORT en el código evaluará como cierto<br><br>ADD_EXECUTABLE(MiProyecto "src/main.cpp")<br></pre><br><h2>Dependencias</h2><br>Se pueden crear árboles de dependencias en CMake<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ADD_EXECUTABLE(MiProyecto "src/main.cpp")<br>ADD_EXECUTABLE(NecesitaMiProyecto "src/otro.cpp")<br><br>ADD_DEPENDENCY(NecesitaMiProyecto MiProyecto)<br># NecesitaMiProyecto ahora depende de MiProyecto<br></pre><br><h2>Usando Qt</h2><br>Ejemplo práctico usando CMake y Qt5 que es capaz de usar QML. Soporta archivos QRC de recursos. Requiere los plugins de Qt5.<br><pre class="lang:default decode:true">PROJECT(ProyectoQt)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(CMAKE_AUTOMOC ON)<br>SET(CMAKE_INCLUDE_CURRENT_DIR ON)<br><br>FILE(GLOB ProyectoQt_SRC "src/*.cpp")<br><br>FIND_PACKAGE(Qt5Core REQUIRED)<br>FIND_PACKAGE(Qt5Widgets REQUIRED)<br>FIND_PACKAGE(Qt5Qml REQUIRED)<br>FIND_PACKAGE(Qt5Quick REQUIRED)<br><br>qt5_add_resources(Res_SRC "src/res.qrc")<br><br>ADD_EXECUTABLE(ProyectoQt ${ProyectoQt_SRC} ${Res_SRC})<br><br>qt5_use_modules(ProyectoQt Widgets Qml Quick)<br></pre><br><h2>Usando Java</h2><br>CMake soporta Java, aunque no maneja dependencias como Maven o Gradle.<br><pre class="lang:default decode:true">PROJECT(ProyectoJava)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>FIND_PACKAGE(Java REQUIRED)<br>INCLUDE(UseJava)<br><br>SET(CMAKE_JAVA_COMPILE_FLAGS "-source" "1.6" "-target" "1.6")<br><br>FILE(GLOB JAVA_SRC "src/*.java")<br>SET(DEPS_JAR "deps/appengine.jar")<br><br>add_jar(ProyectoJava ${JAVA_SRC} INCLUDE_JARS ${DEPS_JAR} ENTRY_POINT "PuntoDeEntrada")<br><br></pre><br><h2>Usar C++11</h2><br>A partir de CMake 3.1, podemos definir el estándar de C y C++ que vamos a usar<br><pre class="lang:default decode:true">SET_PROPERTY(TARGET Ejecutable PROPERTY CXX_STANDARD 11) # Para C++11. Solo afecta al target Ejecutable<br><br>SET(CMAKE_CXX_STANDARD 11) # Para C++11. Afecta globalmente al proyecto.<br><br></pre><br><h2>Comandos personalizados, Doxygen</h2><br>En CMake podemos crear comandos personalizados. Por ejemplo, generar documentación con Doxygen<br><pre class="lang:default decode:true">PROJECT(Doxy)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ADD_CUSTOM_TARGET(doxygen doxygen ${PROJECT_SOURCE_DIR}/Doxyfile DEPENDS MiProyectoEjecutable WORKING_DIRECTORY ${PROJECT_SOURCE_DIR} COMMENT "Generando documentación" VERBATIM )<br><br># Ahora puedes usar "make doxygen"<br># Como es un TARGET cualquiera de CMake, puedes usar ADD_DEPENDENCY<br># También puedes usar el plugin FindDoxygen para más portabilidad<br></pre><br><h2>Archivos de configuración</h2><br>En Autotools es común usar un archivo con configuraciones en tiempo de compilación. Normalmente se trata de una cabecera con soporte para plantillas. En CMake se puede hacer.<br><br>config.hpp.in<br><pre class="lang:c++ decode:true">#ifndef CONFIG_HPP<br>#define CONFIG_HPP<br><br>#cmakedefine PREMIUM_SUPPORT<br><br>/* Si PREMIUM_SUPPORT está definido en CMakeLists.txt, se definirá aquí */<br><br>#define AUTHOR @AUTHOR@<br><br>/* Se definirá AUTHOR con el valor que tenga CMakeLists.txt de la variable AUTHOR */<br><br>#endif<br></pre><br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>SET(AUTHOR "\"Adrian Arroyo Calle\"")<br><br>CONFIGURE_FILE(src/config.hpp.in src/config.hpp)<br></pre><br><h2>Instalar</h2><br>CMake permite instalar también los programas<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ADD_EXECUTABLE(MiProyecto "src/main.cpp")<br><br>INSTALL(TARGETS MiProyecto DESTINATION bin/)<br># Instala un ejecutable o librería en la carpeta seleccionada. Tenemos que tener en cuenta los prefijos, que son configurables en CMake.<br># Si un programa en Linux suele ir en /usr/local/bin, debemos usar bin, pues /usr/local será añadido por CMake automáticamente<br>INSTALL(FILES ${ListaDeArchivos} DESTINATION .)<br># Archivos normales<br>INSTALL(DIRECTORY mi-carpeta DESTINATION .)<br># Copia la carpeta entera, conservando el nombre<br># Se permiten expresiones regulares y wildcards<br># INSTALL(DIRECTORY mi-carpeta DESTINATION . FILES_MATCHING PATTERN "*.png")<br><br>INSTALL(SCRIPT install-script.cmake)<br># Un archivo de CMake que se ejecutará en la instalación<br><br>INCLUDE(InstallRequiredSystemLibraries)<br># Importante si usas Windows y Visual Studio<br><br># Y con esto se puede usar 'make install'<br></pre><br><h2>CPack</h2><br>Pero `make install` es un poco incómodo. No se puede distribuir fácilmente. Aquí CMake presenta CPack, que genara instaladores. Yo soy reacio a usarlos pues son de mala calidad pero soporta:<br><ul><br> 	<li>ZIP</li><br> 	<li>TAR.GZ</li><br> 	<li>TAR.BZ2</li><br> 	<li>TZ</li><br> 	<li>STGZ - Genera un script de Bash que ejecutará la descompresión y hará la instalación</li><br> 	<li>NSIS</li><br> 	<li>DragNDrop</li><br> 	<li>PackageMaker</li><br> 	<li>OSXX11</li><br> 	<li>Bundle</li><br> 	<li>Cygwin BZ2</li><br> 	<li>DEB</li><br> 	<li>RPM</li><br></ul><br>CPack necesita que usemos el comando `cpack` en vez de `cmake`<br><pre class="lang:default decode:true">PROJECT(MiProyecto)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ADD_EXECUTABLE(MiProyecto "src/main.cpp")<br>INSTALL(TARGETS MiProyecto DESTINATION bin)<br><br>INCLUDE(CPack)<br># Esto servirá para ZIP, TAR.GZ, TAR.BZ2, STGZ y TZ<br># Para el resto deberás configurar manualmente unas cuantas variables necesarias<br># http://www.cmake.org/Wiki/CMake:CPackPackageGenerators<br></pre><br><h2>Usando ensamblador</h2><br>CMake soporta correctamente GNU ASM. Nasm requiere más trabajo.<br><pre class="lang:default decode:true">PROJECT(gnu-asm ASM C)<br>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)<br><br>ENABLE_LANGUAGE(ASM-ATT)<br><br>FILE(GLOB ASM_SOURCES "*.asm")<br>FILE(GLOB C_SOURCES "*.c")<br><br>ADD_LIBRARY(asm STATIC ${ASM_SOURCES})<br>ADD_EXECUTABLE(gnu-asm ${C_SOURCES})<br>TARGET_LINK_LIBRARIES(gnu-asm asm)<br></pre><br><h2>Algunas variables interesantes</h2><br>|CMAKE_CURRENT_SOURCE_DIR|La ruta completa a la carpeta donde se encuentra CMakeLists.txt|<br>|CMAKE_MODULE_PATH|Las rutas para buscar plugins de CMake|<br>|PROJECT_BINARY_DIR|La carpeta que se está usando para guardar los resultados de la compilación|<br>|CMAKE_INCLUDE_PATH|Las carpetas de búsqueda de cabeceras|<br>|CMAKE_VERSION|Versión de CMake|<br>|CMAKE_SYSTEM|El nombre del sistema|<br>|CMAKE_SYSTEM_NAME|El sistema operativo|<br>|CMAKE_SYSTEM_PROCESSOR|El procesador|<br>|CMAKE_GENERATOR|El generador usado en ese momento|<br>|UNIX|Si estamos en Linux, OS X, BSD o Solaris será cierto|<br>|WIN32|Si estamos en Windows|<br>|APPLE|En OS X|<br>|MINGW| Usando MinGW|<br>|MSYS| Usando MSYS|<br>|BORLAND| Usando Borland|<br>|CYGWIN| Usando Cygwin|<br>|WATCOM| Usando OpenWatcom|<br>|MSVC| Usando Visual Studio|<br>|MSVC10| Usando Visual Studio 10|<br>|CMAKE_C_COMPILER_ID| El identificador de compilador de C|<br>|CMAKE_CXX_COMPILER_ID| El identificador de compilador de C++|<br>|CMAKE_COMPILER_IS_GNUCC| El compilador de C es una variante de GNU GCC|<br>|CMAKE_COMPILER_IS_GNUCXX| El compilador de C++ es una variante de GNU G++|<br>|CMAKE_BUILD_TYPE| La configuración Debug/Release que estamos usando|<br>|CMAKE_C_COMPILER| La ruta al compilador de C|<br>|CMAKE_C_FLAGS| La configuración del compilador de C|<br>|CMAKE_C_FLAGS_DEBUG| La configuración del compilador de C solo si estamos en la configuración Debug|<br>|CMAKE_C_FLAGS_RELEASE| La configuración del compilador de C solo si estamos en la configuración Release|<br>|CMAKE_SHARED_LINKER_FLAGS| La configuración del compilador para librerías compartidas|<br>|BUILD_SHARED_LIBS| Por defecto en ADD_LIBRARY, las librerías son compartidas. Podemos cambiar esto|<br><br>Muchas más en la <a href="http://www.cmake.org/Wiki/CMake_Useful_Variables">wiki de CMake</a><br><h2>RPath</h2><br>El RPath es importante en los sistemas UNIX. Se trata de cargar librerías dinámicas que no están en directorios estándar.<br><pre class="lang:default decode:true">SET(CMAKE_SKIP_BUILD_RPATH FALSE)<br>SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)<br>SET(CMAKE_INSTALL_RPATH "$ORIGIN")<br>SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)<br></pre><br>Esto hará que los ejecutables construidos en UNIX puedan cargar librerías desde la carpeta donde se encuentran. Al estilo Windows.