En muchas aplicaciones es necesario leer datos de teclado. Si bien esto podría considerarse sencillo en lenguaje como <strong>Python</strong> o <strong>Ruby</strong>, lo cierto es que sí se quiere hacer bien es complicado. Funciones como <strong>scanf</strong> de C son consideradas inseguras y en Java, hasta la llegada de la clase <strong>java.util.</strong><strong>Scanner</strong> era un dolor de cabeza. En Rust no es distinto, es por ello que muchos tutoriales de Rust obvian esta parte. No obstante, leer de teclado no es tan difícil, como veremos a continuación.<br><br><a href="https://files.adrianistan.eu/Teclado.jpg"><img class="aligncenter size-full wp-image-1034" src="https://files.adrianistan.eu/Teclado.jpg" alt="" width="558" height="412" /></a><br><h2>read_line</h2><br>El método principal para leer de teclado es <strong>read_line</strong>, que nos lee una línea como <strong>String</strong>. Para acceder a read_line primero necesitamos tener on objeto <strong>stdin</strong>. La manera más fácil de hacerlo es usar el módulo <strong>std::io</strong>.<br><br>El procedimiento es el siguiente, en primer lugar creamos una variable de tipo String vacía y mutable donde se va a alojar el resultado, posteriormente leemos y tratamos el resultado.<br><br><pre class="lang:rust decode:true"><br>use std::io;<br><br>fn main() {<br>    println!(&quot;Dime tu nombre: &quot;);<br>    let mut input = String::new();<br>    io::stdin().read_line(&amp;mut input);<br>    println!(&quot;Tu nombre es {}&quot;,input.trim());<br>}<br></pre><br><br>Como vemos, al leer la línea también se nos guarda el salto de línea. Si queremos quitarlo podemos usar <strong>trim</strong>.<br><br>Este código sin embargo generará una <strong>advertencia</strong> por el compilador y es que read_line genera devuelve un valor, concretamente un <strong>Result</strong>, que como vimos, sirven para <a href="https://blog.adrianistan.eu/2017/07/03/gestion-errores-rust-option-result/">el manejo de errores en Rust</a>. Si no queremos tratar este Result con especial interés, podemos usar <strong>ok</strong> y opcionalmente especificar un mensaje de error con <strong>expect</strong>.<br><br><pre class="lang:rust decode:true"><br>use std::io;<br><br>fn main() {<br>    println!(&quot;Dime tu nombre: &quot;);<br>    let mut input = String::new();<br>    io::stdin().read_line(&amp;mut input).ok().expect(&quot;Error al leer de teclado&quot;);<br>    println!(&quot;Tu nombre es {}&quot;,input.trim());<br>}<br></pre><br><br>Si quieres tratar el error mejor puedes, pero read_line no suele fallar.<br><h2>Leyendo enteros</h2><br>Hasta aquí todo sencillo, porque leíamos <strong>String</strong>, en lo que entra todo lo que el usuario puede meter. Pero, ¿y si queremos leer un número de teclado? La cosa se complica. Normalmente se lee de teclado como <strong>String</strong> y luego se intenta pasar a número. Veamos como.<br><br><pre class="lang:rust decode:true"><br>use std::io;<br>use std::str::FromStr;<br><br>fn main() {<br>    println!(&quot;Dime tu edad: &quot;);<br>    let mut input = String::new();<br>    io::stdin().read_line(&amp;mut input).ok().expect(&quot;Error al leer de teclado&quot;);<br>    let edad: u32 = u32::from_str(&amp;input.trim()).unwrap();<br>    let frase = if edad &gt;= 18 {<br>        &quot;Mayor de edad&quot;<br>    }else{<br>        &quot;Menor de edad&quot;<br>    };<br>    println!(&quot;{}&quot;,frase);<br>}<br></pre><br><br>Como vemos, hay que importar <strong>std::str::FromStr</strong> para tener disponible las operaciones <strong>from_str</strong> en los tipos elementales. También se observa que hemos hecho un <strong>unwrap</strong>, porque from_str devuelve un Result. Este error sin embargo conviene que lo tratemos con más cuidado, pues es bastante probable que salte.<br><h2>Un ejemplo ideal</h2><br>En este código vamos a ver como pedir un entero, asegurándonos de que el usuario realmente introduce un entero e insistiendo hasta que finalmente introduce un entero válido.<br><br><pre class="lang:rust decode:true"><br>use std::io;<br>use std::io::Write;<br>use std::str::FromStr;<br>use std::num::ParseIntError;<br><br>fn read_input() -&gt; Result&lt;u32,ParseIntError&gt; {<br>    print!(&quot;Dime tu edad: &quot;);<br>    io::stdout().flush().ok();<br>    let mut input = String::new();<br>    io::stdin().read_line(&amp;mut input).ok().expect(&quot;Error al leer de teclado&quot;);<br>    let input = input.trim();<br>    let edad: u32 = u32::from_str(&amp;input)?;<br>    Ok(edad)<br>}<br><br>fn main() {<br>    let edad;<br>    loop {<br>        if let Ok(e) = read_input(){<br>            edad = e;<br>            break;<br>        }else{<br>            println!(&quot;Introduce un número, por favor&quot;);<br>        }<br>    }<br>    let frase = if edad &gt;= 18 {<br>        &quot;Mayor de edad&quot;<br>    }else{<br>        &quot;Menor de edad&quot;<br>    };<br>    println!(&quot;{}&quot;,frase);<br>}<br></pre><br><br>He decidido separar la parte de pedir el número a otra función que devuelve Result para así poder usar el operador <strong>?</strong>. También he usado <strong>print!</strong> y <strong>io::stdout().flush()</strong> en vez de <strong>println!</strong> para que tanto el mensaje como la entrada se realice en la misma línea y quede más bonito.<br><br><a href="https://files.adrianistan.eu/RustInputTest.png"><img class="aligncenter size-full wp-image-1033" src="https://files.adrianistan.eu/RustInputTest.png" alt="" width="586" height="136" /></a><br><br>&nbsp;