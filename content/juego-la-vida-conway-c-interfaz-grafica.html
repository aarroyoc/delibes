Hoy os traigo un proyecto que realizamos <a href="https://github.com/DanielBV">Daniel Bazaco</a> y yo. Se trata del clásico de juego de la vida, esta vez hecho en C# con<a href="http://dot.net/core"> .NET Core</a> y <a href="https://github.com/AvaloniaUI/Avalonia">Avalonia</a> como librería gráfica. Funciona tanto en Windows como en GNU/Linux. El programa tiene la peculiaridad de que tiene implementados dos algoritmos totalmente distintos para el juego de la vida:<br><ul><br> 	<li>El clásico algoritmo de la matriz infinita.</li><br> 	<li>Un algoritmo usando Quadtrees y tablas de dispersión optimizadas, que permite tener patrones precalculados.</li><br></ul><br>La velocidad de este segundo algoritmo es muy superior a la del primero, aunque he de confesar que este segundo algoritmo no resulta evidente y tiene una desventaja en el modo gráfico. Este segundo algoritmo avanza <em>a trompicones</em>, por lo que no es posible realizar una animación gráfica idónea, a no ser que lo modifiquemos ligeramente. Este tercer algoritmo que es una modificación del segundo, es más lento, pero permite ser mostrado por la pantalla.<br><br>El programa admite ficheros tanto en formato estándar RLE como un formato propio, que hemos llamado Vaca. Puedes pasarte por <a href="http://www.conwaylife.com/wiki/Main_Page">la wiki del juego de la vida</a> y probar los ficheros RLE que encuentres. No obstante, hay que tener cuidado, pues algunos ficheros RLE no son del juego de la vida, sino de otros juegos con normas ligeramente modificadas.<br><h2>¿En qué consiste el Juego de la Vida?</h2><br>El juego de la vida es un autómata celular de dos dimensiones. También se le ha categorizado como juego para cero jugadores.<br><br>El juego tiene unas normas sencillas. Cada celda puede estar viva o muerta. En la siguiente evolución, las celdas pueden pasar a vivas o muertas siguiendo este esquema:<br><ul><br> 	<li>Una célula muerta con exactamente 3 células vecinas vivas "nace" (es decir, al turno siguiente estará viva).</li><br> 	<li>Una célula viva con 2 o 3 células vecinas vivas sigue viva, en otro caso muere o permanece muerta (por "soledad" o "superpoblación").</li><br></ul><br>Unas condiciones de partida determinadas podrán desencaminar comportamientos complejos y emergentes muy interesantes como las pistolas de gliders.<br><br>[video width="1364" height="704" mp4="https://files.adrianistan.eu/GosperGliderGun.mp4" webm="https://files.adrianistan.eu/GosperGliderGun.webm"][/video]<br><h2>Uso</h2><br><a href="https://files.adrianistan.eu/ConwayStartScreen.png"><img class="wp-image-1283 size-large" src="https://files.adrianistan.eu/ConwayStartScreen-1024x576.png" alt="" width="840" height="473" /></a> Pantalla de inicio de Conway<br><br>Desde aquí podemos dar a <em>Nuevo patrón</em> o <em>Cargar patrón</em>. Si le damos a Nuevo Patrón tendremos una matriz vacía y limpia. Podemos hacer click con el ratón para ir activando/desactivando las casillas. Puedes usar las teclas W, A, S y D o las flechas en pantalla para moverte por el universo infinito de Conway.<br><br><a href="https://files.adrianistan.eu/ConwayFreePattern.png"><img class="aligncenter size-large wp-image-1284" src="https://files.adrianistan.eu/ConwayFreePattern-1024x576.png" alt="" width="840" height="473" /></a>Una vez lo tengamos podemos guardarlo para no tener que volver a dibujarlo. Otra opción es cargar un patrón de la lista. Este programa admite formato RLE y Vaca, pero solo guarda archivos en formato Vaca.<br><br>Para ejecutar el juego de la vida hay tres botones importantes. El primero es <em>Ejecutar</em>, que ejecuta el juego de la vida indefinidamente. Se para cuando pulsamos <em>Parar</em> (el mismo botón).<br><br>El otro es <em>Siguiente</em>, que nos permite avanzar de iteración en iteración manualmente, muy interesante para observar al detalle ciertos patrones. Por otro lado tenemos <em>Iterar N veces</em>, que permite iterar N veces y que sirve para pruebas de rendimiento. Hay que tener en cuenta que tanto <em>Siguiente</em> como <em>Iterar N veces</em> funcionan un poco distinto con el algoritmo Quadtree (el activado por defecto), ya que este algoritmo hace varias evoluciones de golpe, para ser todavía más rápido. La parte mala es que no es posible ver en detalle cada algoritmo.<br><h5>Algoritmo Matriz</h5><br>[video width="1008" height="486" mp4="https://files.adrianistan.eu/AlgoritmoMatriz.mp4" webm="https://files.adrianistan.eu/AlgoritmoMatriz.webm"][/video]<br><h5>Algoritmo Quadtree</h5><br>[video width="1008" height="486" mp4="https://files.adrianistan.eu/AlgoritmoQuadtree.mp4" webm="https://files.adrianistan.eu/AlgoritmoQuadtree.webm"][/video]<br><h2>Línea de comandos</h2><br>Es posible ejecutar el juego de la vida en línea de comandos. Este modo permite cargar un archivo Vaca o RLE y ejecutarlo N iteraciones. Al finalizar se muestran estadísticas y se permite guardar el resultado o mostrarlo por pantalla con caracteres ASCII.<br><br>Hay dos parámetros, <strong>-i</strong> para indicar el fichero de entrada y <strong>-n</strong> para indicar las iteraciones a calcular.<br><h2><a href="https://files.adrianistan.eu/ConwayCli.png"><img class="aligncenter size-large wp-image-1290" src="https://files.adrianistan.eu/ConwayCli-1024x576.png" alt="" width="840" height="473" /></a>Algoritmo Quadtree</h2><br>¿Cómo funciona el algoritmo quadtree que tanto mejora el rendimiento del juego de la vida? Siendo sinceros, no es algoritmo sencillo o evidente. Su nombre más correcto es algoritmo<strong> Hashlife</strong> y fue descrito por Bill Gosper en los laboratorios de investigación de Xerox Palo Alto.<br><br>La idea básica es que muchas veces en el juego de la vida nos encontramos con patrones que se van repitiendo periódicamente y grandes zonas vacías.<br><br>Para ello recurre a un almacén de cuadrantes. Y es que ahora el universo ya no es una matriz infinita, sino un cuadrante. Y cada cuadrante tiene cuatro cuadrantes hijos (noroeste, noreste, suroeste y sureste), así hasta llegar al cuadrante mínimo ya no tiene hijos sino que es una celda viva o muerta. Esto evidentemente pone limitaciones al tamaño del universo, que será siempre potencia de dos.<br><br>El almacén es una tabla hash, pero no una corriente tipo HashMap de Java o Dictionary de C# sino que toma 4 elementos como índice, cuatro subcuadrantes. Si existe un elemento cuyos cuatro subcuadrantes son <em>iguales</em> (no se comprueba la igualdad exactamente, sería muy lento), se devuelve la siguiente iteración del cuadrante del almacén que cumple esos requisitos. De este modo no hace falta calcular los cuadrantes nada más que la primera vez que el programa se encontró con ellos.<br><br>Este sistema consume más memoria, pero mejora de forma sustancial la velocidad de ejecución. El algoritmo luego tiene bastantes más detalles (<a href="http://diasyfrases.blogspot.com.es/2015/11/dios-esta-en-los-detalles.html">el diablo está en los detalles</a>), pero esa es la idea principal, no calcular los cuadrantes más que una sola vez.<br><h2>Descargar Conway</h2><br>Podéis descargar Conway desde GitHub y compilarlo en Windows y GNU/Linux (Mac no está probado pero en principio funcionaría), con .NET Core 2.0 instalado.<br><p style="text-align: center;"><a href="https://github.com/aarroyoc/Conway">Conway en GitHub</a></p><br>&nbsp;<br><br>&nbsp;