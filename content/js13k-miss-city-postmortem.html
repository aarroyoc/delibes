Desde el 13 de agosto hasta el 13 de septiembre ha tenido lugar la competición <a href="http://js13kgames.com">js13kGames</a> 2015. El objetivo es construir un juego en HTML5, en el plazo de un mes o menos que no ocupe más de <strong>13kb</strong>. EL fichero que no debe superar los 13kb debe ser un fichero ZIP con compresión estándar que tenga un fichero <code>index.html</code> desde el cual arrancará el juego y todo lo necesario para su funcionamiento estará también en el fichero ZIP. JavaScript, CSS, imágenes, sonido, fuentes, etc deberán estar en el fichero ZIP que no supere los 13kb. Está explicitamente prohibido cargar algún recurso del exterior como Google Web Fonts, CDNs de JavaScript, imágenes en otro servidor, etc. Además hay un tema para los juegos, que fue anunciado el 13 de agosto. El tema ha sido <strong>Reversed</strong>.<br><br><img class="alignnone size-full wp-image-54" src="https://files.adrianistan.eu/js13k.png" alt="js13k" width="151" height="151" /><br><h2 id="misscity">MissCity</h2><br><img class="alignnone size-full wp-image-74" src="https://files.adrianistan.eu/MissCityGameplay.png" alt="MissCityGameplay" width="800" height="600" /><br><br>El juego que he presentado se llama <strong>MissCity</strong>. El nombre viene de darle la vuelta a Sim de SimCity. Mis no existe, pero Miss sí, y es perdido. Así MissCity es <em>ciudad perdida</em>.<br><blockquote><em>Euralia es la ciudad perfecta. Nuestra compañía desea construir un centro comercial en un solar abandonado pero el actual alcalde desea constuir una biblioteca. Dentro de poco son elecciones. ¡Debemos ganar las elecciones! Para ello puedes usar nuestro dron y repartir diversos tipos de ataques publicitarios a la población</em></blockquote><br>Los controles son:<br><ul><br> 	<li>WASD para desplazarse (si estamos en móvil o tablet, se usa la inclinación del dispositivo)</li><br> 	<li>VBNM para los 4 diferentes tipos de ataque (si estamos en un dispositivo táctil, aparecen cuatro botones en pantalla que realizan el mismo efecto)</li><br></ul><br>Ganamos:<br><ul><br> 	<li>Si conseguimos suficientes votos entre el electorado</li><br></ul><br>Perdemos:<br><ul><br> 	<li>Si pasan dos minutos</li><br> 	<li>Si nos quedamos sin dinero (cada ataque publicitario cuesta una cantidad de dinero sin especificar)</li><br></ul><br><img class="alignnone size-large wp-image-75" src="https://files.adrianistan.eu/MissCityOpera-1024x578.png" alt="MissCityOpera" width="840" height="474" /><br><br>Vamos a ver el postmortem en profundidad<br><h2 id="cosasquefueronbien">Cosas que fueron bien</h2><br><h3 id="pathfinding">PathFinding</h3><br>Los habitantes de Euralia son inteligentes, no van de una casilla a otra porque sí sino que tienen una ruta que realizar. El origen y el destino sí se calculan aleatoriamente, pero la ruta no, se usa un algoritmo de <em>pathfinding</em>. Debía encontrar una librería sencilla, pequeña, pero que implementase el algoritmo de manera limpia. Finalmente elegí <a href="http://easystarjs.com">EasyStar.js</a> que es <strong>asíncrona</strong>, sin dependencias y entre sus características asegura que es <strong>pequeña</strong> (~5kb) lo cual comprimido en ZIP resulta menos de lo que esperaba. Usa licencia MIT así que perfecto. El único inconveniente que presenta es que la rejilla que usa es bidimensional y yo definí la ciudad y el sistema de renderizado con un array unidimensional que voy cortando al procesarlo. Así que el juego tiene que transformar el array unidimensional en otro bidimensional para que EasyStar lo procese correctamente. Al obtener los resultados, es necesario volver a transformarlos.<br><h3 id="recursosgrficos">Recursos gráficos</h3><br>Creía que mi juego iba a tener peores gráficos, sinceramente. Las imágenes en formato GIF ocupaban menos de lo que esperaba y pude incluir bastantes detalles. Al principio no usé imágenes, tiré de colores en CSS. Renderizar toda la ciudad fue muy sencillo. Esta no es la versión final por supuesto, pero no es muy diferente.<br><br><pre class="lang:js decode:true"><br>// city es el array unidimensional donde defino el mapa de la ciudad<br><br>var draw=city.map(function(val){<br>    switch(val){<br>      case 0: return &quot;rgba(91,196,124,1)&quot;;<br>      case 1: return &quot;rgb(76, 77, 76)&quot;;<br>      case 2: return &quot;rgb(84, 230, 54)&quot;;<br>      case 3: return &quot;rgb(37, 88, 219)&quot;;<br>      case 4: return &quot;rgb(223, 155, 23)&quot;;<br>    }<br>  });<br>  var x=0,y=0;<br>  draw.forEach(function(cell){<br>	ctx.fillStyle=cell;<br>	ctx.fillRect(x,y,box,box);<br>	x+=box;<br>	if((x+box)&gt;id(&quot;a&quot;).width){<br>	  x=0;<br>	  y+=box;<br>	}<br>  });<br></pre><br><h3 id="debugenfirefoxparaandroid">Debug en Firefox para Android</h3><br>Me lo esperaba peor y realmente con WebIDE, el cable USB y ADB es muy sencillo ver la consola de JavaScript de Firefox para Android en tu ordenador.<br><h2 id="problemas">Problemas</h2><br><img class="alignnone size-large wp-image-73" src="https://files.adrianistan.eu/MissCityFirefox-1024x578.png" alt="MissCityFirefox" width="840" height="474" /><br><h2 id="dichosasapisdepantallayorientacin">Dichosas APIs de pantalla y orientación</h2><br>En HTML5 siempre me torturo con los aspect ratio y demás temas relacionados con la pantalla. En HTML5 hay tantas pantallas diferentes que simplemente no sé por donde empezar. El método que he usado en este juego es diferente al usado en otras ocasiones y daría para una entrada de blog suelta. Pero también me gustaría decir que las APIs de gestión de pantalla (saber si estás en modo <em>landscape</em> o <em>portrait</em>) no funcionan entre navegadores todavía. Incluso tienen nombres incompatibles que surgen de distintas versiones del estándar. Es una cosa que las aplicaciones nativas de móviles saben hacer desde el día 1.<br><h2 id="easyzip">EasyZIP</h2><br>En MissCity he usado <a href="http://gulpjs.com">Gulp</a> como herramienta que se encarga de la automatización de todo (ya sabes <a href="http://blog.adrianistan.eu/2015/08/04/haz-scripts">¡haz scripts!</a>). Usé <strong>EasyZIP</strong> para generar el fichero ZIP y posteriormente comprobar que su tamaño seguía siendo inferior a los 13kb. Mi sorpresa vino cuando al subir el fichero ZIP provoqué un error en el servidor de js13kgames. Tuve que contactar con el administrador, hubo que borrar archivos que se habían extraído correctamente en el servidor aunque hubiese devuelto un error. La solución fue comprimirlo manualmente con <strong>File Roller</strong> y el tamaño del fichero aumentó (sin pasar los 13kb).<br><h2 id="apidegestindeteclado">API de gestión de teclado</h2><br>Firefox recomienda usar <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">KeyboardEvent.key</a> para leer el teclado y marca como obsoleta la manera antigua, que era <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">KeyboardEvent.keyCode</a>. Leyendo MDN uno piensa que usando KeyboardEvent.key es la solución sin más. Y efectivamente en Firefox funciona bien, pero en Chrome y Opera no. Y pudiendo usar <code>keyCode</code>, quién va a usar <code>key</code>. <code>keyCode</code> será obsoleto pero funciona en todos los navegadores. Finalmente implementé el teclado usando <code>key</code> y <code>keyCode</code> si no soportan <code>key</code>.<br><h2 id="juega">Juega</h2><br>Si has leído hasta aquí, es un buen momento para jugar a MissCity. Hay un premio por compartir en redes sociales, si quieres ayudarme ya sabes.<br><div style="text-align: center;"><a href="http://js13kgames.com/entries/miss-city">MissCity</a></div><br>Código fuente: <a href="http://github.com/AdrianArroyoCalle/miss-city">http://github.com/AdrianArroyoCalle/miss-city</a>