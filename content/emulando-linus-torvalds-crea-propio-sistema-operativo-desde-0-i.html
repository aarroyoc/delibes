<blockquote><em>Este artículo lo escribí para el blog en español <a href="http://blog.desdelinux.net">DesdeLinux</a> el 27 de diciembre de 2013 y ahora lo dejo aquí, en mi blog personal. El artículo está tal cual, sin ninguna modificación desde aquella fecha.</em></blockquote><br>En esta serie vamos a emular a <strong>Linus Torvalds</strong>, vamos a crear nuestro sistema operativo desde 0. En este primer episodio vamos a ver el arranque y pondremos un texto en pantalla desde nuestro kernel.<br><br><img class="alignnone size-full wp-image-65" src="https://files.adrianistan.eu/LinusTorvalds.jpg" alt="LinusTorvalds" width="800" height="789" /><br><br>En mi caso el sistema operativo se llama <strong>NextDivel</strong>. La primera decisión que debemos hacer nada más plantearnos el sistema operativo es ¿cuál va a ser el bootloader?<br><br>Aquí existen múltiples variantes, e incluso podríamos crear uno nosotros; sin embargo, en este tutorial voy a usar GRUB, porque la mayoría conoce más o menos algo de él. Creamos una carpeta que será el root de nuestro sistema operativo y allí creamos la carpeta /boot/grub<br><pre><code>mkdir nextroot &amp;&amp; cd nextroot<br> mkdir -p boot/grub </code></pre><br>Allí creamos el fichero grub.cfg de la siguiente manera:<br><br><pre class="lang:default decode:true"><br>menuentry &quot;NextDivel&quot; {<br>	echo &quot;Booting NextDivel&quot;<br>	multiboot /next/START.ELF<br>	boot<br>}<br></pre><br><br>En este fichero hemos visto como <strong>GRUB</strong> cargará nuestro kernel, en este caso, en /next/START.ELF. Ahora debemos crear nuestro kernel.<br><br>Para ello necesitaremos el <strong>GCC</strong> y <strong>GAS</strong> (el ensamblador del proyecto <strong>GNU</strong>, suele venir con el gcc). Así pues vamos a crear el kernel.<br><br>Primero hacemos un archivo llamado kernel.asm. Este archivo contendrá el punto de inicio de nuestro kernel y además definirá el multiboot (una característica de algunos bootloaders como <strong>GRUB</strong>). El contenido de kernel.asm será:<br><br><pre class="lang:default decode:true"><br>.text<br>.globl start<br>start:<br>jmp multiboot_entry<br>.align 4<br>multiboot_header:<br>.long 0x1BADB002<br>.long 0x00000003<br>.long -(0x1BADB002+0x00000003)<br>multiboot_entry:<br>movl $(stack + 0x4000), %esp<br>call NextKernel_Main<br>loop: hlt<br>jmp loop<br>.section ".bss"<br>.comm stack,0x4000<br></pre><br><br>Todo lo relacionando con multiboot es simplemente seguir la especificación nada más. Todo empezará en start, llamará a multiboot_entry, habremos definido el multiboot header en los primeros 4k y lo pondremos (con movl).<br><br>Más tarde llamamos a NextKernel_Main que es nuestra función en C del kernel. En el loop hacemos un halt para parar el ordenador. Esto se compila con:<br><pre><code>as -o kernel.o -c kernel.asm </code></pre><br>Ahora vamos a entrar a programar en C. Pensarás que ahora todo es pan comido, ponemos un <strong>printf</strong> en <strong>main</strong> y ya está, lo hemos hecho.<br><br>Pues no, ya que printf y main son funciones que define el sistema operativo, ¡pero nosotros lo estamos creando! Solo podremos usar las funciones que nosotros mismos definamos.<br><br>En capítulos posteriores hablaré de como poner nuestra propia libraría del C (glibc, bionic, newlibc) pero tiempo al tiempo. Hemos hablado que queremos poner texto en pantalla, bueno veremos como lo hacemos.<br><br>Hay dos opciones, una es llamar a la <strong>BIOS</strong> y otra es manejar la memoria de la pantalla directamente. Vamos a hacer esto último pues es más claro desde C y además nos permitirá hacerlo cuando entremos en modo protegido.<br><br>Creamos un fichero llamado NextKernel_Main.c con el siguiente contenido:<br><br><pre class="lang:c++ decode:true"><br>int NextKernel_Main(/*struct multiboot *mboot_ptr*/)<br>{<br>	const char* str=&quot;NextDivel says Hello World&quot;, *ch;<br>	unsigned short* vidmem=(unsigned short*)0xb8000;<br>	unsigned i;<br>	for(ch=str, i=0;*ch;ch++, i++)<br>		vidmem[i]=(unsigned char) *ch | 0x0700;<br><br>	return 0;<br>}<br></pre><br><br>Con esto manipulamos directamente la memoria <strong>VGA</strong> y caracter a caracter lo vamos escribiendo. Compilamos desactivando la stdlib:<br><pre><code>gcc -o NextKernel_Main.o -c NextKernel_Main.c -nostdlib -fPIC -ffreestanding </code></pre><br>Si has llegado hasta aquí querrás probar ya tu nuevo y flamante sistema operativo, pero todavía no hemos terminado. Necesitamos un pequeño fichero que diga al compilador en que posición del archivo dejar cada sección. Esto se hace con un linker script. Creamos link.ld:<br><br><pre class="lang:default decode:true"><br>ENTRY(start)<br>SECTIONS<br>{<br>	. = 0x00100000;<br><br>	.multiboot_header :<br>	{<br>		*(.multiboot_header)<br>	}<br>    .text :<br>    {<br>        code = .; _code = .; __code = .;<br>        *(.text)<br>        . = ALIGN(4096);<br>    }<br><br>    .data :<br>    {<br>        data = .; _data = .; __data = .;<br>        *(.data)<br>        *(.rodata)<br>        . = ALIGN(4096);<br>    }<br><br>    .bss :<br>    {<br>        bss = .; _bss = .; __bss = .;<br>        *(.bss)<br>        . = ALIGN(4096);<br>    }<br><br>    end = .; _end = .; __end = .;<br>}<br></pre><br><br>Con esto definimos la posición de cada sección y el punto de entrada, start, que hemos definido en kernel.asm. Ahora ya podemos unir todo este mejunje:<br><pre><code>gcc -o START.ELF kernel.o NextKernel_Main.o -Tlink.ld -nostdlib -fPIC -ffreestanding -lgcc </code></pre><br>Ahora copiamos START.ELF al /next dentro de nuestra carpeta que simula el root de nuestro sistema operativo. Nos dirigimos a la carpeta root de nuestro sistema operativo nuevo con la consola y verificamos que hay dos archivos: uno /boot/grub/grub.cfg y otro /next/START.ELF.<br><br>Vamos al directorio superior y llamamos a una utilidad de creación ISOs con GRUB llamada <em>grub-mkrescue</em><br><pre><code>grub-mkrescue -o nextdivel.iso nextroot </code></pre><br>Una vez hayamos hecho esto tendremos una ISO. Esta ISO puede abrirse en ordenadores <strong>x86</strong> (64 bits también) y máquinas virtuales. Para probarlo, voy a usar <strong>QEMU</strong>. Llamamos a QEMU desde la línea de comandos:<br><pre><code>qemu-system-i386 nextdivel.iso </code></pre><br>Arrancará <strong>SeaBIOS</strong> y más tarde tendremos GRUB. Después si todo va correcto veremos nuestra frase. Pensarás que esto es difícil, te respondo, sí lo es.<br><br>Realmente crear un sistema operativo es difícil y eso que este de aquí no hace nada útil. En próximos capítulos veremos como manejar colores en la pantalla, reservar memoria y si puedo, como obtener datos del teclado.<br><br>Si alguien no quiere copiar todo lo que hay aquí, tengo un repositorio en GitHub (más elaborado) con el sistema operativo <strong>NextDivel</strong>. Si quieres compilar NextDivel solo tienes que tener git y cmake:<br><br><pre class="lang:default decode:true"><br>git clone https://github.com/AdrianArroyoCalle/next-divel <br>cd next-divel <br>mkdir build &amp;&amp; cd build <br>cmake .. <br>make <br>make DESTDIR=next install <br>chmod +x iso.sh <br>./iso.sh <br>qemu-system-i386 nextdivel.iso<br></pre><br><br>Os animo a colaborar en NextDivel si tienes tiempo y ganas de crear un sistema operativo. Quizá incluso superior a Linux… el tiempo lo dirá.