Hoy vengo a hablar de <a href="http://couchdb.apache.org">CouchDB</a>, una base de datos que no es precisamente nueva ni es precisamente famosa, pero que en mi opinión tiene unas características únicas.<br><br><a href="https://files.adrianistan.eu/couchDB.png"><img class="aligncenter size-full wp-image-823" src="https://files.adrianistan.eu/couchDB.png" alt="" width="800" height="600" /></a><br><br>En primer lugar vayamos con la teoría. Apache CouchDB es una base de datos NoSQL que almacena documentos JSON y tiene una potente API REST. Está programada en Erlang y es un proyecto Apache desde 2008. Usa JavaScript para la operativa interna. Visto este resumen uno podría pensar que estamos ante un clon de <a href="http://mongodb.com">MongoDB</a> (a pesar de que CouchDB es mucho más antigua) pero no. CouchDB parte de una filosofía distinta, ser la base de datos de la era de la web y se nota mucho como toma decisiones que la alejan de las bases de datos relacionales y de las bases de datos NoSQL más populares.<br><h2>La API REST</h2><br>Una parte fundamental de CouchDB es la API REST, que es la única API que dispone. CouchDB de este modo puede funcionar de dos formas:<br><ul><br> 	<li>En un modelo tradicional, con una servidor que haga las peticiones. Este servidor puede estar programado en cualquier cosa (Java, PHP, Node.js, C#, Python, Ruby, Elixir,...) y que no es muy distinto a como nos conectamos por ejemplo a MongoDB o a MySQL.</li><br> 	<li>En un modelo innovador donde la base de datos está conectada directamente a Internet y no hace falta ningún servidor que gestione la comunicación. Este modelo da lugar a las CouchApps, aplicaciones CRUD pero sin servidor propiamente dicho, solo base de datos y un alojamiento estático de archivos. A través de JavaScript en el lado del cliente podemos obtener la información, conectándose directamente el navegador con la base de datos.</li><br></ul><br>La posibilidad de hacer esto último es una de las mayores ventajas de CouchDB en mi opinión, ya que según el proyecto, esto puede ahorrar mucho tiempo y prevenir muchos posibles bugs en operaciones tontas. El desafío de este artículo será crear una aplicación en CouchDB que pudiera simular a una aplicación CRUD cualquiera. Esta aplicación reducirá costes respecto a una tradicional ya que eliminamos la parte del servidor, solo mantenemos la base de datos (y un proxy).<br><h2>Instalando CouchDB</h2><br>CouchDB está en casi todas las distros Linux. Es posible que no esté disponible la última versión, pero para lo que vamos a hacer no es necesario. Yo voy a usar CouchDB 1.4, una versión bastante antigua, pero es la que tiene Debian en sus repos. En Ubuntu tenéis CouchDB 1.6 y en la página oficial está la versión 2.0<br><h2>Creando una base de datos</h2><br>En CouchDB las bases de datos son cubos sin fondo. Podemos arrojar documentos JSON sin control.<br><br>Vamos a usar la API REST para crear la base de datos "supermercado".<br><br><pre class="lang:default decode:true"><br>curl -X PUT http://127.0.0.1:5984/supermercado<br></pre><br><br>Podemos comprobar que la base de datos ha sido creada con GET<br><br><pre class="lang:default decode:true"><br>curl -X GET http://127.0.0.1:5984/supermercado<br></pre><br><br>En CouchDB ciertas rutas que comienzan por barra baja son especiales. Por ejemplo si queremos pedir una lista de todas las bases de datos podemos hacer GET a _all_dbs.<br><br><pre class="lang:default decode:true"><br>curl -X GET http://127.0.0.1:5984/_all_dbs<br></pre><br><br><a href="https://files.adrianistan.eu/CouchDB-AllDbs.png"><img class="aligncenter size-full wp-image-824" src="https://files.adrianistan.eu/CouchDB-AllDbs.png" alt="" width="651" height="160" /></a><br><br>Para borrar la base de datos usaríamos DELETE<br><br><pre class="lang:default decode:true"><br>curl -X DELETE http://127.0.0.1:5984/supermercado<br></pre><br><br>Pero no lo hagas todavía. Si has pensado en lo que hemos hecho te estarás alarmando. Hemos creado una base de datos, por HTTP y no se nos ha pedido ninguna autorización ni nada. Por defecto CouchDB es inseguro ya que arranca en un modo llamado <em>Admin Party</em>, pero rápidamente veremos que si vamos a exponer CouchDB a Internet vamos a necesitar seguridad, y CouchDB la trae. Pero antes, vamos a trabajar con documentos.<br><h2>Insertando un documento</h2><br>Insertar un documento es tan fácil como tirar documentos a la papelera (bueno, quizá no tan fácil).<br><br><pre class="lang:default decode:true"><br>curl -X PUT http://127.0.0.1:5984/supermercado/UUID -d '{&quot;nombre&quot;: &quot;Manzana&quot;, &quot;tipo&quot; : &quot;fruta&quot;, &quot;precio&quot; : 5}'<br></pre><br><br>Donde UUID es un UUID. Si no tienes un UUID a mano, CouchDB te ofrece uno a través de _uuids.<br><br><pre class="lang:default decode:true"><br>curl -X GET http://127.0.0.1:5984/_uuids?count=10<br></pre><br><br>En realidad no es estrictamente necesario poner un UUID, pero es la convención habitual. Una vez hagamos el PUT obtendremos de respuesta un JSON con tres campos muy importantes. Ok para decirnos si la operación fue bien o no, _id, con el ID del documento (es el UUID de antes) y el _rev. Este último campo, nos indica con que versión del documento hemos interactuado, en nuestro caso, era la primera así que hay un 1 delante. Esto es muy importante en CouchDB y tiene que ver con como gestiona la concurrencia. CouchDB es eventualmente consistente. Quiere decir que en una situación de escritura y lectura simultáneas, la base de datos no se bloquea sino que puede mandar distintas versione de los documentos. Cuando editemos un documentos tendremos que indicar  sobre que versión hacemos la modificación, y si algún otro cliente se nos adelantó y modificó el documento antes, tendremos que basarnos en su revisión para que sea aceptada por la base de datos. Hay que tener que CouchDB no es un sistema de control de versiones, las revisiones antiguas pueden desaparecer sin previo aviso. Esta característica, la de ser eventualmente consistente, también facilita mucho su desempeño en clústeres, pero no vamos a entrar en ello. De momento hay que saber que en CouchDB, a diferencia de otras bases de datos, para actualizar un documento necesitaremos su ID y su revisión.<br><br>Para ver el documento conociendo su ID hacemos un simple GET<br><br><pre class="lang:default decode:true"><br>curl -X GET http://127.0.0.1:5984/supermercado/UUID<br></pre><br><br>Nos devuelve el documento entero junto con las propiedades _id y _rev.<br><h2>Actualizando un documento</h2><br>El precio de las manzanas ha cambiado, vamos a actualizarlo. El proceso es muy simple, es como insertar un documento pero añadimos la revisión sobre la que queremos hacerlo. Es importante mencionar que CouchDB no preserva nada en las actualizaciones. Si quieres dejar campos sin tocar, tendrás que volver a subirlos.<br><br><pre class="lang:default decode:true"><br>curl -X PUT http://127.0.0.1:5984/supermercado/98c003b03bc8aa87cb05983d1c000713 -d '{&quot;_rev&quot;: &quot;1-eba25568090eb2dfffad770b55147a67&quot;,&quot;nombre&quot;: &quot;Manzana&quot;, &quot;tipo&quot; : &quot;fruta&quot;, &quot;precio&quot; : 4}'<br></pre><br><br>Para borrar documentos necesitas usar DELETE indicando el número de revisión.<br><br><pre class="lang:default decode:true"><br>curl -X DELETE http://127.0.0.1:5984/supermercado/98c003b03bc8aa87cb05983d1c000713?rev=2-298fdb46385be60609b242b3e5cc3566<br></pre><br><br>(pero no lo hagas)<br><h2>Vistas</h2><br>Todo muy bonito, pero, ¿cómo accedo a la información? En SQL usaríamos SELECT, en bases como MongoDB lanzaríamos un find. En CouchDB hay que usar vistas, que se programan en JavaScript y siguen un esquema MapReduce (que recordemos, funciona muy bien en paralelo). Esto se puede hacer de varias formas. Se puede usar Fauxton, una interfaz web de CouchDB, se puede usar Erica, una herramienta para facilitar la creación y mantenimiento de CouchApps o se puede hacer con la API REST, ya que las vistas se definen en documentos JSON también.<br><br>Tenemos que crear un Design Doc. Los design doc son muy útiles y permiten por ejemplo validar documentos que vayan a entrar en la base de datos (podemos definir schemas así) o definir las vistas. Un design doc simple es así. Definimos una vista llamada all con una operación map.<br><br>&nbsp;<br><br><pre class="lang:js decode:true"><br>{<br>    &quot;views&quot; : {<br>        &quot;all&quot; : {<br>            &quot;map&quot; : &quot;function(doc){ emit(null,doc); }&quot;<br>        }<br>    }<br>}<br></pre><br><br>Si lo tenemos guardado en un archivo JSON<br><br><pre class="lang:default decode:true"><br>curl -H &quot;Content-Type: application/json&quot; --data @super.json -X PUT http://127.0.0.1:5984/supermercado/_design/super<br></pre><br><br>Ahora vamos a ejecutar la vista<br><br><pre class="lang:default decode:true"><br>curl -X GET http://127.0.0.1:5984/supermercado/_design/super/_view/all<br></pre><br><br>Obtenemos un objeto JSON con todos los documentos que contiene la base de datos supermercado. Por supuesto es posible crear distintos documentos de diseño, con distintas vistas cada uno.<br><br>Las vistas solo las debería poder crear el administrador de la base de datos, por lo que al contrario que en otras bases de datos, el cliente no podrá realizar operaciones que no hayan sido definidas antes. En realidad, no es del todo cierto, ya que en CouchDB 2.0 se añadió Mango, un lenguaje de consulta declarativo que permite realizar cierta operativa sin usar las vistas, pero no es tan potente.<br><br>Otro ejemplo:<br><br><pre class="lang:js decode:true"><br>{<br>    &quot;views&quot; : {<br>        &quot;by-price&quot; : {<br>            &quot;map&quot; : &quot;function(doc){ emit(doc.precio,doc); }&quot;<br>        }<br>    }<br>}<br></pre><br><br>Esta vista puede ser llamada con parámetros<br><br><pre class="lang:default decode:true"><br>curl -X GET http://127.0.0.1:5984/supermercado/_design/super/_view/by-price?descending=true&amp;amp;limit=1<br></pre><br><br>CouchDB realiza la operación de ordenado por su cuenta con el valor del key que devolvemos.<br><h2>La base de datos en el salvaje oeste</h2><br>Ahora vamos a ver como exponer CouchDB al salvaje Internet sin comprometer seguridad. En primer lugar toca hablar de los usuarios. Como hemos dicho, CouchDB arranca en el modo <em>Admin Party</em>. Este modo será desactivado en cuanto creemos un usuario como admin. CouchDB soporta además usuarios tradicionales, una característica muy útil que veremos después como usar.<br><br>Para crear un usuario como admin lanzamos esta petición:<br><br><pre class="lang:default decode:true"><br>curl -X PUT http://127.0.0.1:5984/_config/admins/aarroyoc -d '&quot;MiPassword&quot;'<br></pre><br><br>A partir de ahora ya no estamos en una admin party y si intentamos crear una base de datos veremos que CouchDB nos deniega el acceso. Sin embargo, otras tareas como subir documentos a bases de datos ya existentes todavía funcionan.<br><br>Para protegernos mejor debemos saber los tipos de autorización que soporta CouchDB. En primer lugar soporta HTTP Basic Auth, un método en el que mandamos el usuario y la contraseña en texto plano en cada petición. Esto no es para nada seguro, pero combinado con SSL no es mala opción. Sin embargo sigue sin ser la mejor solución para los expertos en seguridad. CouchDB también acepta autenticación por cookies. Las cookies duran 10 minutos por defecto y se generan haciendo una petición a _session con formato de formulario HTTP.<br><br><pre class="lang:default decode:true"><br>curl -vX POST http://127.0.0.1:5984/_session -H &quot;Content-Type:application/x-www-form-urlencoded&quot; -d &quot;name=aarroyoc&amp;amp;password=MiPassword&quot;<br></pre><br><br>Que nos devuelve una cookie válida para operar en la base de datos<br><br><a href="https://files.adrianistan.eu/Cookie.png"><img class="aligncenter size-full wp-image-826" src="https://files.adrianistan.eu/Cookie.png" alt="" width="657" height="388" /></a>Existen plugins que permiten gestionar desde CouchDB autorizaciones más diversas, como por ejemplo OpenID o OAuth2, pero pueden complicarnos mucho el desarrollo.<br><br>Los usuarios normales se guardan en la base de datos especial _users y se les puede asignar roles, con permisos para cada base de datos. Por defecto, se pueden crear cuentas de usuario nuevas de forma tan simple como así:<br><br><pre class="lang:default decode:true"><br>curl -X PUT http://127.0.0.1:5984/_users/org.couchdb.user:USUARIO -d '{&quot;name&quot; : &quot;USUARIO&quot;, &quot;password&quot; : &quot;MiPassword&quot;, &quot;type&quot; : &quot;user&quot;, &quot;roles&quot; : []}'<br></pre><br><br>Es importante seguir el esquema <em>org.couchdb.user:USUARIO</em> para los documentos. Los roles solo los puede ajustar una cuenta de admin, así que en las peticiones anónimas deberá ir vacío.<br><br>Si en algún momento quieres saber cuántos usuarios tiene la base de datos, puedes usar la vista predefinida <em>_all_docs</em>.<br><br><pre class="lang:default decode:true"><br>curl -X GET http://usuarioadmin:contraseñaadmin@127.0.0.1:5984/_users/_all_docs<br></pre><br><br>Estos documentos de usuarios por defecto son privados pero podemos mostrar cierta información para el resto de usuarios, sobretodo si añadimos campos extra a los documentos<br><br><pre class="lang:default decode:true"><br>curl -X PUT http://usuarioadmin:contraseñaadmin@127.0.0.1:5984/_config/couch_httpd_auth/public_fields -d '&quot;name&quot;'<br></pre><br><br>Hará visible el campo name a todas las peticiones GET anónimas a ese documento de usuario.<br><h2>Accesos a la base de datos</h2><br>Ahora vamos a ver como controlar las lecturas y escrituras de una base de datos en concreto. Aquí creo que CouchDB tiene limitaciones y que debe ser algo en lo que enfocarse en futuras versiones pues es un control muy limitado. Si fuese una base de datos interna no sería mucho problema, pero teniendo en cuenta que va a estar expuesta a Internet sería necesario algo más potente. Eso no quiere decir que no se puedan hacer cosas, pero vamos a tener que tirar de funciones JavaScript internas.<br><br>Por un lado, tenemos un documento especia en cada base de datos llamado _security. Este contiene listas de admins y miembros. Las listas pueden estar vacías, contener usuarios o contener roles. En caso de que la lista de miembros este vacía se considera que todos los usuarios son miembros (incluido los anónimos). Los miembros pueden leer y escribir todos los archivos. Esto es muy insuficiente. Por poner un caso completo, yo necesitaba:<br><ul><br> 	<li>Que todos los usuarios pudieran leer los documentos (incluido anónimos)</li><br> 	<li>Que todos los usuarios registrados pudieran crear documentos</li><br> 	<li>Que solo se pudiesen modificar los documentos creados por cada usuario</li><br></ul><br>Esto se puede hacer si obligamos a los documentos a que especifiquen un dueño. Todo lo podemos hacer en esta función:<br><br><pre class="lang:js decode:true"><br>function (new_doc, old_doc, userCtx){<br>    if(!userCtx.name)<br>        throw({forbidden: &quot;Not authorized&quot;});<br><br>    if(!new_doc.owner)<br>        throw({forbidden: &quot;Plase, set an owner&quot;});<br><br>    if(new_doc.owner != userCtx.name)<br>        throw({forbidden: &quot;Owner in document should be the same as user&quot;})<br><br>    if(old_doc!=null)<br>        if(old_doc.owner != userCtx.name &amp;&amp; userCtx.roles.indexOf(&quot;_admin&quot;) &lt; 0)<br>            throw({forbidden: &quot;Not your document&quot;});<br>    return;<br>}<br></pre><br><br>Esta función puede ser subida a CouchDB con la API HTTP dentro de un design doc. El design doc quedaría así:<br><br><pre class="lang:js decode:true"><br>{<br>        &quot;_rev&quot; : &quot;7-670f7428b5a5afb25ec61382024f0733&quot;,<br>        &quot;views&quot; : {<br>                &quot;all&quot; : {<br>                        &quot;map&quot; : &quot;function(doc){ emit(doc.name,doc); }&quot;<br>                },<br>                &quot;by-price&quot; : {<br>                        &quot;map&quot; : &quot;function(doc){ emit(doc.precio,doc); }&quot;<br>                }<br>        },<br>        &quot;validate_doc_update&quot;:&quot;function (new_doc, old_doc, userCtx){\n    if(!userCtx.name)\n        throw({forbidden: \&quot;Not authorized\&quot;});\n\n    if(!new_doc.owner)\n\tthrow({forbidden: \&quot;Plase, set an owner\&quot;});\n\n    if(new_doc.owner != userCtx.name)\n        throw({forbidden: \&quot;Owner in document should be the same as user\&quot;})\n\n    if(old_doc!=null)\n        if(old_doc.owner != userCtx.name &amp;&amp; userCtx.roles.indexOf(\&quot;_admin\&quot;) &lt; 0)\n            throw({forbidden: \&quot;Not your document\&quot;});\n    return;\n} \n&quot;<br>}<br><br></pre><br><br>Por supuesto, en _rev irá la revisión que toque. Este sistema es más potente de lo que parece ya que podemos controlar todos los detalles de la operación. Es por ello que muchas veces la función validate_doc_update es la más compleja de los documentos de diseño. Para ayudarme un poco, estoy usando Node.js para leer archivos JavaScript y pasarlos a una cadena JSON válida.<br><h2>CORS y SSL</h2><br>Vamos a lanzar CouchDB a Internet. En primer lugar, un par de detalles. CouchDB idealmente vivirá en un dominio separado a la web estática. Para que las peticiones JavaScript funcionen hay que activar CORS. También vamos a proteger los datos así como los usuarios y contraseñas transmitidos. Todo esto podemos hacerlo del tirón con nginx:<br><br>&nbsp;<br><br><pre class="lang:default decode:true"><br>server {<br>        listen 443 ssl http2;<br>        ssl_certificate /etc/letsencrypt/live/alejandria.adrianistan.eu/fullchain.pem;<br>        ssl_certificate_key /etc/letsencrypt/live/alejandria.adrianistan.eu/privkey.pem;<br>        server_name alejandria.adrianistan.eu;<br>        location / {<br>                add_header Access-Control-Allow-Origin *;<br>                proxy_pass http://localhost:5984;<br>                proxy_redirect off;<br>                proxy_set_header Host $host;<br>                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>                proxy_set_header X-Forwarded-Ssl on;<br>        }<br><br>        location /_utils/ {<br>                return 404;<br>        }<br>}<br></pre><br><br>¡Listo! Ya tenemos una instancia de CouchDB directamente conectada a Internet. Como podéis comprobar es una alternativa muy interesante en muchos casos. Sin embargo, ciertas cosas son un poco diferentes y más complejas de realizar. Mencionar que CouchDB también es posible usarse con un servidor de por medio en un esquema tradicional. En este caso, podemos usar la cuenta de admin para crear bases de datos personales para cada usuario. Este enfoque es necesario si necesitamos que los datos sean privados o queremos afinar más que roles tienen acceso a una base datos. CouchDB anima a crear tantas bases de datos como necesitemos, varias por usuario si es necesario, para satisfacer nuestros requerimientos. Esto no tiene gran impacto en el rendimiento tal y como está diseñado.<br><br>Puede hacerse de forma ligera, con una pequeña app que gestione el alta de usuarios y una vez creada la base de datos y ajustados los permisos se puede usar la API REST de CouchDB desde el lado del cliente con total normalidad, con protecciones de lectura y escritura más precisas.<br><br>Este modelo que hemos presentado es ideal para aplicaciones cuya base de datos principal sea pública y accesible y con unos pequeños ajustes puede adaptarse a muchas situaciones. Espero que os haya gustado el artículo. Nos hemos dejado cosas como la replicación entre nodos, los ficheros binarios o attachments ydos complementos a las vistas llamados show y lists, que permiten renderizar HTML o XML entre otras cosas, con los datos de salida de una vista si es necesario.<br><br>&nbsp;