Ya hemos visto los <a href="https://blog.adrianistan.eu/2015/04/05/la-informacion-es-poder/">motivos</a> que tengo para diseñar un servicio de analíticas desde 0. Ahora veremos como lo he hecho.<br><img class="alignnone size-large wp-image-39" src="https://files.adrianistan.eu/Fliuva-1024x496.png" alt="Fliuva" width="840" height="407" /><br><br>No he tocado ningún CSS.<br><h2>La base de datos</h2><br>En un servicio de analíticas lo más importante son los datos, así que debemos de definir como almacenaremos la información. En principio Fliuva iba a estar centrado en analizar una única aplicación. Más tarde he pensado en un soporte multiaplicaciones pero no lo voy a desarrollar de momento. Usaría un espacio de nombres delante de todas las tablas y las peticiones GET.<br><blockquote>Usuarios = Sesiones</blockquote><br>En ciertos servicios de analíticas los usuarios y las sesiones son dos conceptos diferentes. En Fliuva sin embargo, y por razones de simplificar la estructura, ambos conceptos son idénticos y hablaremos de ellos como sesiones.<br><h3>Tablas</h3><br>Será necesario tener una tabla de eventos.<br><h4>Events</h4><br><ul><br> 	<li>CATEGORY: Categoría del evento</li><br> 	<li>SUBCATEGORY: Subcategoría del evento</li><br> 	<li>NAME: Nombre del evento</li><br> 	<li>DESCRIPTION: Descripción del evento</li><br> 	<li>DATA: Datos del evento</li><br> 	<li>ID: Identificador</li><br> 	<li>TIME: Hora en que se produjo</li><br> 	<li>SESSION: Sesión a la que pertenece el evento</li><br></ul><br><pre class="lang:tsql decode:true ">CREATE TABLE IF NOT EXISTS EVENTS(ID INT NOT NULL AUTO_INCREMENT, CATEGORY TEXT, SUBCATEGORY TEXT, NAME TEXT, DESCRIPTION TEXT, DATA TEXT, TIME DATETIME, SESSION TEXT, PRIMARY KEY (`ID`) )</pre><br>&nbsp;<br><br>Y ya con esta tabla tendremos para almacenar muchos datos. Los campos CATEGORY, SUBCATEGORY, NAME, DESCRIPTION y DATA sirven unicamente para organizar eventos y subeventos en categorías. Los nombres de los campos son triviales. DESCRIPTION no guarda realmente la descripción sino que podemos definir otro subevento. Con 5 campos para categorizar eventos superamos a Google Analytics que tiene CATEGORY, ACTION, LABEL y VALUE. Además VALUE debe ser numérico mientras que en Fliuva todos son de tipo texto (en la práctica, cualquier cosa).<br><h3>Código de seguimiento</h3><br>¿Cómo introducir datos en la base de datos desde nuestra aplicación? Con una pequeña llamada GET a /collect. Yo la he definido en un fichero llamado collect.js<br><pre class="lang:js decode:true">var mysql=require("mysql");<br><br>// GET /collect<br><br>module.exports=function(req,res){<br>var connection=mysql.createConnection({<br>    host: process.env.OPENSHIFT_MYSQL_DB_HOST,<br>    port: process.env.OPENSHIFT_MYSQL_DB_PORT,<br>    user: process.env.OPENSHIFT_MYSQL_DB_USER,<br>    password: process.env.OPENSHIFT_MYSQL_DB_PASSWORD,<br>    database: "fliuva"<br>});<br>connection.connect(function(err){<br>    if(err){<br>        res.send(501,"MySQL connection error\n"+err);<br>    }<br>    connection.query("CREATE TABLE IF NOT EXISTS EVENTS(ID INT NOT NULL AUTO_INCREMENT,"+<br>        "CATEGORY TEXT, SUBCATEGORY TEXT, NAME TEXT, DESCRIPTION TEXT, DATA TEXT, "+<br>        "TIME DATETIME, SESSION TEXT,"+<br>        "PRIMARY KEY (`ID`) )",function(err,results,fields){<br>            if(err){<br>                res.send(501,"MySQL table creation error\n"+err);<br>            }<br>            connection.query("INSERT INTO EVENTS SET ?",{<br>                SESSION: req.query.SESSION,<br>                TIME: new Date(),<br>                CATEGORY: req.query.CATEGORY || "",<br>                SUBCATEGORY: req.query.SUBCATEGORY || "",<br>                NAME: req.query.NAME || "",<br>                DESCRIPTION: req.query.DESCRIPTION || "",<br>                DATA: req.query.DATA || ""<br>            },function(err,results,fields){<br>                if(err){<br>                    res.send(501,"Query error\n"+err);<br>                }<br>                res.send("OK");<br>            });<br>       });<br>});<br>}<br><br></pre><br>Y se llama muy fácilmente<br><pre class="lang:default decode:true">GET /collect?CATEGORY=&lt;category&gt;&amp;SUBCATEGORY=&lt;subcategory&gt;&amp;NAME=&lt;name&gt;&amp;DESCRIPTION=&lt;description&gt;&amp;DATA=&lt;data&gt;&amp;SESSION=&lt;session&gt;<br><br></pre><br>Si estamos en HTML5, necesitaremos una librería de cliente para poder realizar las llamadas<br><pre class="lang:js decode:true">function login(){<br>    var xhr=new XMLHttpRequest();<br>    xhr.open("GET","/uuid");<br>    xhr.addEventListener("load",function(){<br>        sessionStorage.__fliuvaSession=xhr.responseText;<br>    });<br>    xhr.send();<br>}<br><br>function sendEvent(category,subcategory,name,description,data){<br>    var xhr=new XMLHttpRequest();<br>    var url="/collect"+<br>    "?CATEGORY="+category+<br>    "&amp;SUBCATEGORY="+subcategory+<br>    "&amp;NAME"+name+<br>    "&amp;DESCRIPTION"+description+<br>    "&amp;DATA"+data+<br>    "&amp;SESSION"+sessionStorage.__fliuvaSession;<br>    xhr.open("GET",url);<br>    xhr.send();<br>}<br><br></pre><br>Así, simplemente hay que llamar a sendEvent. Llamar a <em>login</em> no es necesario siempre que rellenes el valor de <em>sessionStorage.__fliuvaSession </em>correctamente.<br><h2>Análisis de datos</h2><br>Ahora debemos analizar los datos. Primero debemos obtener los valores a analizar. La llamada a /get devuelve un fichero JSON con la información completa. En un futuro lo ideal sería espeficicar intervalos de fechas.<br><pre class="lang:js decode:true">//GET /get<br>var mysql=require("mysql");<br><br>module.exports=function(req,res){<br>var connection=mysql.createConnection({<br>    host: process.env.OPENSHIFT_MYSQL_DB_HOST,<br>    port: process.env.OPENSHIFT_MYSQL_DB_PORT,<br>    user: process.env.OPENSHIFT_MYSQL_DB_USER,<br>    password: process.env.OPENSHIFT_MYSQL_DB_PASSWORD,<br>    database: "fliuva"<br>});<br>connection.query("SELECT * FROM EVENTS",function(err,results,fields){<br>    res.send(JSON.stringify(results));<br>});<br>}<br><br></pre><br>Y en el cliente tratamos los datos. Aquí es donde debemos nosotros mismos crear las estadísticas según las métricas que hayamos definido. Yo solo voy a poner una métrica universal, usuarios por día.<br><pre class="lang:js decode:true">/* Visualization App */<br>window.addEventListener("load",function(){<br>    usersPerDay();<br>    sessionsTable();<br>});<br><br>function id(idx){<br>    return document.getElementById(idx);<br>}<br><br>function uniqBy(a, key) {<br>    var seen = {};<br>    return a.filter(function(item) {<br>        var k = key(item);<br>        return seen.hasOwnProperty(k) ? false : (seen[k] = true);<br>    })<br>}<br>function ISODateString(d){<br>    function pad(n){return n&lt;10 ? '0'+n : n}<br>    return d.getUTCFullYear()+'-'<br>    + pad(d.getUTCMonth()+1)+'-'<br>    + pad(d.getUTCDate());<br>}<br><br>/* Users-per-day */<br>function usersPerDay(){<br>    var xhr=new XMLHttpRequest();<br>    xhr.overrideMimeType("application/json");<br>    xhr.open("GET","/get");<br>    xhr.addEventListener("load",function(){<br>        var json=JSON.parse(xhr.responseText);<br>        var dataset=new vis.DataSet();<br>        /*var data=json.filter(function(){<br><br>        });*/<br>        var array=uniqBy(json,function(item){<br>            return item.SESSION;<br>        }); // Eventos de sesiones repetidas eliminados (mismos usuarios). Ahora tenemos sesiones únicas y tiempos distintos<br>        for(var i=0;i&lt;array.length;i++)<br>        {<br>            var time=new Date(array[i].TIME);<br>            var date=ISODateString(time); //time.toISOString().substring(0,time.toISOString().indexOf("T"));<br><br>            var y;<br>            if(dataset.get(date)==null)<br>                y=1;<br>            else<br>                y=dataset.get(date).y+1;<br><br>            console.log(date);<br>            dataset.update({x: date, id: date, y: y});<br>        }<br>        var options = {<br>            catmullRom: false<br>        };<br>        var graph2d = new vis.Graph2d(id("users-per-day"), dataset, options);<br>    });<br>    xhr.send();<br>}<br><br>/* Table for sessions */<br><br>function sessionsTable(){<br>	var table=document.getElementById("sessions");<br>	var xhr=new XMLHttpRequest();<br>	xhr.open("GET","/get");<br>	xhr.addEventListener("load",function(){<br>		var json=JSON.parse(xhr.responseText);<br>		var data=uniqBy(json,function(item){<br>			return item.SESSION;<br>		});<br>		for(var i=0;i&lt;data.length;i++)<br>		{<br>			var item=data[i];<br>			var tr=document.createElement("tr");<br>			var time=document.createElement("td");<br>			time.textContent=item.TIME;<br>			var session=document.createElement("td");<br>			var link=document.createElement("a");<br>			link.href="/session/"+item.SESSION;<br>			link.textContent=item.SESSION;<br>			session.appendChild(link);<br>			tr.appendChild(time);<br>			tr.appendChild(session);<br>			table.appendChild(tr);<br>		}<br>	});<br>	xhr.send();<br>}<br><br></pre><br>Que se corresponde a este pequeño HTML<br><pre class="lang:default decode:true">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;title&gt;Fliuva - Página principal&lt;/title&gt;<br>		&lt;meta charset="utf-8"/&gt;<br>		&lt;script src="bower_components/vis/dist/vis.min.js" type="text/javascript"&gt;&lt;/script&gt;<br>		&lt;link href="bower_components/vis/dist/vis.min.css" rel="stylesheet" media="all" type="text/css"&gt;<br>		&lt;script src="/app.js"&gt;&lt;/script&gt;<br>	&lt;/head&gt;<br>	&lt;body&gt;<br>		&lt;h1&gt;Fliuva&lt;/h1&gt;<br>		&lt;section&gt;<br>			&lt;h3&gt;Usuarios por día&lt;/h3&gt;<br>			&lt;div id="users-per-day"&gt;&lt;/div&gt;<br>		&lt;/section&gt;<br>		&lt;section&gt;<br>			&lt;table id="sessions"&gt;<br>				&lt;tr&gt;<br>					&lt;th&gt;Tiempo&lt;/th&gt;<br>					&lt;th&gt;Sesión&lt;/th&gt;<br>				&lt;/tr&gt;<br>			&lt;/table&gt;<br>		&lt;/section&gt;<br>	&lt;/body&gt;<br>&lt;/html&gt;<br></pre><br>Visualizar cada sesión por separado es posible con la llamada a /session/NOMBRE_DE_SESION<br><pre class="lang:js decode:true">var mysql=require("mysql");<br><br>module.exports=function(req,res){<br>	var session=req.params.session;<br>	var connection=mysql.createConnection({<br>		host: process.env.OPENSHIFT_MYSQL_DB_HOST,<br>		port: process.env.OPENSHIFT_MYSQL_DB_PORT,<br>		user: process.env.OPENSHIFT_MYSQL_DB_USER,<br>		password: process.env.OPENSHIFT_MYSQL_DB_PASSWORD,<br>		database: "fliuva"<br>	});<br>	connection.query("SELECT * FROM EVENTS WHERE SESSION = ?",[session],function(err,results){<br>		if(err)<br>			res.send(502,"Error: "+err);<br>		res.render("session.jade",{events: results});<br>	});<br>}<br><br></pre><br>Y para un rápido procesamiento he decidido usar Jade con JavaScript en el servidor. Y entonces session.jade queda<br><pre class="lang:default decode:true">doctype html<br>html<br>	head<br>		title Vista de sesión<br>		meta(charset="utf-8")<br>	body<br>		h1 Vista de sesión<br>		table<br>			tr<br>				th Categoría<br>				th Subcategoría<br>				th Nombre<br>				th Descripción<br>				th Datos<br>				th Tiempo<br>			each event in events<br>				tr<br>					td= event.CATEGORY<br>					td= event.SUBCATEGORY<br>					td= event.NAME<br>					td= event.DESCRIPTION<br>					td= event.DATA<br>					td= event.TIME<br><br></pre><br><h2>Juntando piezas</h2><br>Por último, la aplicación se tiene que iniciar en algún lado. Server.js contiene el arranque<br><pre class="lang:js decode:true">var express=require("express");<br>var mysql=require("mysql");<br>var collect=require("./collect");<br>var getdata=require("./getdata");<br>var session=require("./session");<br>var uuid=require("node-uuid");<br><br>var app=express();<br><br>app.set("views",__dirname + "/jade");<br>app.set("view engine","jade");<br><br>app.get("/collect",collect);<br><br>app.get("/get",getdata);<br><br>app.get("/uuid",function(req,res){<br>	res.send(uuid.v4());<br>});<br><br>app.get("/session/:session",session);<br><br>app.use(express.static("www"));<br><br>var ip=process.env.OPENSHIFT_NODEJS_IP || process.env.OPENSHIFT_INTERNAL_IP || "127.0.0.1";<br>var port=process.env.OPENSHIFT_NODEJS_PORT || process.env.OPENSHIFT_INTERNAL_PORT || 8080;<br><br>var server=app.listen(port,ip);<br><br></pre><br>Y así en un pis pas hemos hecho una aplicación de seguimiento y analíticas en JavaScript. Ahora toca empezar a diseñar estadísticas con los datos que tenemos a nuestra disposición y por supuesto cuando tengamos los datos a obrar en consecuencia.