Hace ya bastante tiempo quese viene hablando de ordenadores cuánticos. ¿Qué son? ¿En qué se diferencian de los ordenadores clásicos? ¿Son de verdad tan potente como dicen?<br><br>En este largo artículo, ideal para el verano, vamos a ver los principios fundamentales de los ordenadores cuánticos más allá de lo que la típica revista o web te podría contar. Veremos qué es un qubit y algunas puertas lógicas interesantes, así como su aplicación.<br><br><a href="https://files.adrianistan.eu/IBMQComputer.jpg"><img class="size-full wp-image-1552" src="https://files.adrianistan.eu/IBMQComputer.jpg" alt="" width="720" height="480" /></a> Los ordenadores cuánticos actuales requieren temperaturas de funcionamiento cercanas al cero absoluto<br><h2>Notación de Dirac</h2><br>Lo primero antes de entrar en materia cuántica, será adaptar nuestra notación clásica, a otra más potente. Esta notación que vamos a ver, llamada <a href="https://la-mecanica-cuantica.blogspot.com/2009/08/la-notacion-bra-ket-de-dirac.html">notación de Dirac o Bra-ket</a>, nos será muy útil ya que los bits clásicos no son más que un caso concreto de qubit en esta notación.<br><br>En esta notación tenemos que representar los bits como matrices. Un conjunto de N bits se representa con una matriz de 1 columna y [latex]2^N[/latex] filas. En todas las posiciones existen ceros salvo para la posición que representa la combinación que representa. Veamos algunos ejemplos sencillos:<br><br>Un bit con valor 0 se representa así<br><p style="text-align: center;">[latex]<br>| 0 \rangle = \begin{pmatrix}<br>1\\<br>0<br>\end{pmatrix}[/latex]</p><br>Un bit con valor 1 se representa así:<br><p style="text-align: center;">[latex]<br>| 1 \rangle = \begin{pmatrix}<br>0\\<br>1<br>\end{pmatrix}[/latex]</p><br>Aquí contamos como en informática, empezando desde cero. Como ves la posición 0 del vector solo es 1 cuando representa el bit 0. Si la posición que tiene el 1 es la segunda, representa el bit 1.<br><br>La parte que va a la izquierda del igual se llama ket. En este caso hemos representado ket 0 y ket 1.<br><br>Si tenemos más bits se puede hacer de la misma forma. Vamos a representtar ket 10. 10 en binario es 2, así que estará en la posición tercera.<br><p style="text-align: center;">[latex]<br>| 10 \rangle = \begin{pmatrix}<br>0\\<br>0\\<br>1\\<br>0<br>\end{pmatrix}[/latex]</p><br><br><h2>Puertas lógicas como producto de matrices</h2><br>¿Recuerdas el producto de matrices de tus clases de álgebra? Resulta que todas las puertas lógicas clásicas pueden representarse como producto de matrices. Por ejemplo, la puerta lógica NOT se puede implementar con esta matriz:<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>0 &amp; 1 \\<br>1 &amp; 0 \\<br>\end{pmatrix}<br>[/latex]</p><br>Y aquí la vemos en acción<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>0 &amp; 1 \\<br>1 &amp; 0 \\<br>\end{pmatrix}\begin{pmatrix}<br>1 \\<br>0<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>0 \\<br>1<br>\end{pmatrix}<br>[/latex]</p><br>También podría hacerse con la puerta AND que toma como entrada dos bits.<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>1 &amp; 1 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>\begin{pmatrix}<br>0 \\<br>0 \\<br>0 \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>0 \\<br>1<br>\end{pmatrix}<br>[/latex]</p><br><br><br><a href="https://files.adrianistan.eu/IBMQKeyboard.jpeg"><img class="size-large wp-image-1553" src="https://files.adrianistan.eu/IBMQKeyboard-747x1024.jpeg" alt="" width="747" height="1024" /></a> Un teclado con puertas cuánticas<br><h2>Juntando bits</h2><br>Para formar bits más grandes ya sabemos que tenemos que tener una matriz tan grande como combinaciones haya ([latex]2^N[/latex] posiciones, N bits). Existe una forma de calcular automáticamente la posición que hay que marcar y es hacer el <strong>producto tensorial</strong>. Si no sabes calcularlo no importa mucho, porque apenas lo vamos a usar, pero puedes ver un ejemplo de como funciona. En este ejemplo, queremos juntar los bits 1 y 1 (3 en decimal).<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>0 \\<br>1<br>\end{pmatrix}<br>\otimes<br>\begin{pmatrix}<br>0 \\<br>1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>0 \\<br>0 \\<br>0 \\<br>1<br>\end{pmatrix}<br>[/latex]</p><br><br><h2>Qubits</h2><br>Hasta ahora no hemos visto nada realmente nuevo, solo hemos preparado el terreno para dejar paso a los qubits. Personalmente desconocía que podían usarse matrices para operar con bits y aunque no es tan práctico como otros sistemas, lo cierto es que es muy explícito y elegante.<br><br><a href="https://files.adrianistan.eu/Schrodinger.jpg"><img class="aligncenter size-full wp-image-1555" src="https://files.adrianistan.eu/Schrodinger.jpg" alt="" width="670" height="502" /></a>Los qubits son bits como los que hemos visto antes pero tienen un estado indeterminado. No es que tengan un valor de forma secreta y no sepamos cuál es. Podríamos decir que son los dos valores clásicos a la vez, como el <a href="https://www.youtube.com/watch?v=WMnjRIx3_XE">gato de Schrodinger.</a> Cuando realizamos una observación sobre el qubit, este <strong>colapsa</strong> y podemos ver uno de los dos estados. ¿Cuál vemos? No podemos saberlo a priori, pero hay <strong>probabilidades</strong>. Los bits clásicos no son más que qubits cuyas probabilidades de colapsar a 0 o 1 es del 100%, por tanto no hay duda y su valor sí que está determinado.<br><br>¿Cómo representamos los qubits y sus estados cuánticos? Con <strong>números complejos</strong>. Si recuerdas, estos eran los que tenían una parte real y una imaginaria. No obstante, voy a tomar solo los números <strong>reales</strong> para simplificar. Los números reales son números complejos válidos, pero los complejos son mucho más extensos.<br><br><a href="https://files.adrianistan.eu/EsferaBloch.jpg"><img class="size-large wp-image-1551" src="https://files.adrianistan.eu/EsferaBloch-1024x482.jpg" alt="" width="840" height="395" /></a> La esfera de Bloch permite representar todos los estados cuánticos (números complejos)<br><br>Para calcular la probabilidad que tiene un estado cuántico de colapsar a un valor, hacemos el módulo y elevamos al cuadrado: [latex]|a|^2[/latex].<br><br>Todo qubit además debe cumplir una propiedad fundamental:<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>a \\<br>b<br>\end{pmatrix}<br>\text{ es un qubit}<br>\Leftrightarrow<br>|a|^2 + |b|^2 = 1<br>[/latex]</p><br>Y es que la probabilidad de ser 0 y de ser 1 sumadas deben equivaler al suceso seguro, es decir, 1. 100% de probabilidades de que de 0 o 1.<br><br>Con esto ya podemos definir algunos qubits.<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>\frac{1}{\sqrt{2}} \\<br>\frac{1}{\sqrt{2}}<br>\end{pmatrix}<br>[/latex]</p><br>Este es mi qubit preferido. Representa el estado de superposición cuántica. Cada valor tiene el 50% de probabilidades de salir. [latex]|\frac{1}{\sqrt{2}}|^2 = \frac{1}{2}[/latex]. Cuando colapsemos el qubit al observarlo será como lanzar una moneda al aire.<br><br>Otro detalle que a veces se nos pasa por alto es que los qubits pueden contener valores negativos. Estos qubits son físicamente diferentes a los positivos, pero tienen las mismas probabilidades de colapsar en los mismos valores que los positivos.<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>-1 \\<br>0<br>\end{pmatrix}<br>[/latex]</p><br>Es un qubit válido, que colapsa con 100% de probilidad a 0.<br><br>¿Cómo se representan los qubits en notación de Dirac? Representando la probabilidad que tiene cada combinación de bits de aparecer. Para un qubit sería algo así:<br><p style="text-align: center;">[latex]<br>\alpha | 0 \rangle + \beta | 1 \rangle<br>[/latex]</p><br>Siendo [latex]\alpha[/latex] y [latex]\beta[/latex] las probabilidades de colapsar a cada estado.<br><h2>Puertas cuánticas</h2><br>Ahora vamos a ver cuáles son las puertas lógicas más importantes del mundo cuántico.<br><br><a href="https://files.adrianistan.eu/IBMQ.png"><img class="aligncenter size-large wp-image-1537" src="https://files.adrianistan.eu/IBMQ-1024x608.png" alt="" width="840" height="499" /></a><br><h4>Negación (Pauli X)</h4><br>Esta es exactamente igual que en el mundo clásico, con la misma matriz que hemos visto antes. Su símbolo es el cuadrado con una X.<br><br><a href="https://files.adrianistan.eu/IBMQNegation.png"><img class="aligncenter size-full wp-image-1535" src="https://files.adrianistan.eu/IBMQNegation.png" alt="" width="283" height="57" /></a>Aquí vemos una imagen del <a href="https://quantumexperience.ng.bluemix.net/qx">simulador IBM Q</a> usando la puerta X cuántica. IBM nos deja ejecutarlo en ordenadores cuánticos <strong>reales</strong>. Veamos los resultados.<br><br><a href="https://files.adrianistan.eu/IBMQResults.png"><img class="aligncenter size-full wp-image-1536" src="https://files.adrianistan.eu/IBMQResults.png" alt="" width="292" height="238" /></a>¡Terrible! La mayoría de casos, el ordenador cuántico responde 1, el valor correcto, pero un 13% de los casos no. Teóricamente había una probabilidad del 100% y en la práctica solo es del 86.3%. ¡Y solo es una puerta X! Es por ello que los procesadores cuánticos todavía necesitan mejorar mucho. Google, Microsoft e IBM están investigando de forma independiente en ordenadores cuánticos. Veremos quién consigue tener antes ordenadores cuánticos precisos (aunque hay expertos que piensan que nunca se podrá lograr).<br><h4>CNOT</h4><br>Esta puerta es muy interesante. Toma dos qubits, uno de control, que permanece invariable al traspasar la puerta y otro de datos. Al qubit de datos se le aplica la puerta X si el qubit de control está activo. Su matriz es la siguiente:<br><p style="text-align: center;">[latex]<br>CNOT = \begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{pmatrix}<br>[/latex]</p><br>Se reprensenta de esta forma:<br><br><a href="https://files.adrianistan.eu/CNOT.png"><img class="aligncenter size-full wp-image-1539" src="https://files.adrianistan.eu/CNOT.png" alt="" width="60" height="90" /></a>O similar, porque los símbolos de computación cuántica no están todavía muy estandarizados. El punto grande es el qubit de control y el punto pequeño está sobre el qubit de datos.<br><h4>HADAMARD</h4><br>Esta puerta es quizá la más famosa del mundo cuántico. Veamos su matriz:<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\<br>\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}<br>\end{pmatrix}<br>[/latex]</p><br>Esta puerta permite poner un qubit clásico en estado de superposición cuántica. Y también deshacerlo. Es muy usada en algoritmos cuánticos. Se representa con un cuadrado y una H.<br><br><a href="https://files.adrianistan.eu/IBMH.png"><img class="aligncenter size-full wp-image-1540" src="https://files.adrianistan.eu/IBMH.png" alt="" width="243" height="92" /></a>Los resultados en el ordenador cuántico real de IBM Q son:<br><br><a href="https://files.adrianistan.eu/IBMHStats.png"><img class="aligncenter size-full wp-image-1541" src="https://files.adrianistan.eu/IBMHStats.png" alt="" width="191" height="242" /></a>Cuando debería de ser bastante más cercano a 50% en los dos valores.<br><br>Con esto ya tenemos las puertas más usadas. Básicamente con Hadamard, X y CNOT se pueden implementar casi todos los circuitos cuánticos. Solo nos faltarían las puertas que operan entran en números complejos para poder implementar todos los circuitos.<br><h2>Algoritmo de Deutsch-Jozsa</h2><br>El<a href="https://es.wikipedia.org/wiki/Algoritmo_de_Deutsch-Jozsa"> algoritmo de Deutsch-Jozsa</a> es uno de los algoritmos cuánticos más sencillos de entender y que mejoran drásticamente el rendimiento respecto a un algoritmo clásico.<br><br>El planteamiento básico es que tenemos una caja negra que aplica una función sobre un bit. Estas funciones pueden ser: set-to-0, set-to-1 (ambas constantes), identidad (no cambiar nada) y X (ambas dinámicas) . Si queremos saber que función contiene la caja negra, ¿Cuántas veces tenemos que pasar valores? En una CPU clásica tendríamos que hacerlo dos veces para poder determinar que función contiene la caja negra. En una CPU cuántica... también. No hay diferencia. Pero, si cambiamos la pregunta a ¿de qué categoría es la función de la caja negra?, la cosa cambia. En una CPU clásica seguiríamos necesitando 2 pruebas, pero en una CPU cuántica y con un circuito por el exterior, podemos aprovechar la superposición cuántica para realizar una sola prueba y determinar si en el interior hay una función constante o dinámica.<br><br>Vamos a ver estas 4 funciones de la caja negra como son:<br><br><a href="https://files.adrianistan.eu/QuantumGates.png"><img class="aligncenter size-full wp-image-1544" src="https://files.adrianistan.eu/QuantumGates.png" alt="" width="900" height="200" /></a>¿Se te ocurre como puedes crear un circuito fuera de la caja negra que con una sola prueba, ya sepa si estamos ante las funciones Set-0, Set-1 o Identidad, Negación?<br><br>El circuito es el siguiente:<br><br><a href="https://files.adrianistan.eu/IBMBlackBox.png"><img class="aligncenter size-full wp-image-1545" src="https://files.adrianistan.eu/IBMBlackBox.png" alt="" width="390" height="89" /></a>Tal y como está diseñado si en q[1] medimos 0, la función es de tipo constante y si medimos 1, es de tipo dinámica. Un desarrollo matemático de los productos de matrices, <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Deutsch-Jozsa">como el que hay en Wikipedia</a>, te mostrará como siempre es cierto. Este también es un ejemplo de como los ordenadores cuánticos pueden dar resultados totalmente deterministas.<br><br>Esta idea, se puede generalizar y extrapolar a otros problemas, generando una colección muy interesante de algoritmos que se ejecutan en tiempo exponencialmente menor que en una CPU clásica.<br><h2>Algoritmos de Shor y de Grover</h2><br>Estos dos algoritmos han sido llamados los <em>killer apps</em> de la computación cuántica, ya que son algoritmos que mejoran sustancialmente (uno de forma exponencial, otro de forma cuadrática) los tiempos de problemas reales.<br><br>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Shor">algoritmo de Shor</a> fue el primero en ser descubierto, en 1994 por <a href="http://www-math.mit.edu/~shor/">Peter Shor</a>. Sirve para factorizar números (es decir, sacar los números primos que multiplicados generan el número original). Lo puede hacer en [latex]O((\log{n})^3)[/latex]. De este modo, los algoritmos tipo RSA que se basan en la factorización de números podrían romperse en tiempo polinómico, por lo cuál RSA ya no serviría como protección. El algoritmo de Shor no da siempre los resultados correctos, pero tiene una probabilidad de éxito superior a la de fracaso, por lo que con repetir múltiples veces la ejecución podríamos estar casi seguros del resultado.<br><br>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> fue descubierto en 1996 por Lov Grover y permite buscar en una lista no ordenada de datos en [latex]O(\sqrt{n})[/latex] mientras que en una computadora clásica sería [latex]O(n)[/latex].<br><br>Estos dos algoritmos sin duda marcan lo que se ha llamada la <strong>supremacía cuántica</strong> y que ocurrirá cuando los ordenadores cuánticos puedan ejecutar con suficiente precisión estos algoritmos y su utilidad en el mundo real supere a la de los algoritmos clásicos.<br><h2>Entrelazamiento cuántico</h2><br>Ya hemos visto las bases de los circuitos cuánticos. Ahora veamos algunas consecuencias de todo lo anterior. Cosas cuánticas que parecen hasta cierto punto fuera de la lógica. ¿Qué ocurre si tenemos varios qubits en un estado como este?<br><p style="text-align: center;">[latex]<br>\begin{pmatrix}<br>\frac{1}{\sqrt{2}} \\<br>0 \\<br>0 \\<br>\frac{1}{\sqrt{2}}<br>\end{pmatrix}<br>[/latex]</p><br>En este estado solo puede colapsar a 00 o a 11. ¿Esto qué significa? Significa que los qubits están entrelazados entre sí, uno depende de otro, si los separamos y uno colapsa a 0, el otro colapsa a 0. Si uno colapsa a 1, el otro colapsa a 1.<br><br>Es importante destacar que los qubits pueden separarse en este estados. Los qubits alejados a millones de kilómetros siguen entrelazados y el valor al que deciden colapsar se decide de <strong>forma instantánea</strong>. Esto quiere decir que se <em>sincronizan</em> a una velocidad <strong>superior a la de la luz</strong>. El truco es que no se transmite información, por eso el universo lo permite, pero esto permite realizar la teletransportación cuántica.<br><br>La forma de entrelazar qubits es muy sencilla, con una puerta Hadamard y una CNOT.<br><br><a href="https://files.adrianistan.eu/QuantumEntanglement.png"><img class="aligncenter size-full wp-image-1546" src="https://files.adrianistan.eu/QuantumEntanglement.png" alt="" width="373" height="113" /></a><a href="https://files.adrianistan.eu/QuantumEntanglementStats.png"><img class="aligncenter size-full wp-image-1547" src="https://files.adrianistan.eu/QuantumEntanglementStats.png" alt="" width="526" height="297" /></a><a href="https://quantumexperience.ng.bluemix.net/qx">IBM Q</a> todavía tiene que mejorar, pero se aprecia claramente el entrelazamiento cuántico.<br><h2>Teletransportación cuántica</h2><br>La teletransportación existe, al menos entre qubits. Y es <strong>instantánea</strong> (más o menos). La teletransportación cuántica la podemos provocar usando varios qubits entrelazados. Necesitamos 3 qubits. El qubit que va a ser teletransportado, un qubit del emisor y un qubit del receptor. La idea es entrelazar el emisor con el receptor (qubit de destino) y posteriormente el qubit del emisor con el qubit que va a ser transportado.<br><br><a href="https://files.adrianistan.eu/QuantumTeletransportation2.png"><img class="aligncenter size-full wp-image-1549" src="https://files.adrianistan.eu/QuantumTeletransportation2.png" alt="" width="724" height="185" /></a>No he sido capaz de hacer que IBM Q haga una teletransportación, así que aquí viene un esquema distinto. T es el qubit a transportar, A es el emisor y B el receptor. En este ejemplo se usa la puerta Pauli Z, cuya matriz es la indicada.<br><br>El truco de la teletransportación instantánea tiene que ver con que A y B tienen que estar entrelazados, por tanto, han tenido que ser transportados a sus respectivos lugares anteriormente a velocidad inferior a la luz.<br><br>Esto teletransporta qubits pero <strong>no hace copias</strong>. Esto es debido al <a href="https://es.wikipedia.org/wiki/Teorema_de_no_clonaci%C3%B3n">Teorema de No Clonación</a>.<br><h2>Lenguajes de programación</h2><br>Mientras esperamos a que los ordenadores cuánticos sean lo suficientemente estables, ya existen lenguajes de programación que podemos usar en simuladores. Quizá el más conocido sea Q# de Microsoft (funciona en Linux, tranquilos), que guarda similitudes con C#. Otro bastante usado es OpenQasm de IBM, algo más parecido a ensamblador.<br><pre class="lang:c# decode:true">namespace Quantum.Bell<br>{<br>    open Microsoft.Quantum.Primitive;<br>    open Microsoft.Quantum.Canon;<br><br>    operation Set (desired: Result, q1: Qubit) : ()<br>    {<br>        body<br>        {<br>            let current = M(q1);<br>            if (desired != current)<br>            {<br>                X(q1);<br>            }<br>        }<br>    }<br>    operation BellTest (count : Int, initial: Result) : (Int,Int,Int)<br>    {<br>        body<br>        {<br>            mutable numOnes = 0;<br>            mutable agree = 0;<br>            using (qubits = Qubit[0])<br>            {<br>                for (test in 1..count)<br>                {<br>                    Set (initial, qubits[0]);<br>                    Set (Zero, qubits[1]);<br><br>                    H(qubits[0]);<br>                    CNOT(qubits[0],qubits[1]);<br>                    let res = M (qubits[0]);<br><br>                    if (M (qubits[1]) == res) <br>                    {<br>                        set agree = agree + 1;<br>                    }<br><br>                    // Count the number of ones we saw:<br>                    if (res == One)<br>                    {<br>                        set numOnes = numOnes + 1;<br>                    }<br>                }<br><br>                Set(Zero, qubits[0]);<br>            }<br>            // Return number of times we saw a |0&gt; and number of times we saw a |1&gt;<br>            return (count-numOnes, numOnes, agree);<br>        }<br>    }<br>}</pre><br>Este es un ejemplo de <em>lanzar la moneda</em> con entrelazamiento cuántico en Q#, el lenguaje cuántico de Microsoft.<br><h2>Referencias</h2><br><a href="https://www.youtube.com/watch?v=F_Riqjdh2oM">Quantum Computing for Computer Scientists</a><br><a href="https://www.infoq.com/articles/quantum-computing-algoritms-two">Cats, Qubits, and Teleportation: The Spooky World of Quantum Algorithms</a><br><a href="https://www.youtube.com/watch?v=v7b4J2INq9c">Microsoft Quantum Development Kit: Introduction and step-by-step demo</a><br><a href="https://en.wikipedia.org/wiki/Qubit">Qubit</a>