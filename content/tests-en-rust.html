Mientras los programas no puedan verificarse de forma matemática de forma sencilla, la única manera de asegurarse que un programa más o menos funciona es con tests. Rust soporta tests de forma nativa. Gracias a la directiva <strong>#[test]</strong>.<br><h2>Definiendo una función de test</h2><br>Una función de test es cualquiera que lleve la directiva <strong>#[test]</strong>. Normalmente, estos tests se dejan dentro de un módulo con la directiva <strong>#[cfg(test)]</strong>.<br><br><pre class="lang:rust decode:true"><br>fn suma(a: i32,b: i32) -&gt; i32{<br>    a+b<br>}<br><br>#[cfg(test)]<br>mod test{<br><br>    #[test]<br>    fn suma(){<br>        assert_eq!(super::suma(4,5),9);<br>    }<br>}<br></pre><br><br>La macro <strong>assert_eq!</strong> provocará un <strong>panic!</strong> si sus argumentos no coinciden. También es posible hacer fallar los tests llamando a <strong>panic!</strong> manualmente. ¿Cómo se ejecutan estos test te preguntarás? Sencillo, con <strong>cargo test</strong>. Automáticamente Cargo selecciona las funciones de test y las ejecuta todas, generando un informe de tests existosos y tests que han fallado.<br><br><a href="https://files.adrianistan.eu/CargoTest.png"><img class="aligncenter size-full wp-image-869" src="https://files.adrianistan.eu/CargoTest.png" alt="" width="505" height="125" /></a>Obviamente, existen más opciones dentro de los tests. <strong>assert!</strong> comprobará que una expresión sea <strong>true</strong>. <strong>#[should_panic]</strong> se deberá indicar en aquellas funciones de test en lo que lo correcto sea que ocurra un <strong>panic!</strong>. Por otro lado, la trait <strong>Debug</strong> es interesante.<br><br>Es posible ejecutar tests de forma manual, con <em>cargo test NOMBRE_TEST<strong>.</strong></em><br><br>&nbsp;