En este apartado vamos a tratar uno de los temas más densos de Rust, que son las estructuras, los traits y la orientación a objetos en general. Antes de empezar conviene hacerse una pregunta.<br><h2>¿Es Rust orientado a objetos?</h2><br>La respuesta no es unánime. Bajo ciertas definiciones lo es, bajo otras no. Lo cierto es que aquí vamos a suponer que lo es, aunque no implementa <strong>clases</strong> y <strong>herencia</strong>.<br><h2>Structs en Rust</h2><br>Antes de avanzar a los objetos, vamos a ir con los <strong>structs</strong> o estructuras, similares a las que podemos tener en C. Las estructuras son datos agrupados por clave-valor.<br><br><pre class="lang:rust decode:true"><br>struct Punto{<br>    x: i32,<br>    y: i32<br>}<br><br>struct Rectangulo{<br>    origen: Punto,<br>    ancho: i32,<br>    alto: i32<br>}<br><br>fn main(){<br>    let p = Punto {x: 50, y: 50};<br>    println!(&quot;Punto X: {}&quot;,p.x);<br>}<br></pre><br><br>Se crean con la sintaxis de llave. Hasta aquí todo nada raro. Pero en Rust, las estructuras pueden y deben llevar asociado métodos. Estos métodos se definen en las <strong>traits</strong>. Piensa en ello como si fuesen interfaces. No obstante, algunas <strong>trait</strong><strong>s</strong> pueden tener implementación automática. Estas <strong>traits</strong> las llamaremos <strong>derivables</strong>. Usando la anotación <strong>#[derive()]</strong> podemos indicarle a una estructura que derive de una <strong>trait</strong>. ¿Recuerdas las traits <strong>Clone</strong> y <strong>Copy</strong>? Son de este tipo y salvo que queramos cosas más especiales, con hacer una anotación nos bastará. ¿No te parece que Punto es una estructura que debe ser copiada en vez de movida? Pues simplemente añadimos las <strong>traits</strong> correspondientes.<br><br><pre class="lang:rust decode:true"><br>#[derive(Copy,Clone)]<br>struct Punto{<br>    x: i32,<br>    y: i32<br>}<br><br>struct Rectangulo{<br>    origen: Punto,<br>    ancho: i32,<br>    alto: i32<br>}<br><br>fn main(){<br>    let p = Punto {x: 50, y: 50};<br>    println!(&quot;Punto X: {}&quot;,p.x);<br>}<br></pre><br><br>Así, hemos modificado el comportamiento del <strong>struct</strong>. Además, hemos ganado métodos en la estructura. Ahora podemos hacer p.clone() y obtener una copia. Esto ha sido gracias a la trait <strong>Clone</strong>, la cuál es necesaria para los elementos que quieran ser <strong>Copy</strong>. Esto además significa que podremos pasar la estructura a todas las funciones con genericidad cuya única condición sea que implementemos <strong>Copy.</strong><br><h2>Métodos asociados a la estructura</h2><br>Hemos visto que <strong>Clone</strong> ha añadido un método a la estructura, como si fuese una clase de la que hubiérmamos heredado. Nosotros también podemos definir métodos asociados a la estructura. Se hace con la palabra reservada <strong>impl</strong>.<br><br><pre class="lang:rust decode:true"><br>#[derive(Copy,Clone)]<br>struct Punto{<br>    x: i32,<br>    y: i32<br>}<br><br>struct Rectangulo{<br>    origen: Punto,<br>    ancho: i32,<br>    alto: i32<br>}<br><br>impl Rectangulo{<br>    pub fn area(&amp;self) -&gt; i32{<br>        self.ancho*self.alto<br>    }<br>}<br><br>fn main(){<br>    let p = Punto {x: 50, y: 50};<br>    println!(&quot;Punto X: {}&quot;,p.x);<br>    let rectangulo = Rectangulo {origen: p,ancho: 20, alto: 20};<br>    println!(&quot;Área: {}&quot;,rectangulo.area());<br>}<br></pre><br><br>Aquí hemos definido el método area asociado a Rectangulo. Es importante destacar que aunque parezca una definición de clase, aquí no hay herencia posible y tampoco hay constructores. El primer argumento de la función area es <strong>self</strong>, o lo que es lo mismo, una referencia a la propia estructura.<br><br>Además vemos <strong>pub</strong>, lo que indica que es un método público.<br><br>Como hemos dicho, hay ciertas <strong>traits</strong> que se autoimplementan, pero otras requieren de código de integración. Vamos a implementar dos <strong>traits</strong> en Rectangulo, <strong>PartialOrd</strong> para las comparaciones y <strong>std::fmt::Display</strong> para definir que se debe mostrar cuando hagamos <strong>println!</strong> a Rectangulo. <strong>PartialOrd</strong> a su vez requiere <strong>PartialEq</strong> presente.<br><br><pre class="lang:rust decode:true"><br>use std::cmp::Ordering;<br><br>#[derive(Copy,Clone)]<br>struct Punto{<br>    x: i32,<br>    y: i32<br>}<br><br>struct Rectangulo{<br>    origen: Punto,<br>    ancho: i32,<br>    alto: i32<br>}<br><br>impl Rectangulo{<br>    pub fn area(&amp;self) -&gt; i32{<br>        self.ancho*self.alto<br>    }<br>}<br><br>impl PartialEq for Rectangulo{<br>    fn eq(&amp;self,other: &amp;Rectangulo) -&gt; bool{<br>        self.area() == other.area()<br>    }<br>}<br><br>impl PartialOrd for Rectangulo{<br>    fn partial_cmp(&amp;self, other: &amp;Rectangulo) -&gt; Option&lt;Ordering&gt;{<br>        if self.area() == other.area() {<br>            Some(Ordering::Equal)<br>        }else if self.area() &gt; other.area() {<br>            Some(Ordering::Greater)<br>        }else{<br>            Some(Ordering::Less)<br>        }<br>    }<br>}<br><br>impl std::fmt::Display for Rectangulo{<br>    fn fmt(&amp;self,f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result{<br>        write!(f,&quot;Origen: ({},{}) - Area: {}&quot;,self.origen.x,self.origen.y,self.area())<br>    }<br><br>}<br><br>fn main(){<br>    let p = Punto {x: 50, y: 50};<br>    println!(&quot;Punto X: {}&quot;,p.x);<br>    let r1 = Rectangulo {origen: p,ancho: 20, alto: 20};<br>    println!(&quot;{}&quot;,r1);<br>    let r2 = Rectangulo {origen: Punto{x: 3, y: 4}, ancho: 30, alto: 30};<br>    println!(&quot;{}&quot;,r2);<br>    if r1 &lt; r2 {<br>        println!(&quot;r2 es más grande&quot;);<br>    }<br><br>}<br></pre><br><br>Aquí ya estamos viendo código Rust en estado puro. Sin embargo todavía no hemos visto como crear <strong>traits</strong> nosotros mismos.<br><h2>Traits</h2><br>Una <strong>trait</strong> es similar a una interfaz y deben de ser usadas mediante la composición, no la herencia. Piensa como si el objeto estuviese hecho con piezas de puzzle. Unas le dan una funcionalidad, otras otra y junt con código propio, se consigue crear un objeto completo. Así funciona la POO en Rust.<br><br>Imagina que existe la <strong>trait</strong> Pintable. Podremos crear métodos que admitan mediante genericidad restringida solo a objetos que implementen Pintable. Y si queremos que Rectangulo sea uno de ellos solo hay que implementar las funciones de Pintable sin definir. Pero Pintable puede incluir métodos ya hecho que funcionan con independencia del objeto en cuestión. Esos métodos pueden ser reescritos si creemos conveniente.<br><br><pre class="lang:rust decode:true"><br>impl Pintable for Rectangulo{<br>    fn pintar(&amp;self) {<br>        // pintar rectangulo<br>    }<br>}<br><br>trait Pintable{<br>    fn pintar(&amp;self);<br>    fn limpiar(){<br>        // limpiar pantalla<br>    }<br>}<br></pre><br><br>Con esto acabamos un capítulo muy importante del tutorial. En el siguiente hablaremos de algo que ya se ha dejado ver como es Option y Result y trataremos la gestión de errores.<br><br>&nbsp;