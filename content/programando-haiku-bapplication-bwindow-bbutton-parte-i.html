Hoy voy a comenzar una serie de tutoriales donde explicaré la programación de una apliación en Haiku. Para ello vamos a usar C++ y la BeAPI. Siempre que tengais cualquier duda podéis visitar la documentación oficial: tanto la antigua de BeOS en el <a href="https://www.haiku-os.org/legacy-docs/bebook/">BeBook</a> y la nueva de Haiku en <a href="https://api.haiku-os.org/">Haiku API</a>. Aun así hay APIs nuevas que todavía no aparecen documentadas. En ese caso hay que recurrir al código fuente.<br><h2 id="librerasenhaiku">Librerías en Haiku</h2><br>Haiku (y BeOS) comparte con UNIX muchas características de bajo nivel. El tema de las librerías es uno de ellos. También han de empezar por lib y terminar por .so si son compartidas y .a si son estáticas. Para compilar también se usa GCC. Sin embargo hay una pequeña diferencia con el resto de sistemas UNIX. En UNIX normalmente disponemos de una librería del C, libc y una librería de funciones matemáticas, libm. En Haiku no existe libm, en cambio existen muchas más, libroot y libbe, para interactuar con el sistema de manera básica, libtracker, con funciones relacionadas con el explorador de archivos, libnetwork y libnetapi, con funciones de red, y muchas otras.<br><br>Además la API se divide en Kits, cada Kit se encarga de una tareas diferentes dentro del sistema operativo. AppKit, Game Kit, Interface Kit, Media Kit, Storage Kit, etc... Si queremos usar la funcionalidad de un kit tendremos que revisar que hemos añadido la librería correcta al compilador y que hemos añadido #include dentro del código que lo usemos.<br><h2 id="unholamundo">Un hola mundo</h2><br>Vamos a empezar por lo simple, una aplicación que muestre una ventana y ya.<br><br>Creamos un archivo de C++, será el punto de inicio de nuestra aplicación. Como sabéis, el punto de inicio de un programa de C o C++ es la función main.<br><br><pre class="lang:c++ decode:true"><br>int main(int argc, char** argv)<br>{<br>	AplicacionPrueba app;<br>    return app.Run();<br>}<br></pre><br><br>Hemos creado un objeto llamado app del tipo AplicacionPrueba y después hemos ejecutado la aplicación. AplicacionPrueba tiene que ser del tipo BApplication. Es la clase básica de todas las aplicaciones Haiku/BeOS. BApplication provee de mensajería entre los distintos procesos del programa (hay que tener en cuenta que BeOS se diseñó pensando en el multiproceso). Vamos a ver como definimos AplicacionPrueba<br><br><pre class="lang:c++ decode:true"><br>#include &lt;AppKit.h&gt;<br><br>class AplicacionPrueba : public BApplication {<br>	public:<br>    	VentanaPrueba* ventana;<br>    	AplicacionPrueba() : BApplication(&quot;application/x-applicion-prueba&quot;){<br>        	ventana = new VentanaPrueba();<br>            ventana-&gt;Show();<br>        }<br>};<br></pre><br><br>Las <strong>Application</strong> necesitan un MIME type, al igual que se usa para indicar los tipos de archivo. No es necesario que sea real. Además hemos creado un objeto VentanaPrueba y la mostramos. VentanaPrueba es del tipo <strong>BWindow</strong> y es la ventana básica de Haiku, lo que vemos. Veamos la definición:<br><br><pre class="lang:c++ decode:true"><br>class VentanaPrueba : public BWindow{<br>	public:<br>    	VentanaPrueba() : BWindow(BRect(100,100,900,700),&quot;Mi ventana&quot;, B_TITLED_WINDOW,0){<br>         // iniciar ventana<br>        }<br>        bool QuitRequested(){<br>        	be_app_messenger.SendMessage(B_QUIT_REQUESTED);<br>            return BWindow::QuitRequested();<br>        }<br>        void MessageReceived(BMessage* msg){<br>        	switch(msg-&gt;what){<br>            	default:<br>                	BWindow::MessageReceived(msg);<br>            }<br>        }<br>};<br></pre><br><br><strong>BWindow</strong> necesita un tamaño, que es indicado con BRect, un título, un estilo (por defecto es B<em>TITLED</em>WINDOW, pero podemos tener ventanas sin bordes o modal) y opciones varias. En las opciones varias podemos especificar que al cerrar la ventana se cierre la aplicación (B<em>QUIT</em>ON<em>WINDOW</em>CLOSE), que el usuario no pueda cambiar su tamaño (B<em>NOT</em>RESIZABLE), que no se pueda minimizar (B<em>NOT</em>MINIMIZABLE) y otras opciones por el estilo.<br><br>Además dentro de la clase hemos definido dos funciones virtuales, es decir, que tienen implementación por defecto de la clase padre, BWindow, pero nosotros podemos modificar su comportamiento.<br><br><strong>QuitRequested</strong> es llamada cuando algo pide el cierre de la ventana. El objeto global <strong>be<em>app</em>messenger</strong> es del tipo BApplication, pero está definido en todos los puntos de nuestra aplicación sin que nosotros hagamos nada. Gracias a este objeto podemos enviar mensajes entre procesos. En este caso enviamos el mensaje a la aplicación de B<em>QUIT</em>REQUESTED. Y luego llamamos a la función sin modificar.<br><br><strong>MessageReceived</strong> es muy importante. Se encarga de procesar todos los mensajes que recibe la ventana. Para distinguir los mensajes (que son del tipo BMessage) tenemos que inspeccionar la propiedad <strong>what</strong>. Se trata de un valor de tipo <strong>uint32</strong>. Hay algunos ya definidos por el sistema como B<em>QUIT</em>REQUESTED pero nosotros podemos definir más. Veremos más tarde como. De momento simplemente devolvemos el procesado de mensajes a BWindow padre.<br><br>Con esto ya podemos compilar.<br><pre><code>gcc -o AplicacionPrueba app.cpp -lbe -lroot </code></pre><br><h2 id="aadiendobviewbbuttonybgrouplayout">Añadiendo BView, BButton y BGroupLayout</h2><br>Ahora vamos a añadir cosas a nuestra ventana sosa. Ponemos una vista dentro de la ventana. Las vistas en Haiku son muy potentes pero eso lo trataré en otro momento. A esa vista le añadiremos un botón.<br><br><pre class="lang:c++ decode:true"><br>VentanaPrueba() : BWindow(BRect(100,100,900,700),&quot;Mi ventana&quot;, B_TITLED_WINDOW,0){<br>         // iniciar ventana<br>         BGroupLayout* sizer = new BGroupLayout(B_HORIZONTAL);<br>         BView* panel = new BView(Bounds(), NULL, B_FOLLOW_ALL_SIDES,<br>                           B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE |<br>                               B_FRAME_EVENTS | B_DRAW_ON_CHILDREN);<br>         panel-&gt;SetViewColor(220, 220, 220);<br>         panel-&gt;SetLayout(sizer);<br>         <br>         BButton* boton = new BButton(&quot;Hola Mundo&quot;,NULL);<br>         <br>         sizer-&gt;AddView(boton);<br>         AddChild(panel);<br>        }<br></pre><br><br>Aquí hemos hecho varias cosas. Por una parte he creado un layout horizontal. Es decir, dispongo el espacio de la ventana de manera horizontal, según se vayan añadiendo elementos lo harán a la derecha. Esto no estaba en BeOS y es particular de Haiku, pero recomiendo usar este sistema pues permite realizar un <strong>responsive design</strong>. Creamos una vista o panel. <strong>Bounds()</strong> indica que cubra todo el espacio disponible. El resto son propiedades de la vista más o menos estándar. Con SetViewColor le podemos poner un color de fondo, y con SetLayout le aplicamos el layout previamente creado.<br><br>Creamos un botón, que es del tipo <strong>BButton</strong>. BButton tiene muchos constructores si revisais la documentación pero este es muy cómodo si usamos el sistema de layouts. Simplemente indicamos el texto que va a mostrar y el mensaje que envía. En este caso NULL pues no vamos a poner ninguno.<br><br><strong>sizer-&gt;AddView()</strong> lo usamos para añadir el botón al layaout y AddChild para añadir la vista a la ventana. Puedes compilar.<br><h2 id="aadiendoeventosmensajeraconbmessagedilogoconbalert">Añadiendo eventos. Mensajería con BMessage. Diálogo con BAlert.</h2><br>Vamos ahora a crear un evento para el botón. Cuando pulsemos el botón mostrará un mensaje al usuario.<br><br>Los eventos se realizan por el sistema de mensajería basado en <strong>BMessage</strong> y BHandler. Para crear un BMessage necesitamos un ID, que es del tipo uint32. Eso es lo mínimo y con eso ya serviría para este caso.<br><br><pre class="lang:c++ decode:true"><br>const uint32 MOSTRAR_DIALOGO = 1;<br><br>...<br><br>BMessage* msg = new BMessage(MOSTRAR_DIALOGO);<br>BButton* boton = new BButton(&quot;Hola mundo&quot;,msg);<br><br>...<br></pre><br><br>Pero los mensajes pueden llevar información adicional de cualquier tipo. Por ejemplo si queremos añadir además una cadena de texto al mensaje usaremos <strong>AddString</strong>.<br><br><pre class="lang:c++ decode:true"><br>msg-&gt;AddString(&quot;NombrePropiedad&quot;,&quot;ValorPropiedad&quot;);<br></pre><br><br>Podremos recuperar el valor en cualquier momento con <strong>FindString</strong>.<br><br>Ahora si vamos a <strong>MessageReceived</strong> podemos añadir código que gestione este tipo de mensaje.<br><br><pre class="lang:c++ decode:true"><br>        void MessageReceived(BMessage* msg){<br>        	switch(msg-&gt;what){<br>            	case MOSTRAR_DIALOGO:<br>                BAlert* alert = new BAlert(&quot;Hola&quot;, &quot;Sabes pulsar el boton, eh?&quot;, &quot;Sip&quot;);<br>                alert-&gt;Go();<br>                break;<br>            	default:<br>                	BWindow::MessageReceived(msg);<br>            }<br>        }<br></pre><br><br>Con un simple case gestionamos el mensaje. Para mostrar un diálogo simple se puede usar <strong>BAlert</strong>. Es muy simple, indicamos el título, el contenido del mensaje y el texto del botón que aparecerá. Y con <strong>Go</strong> lo mostramos.<br><br>Esta ha sido la primera parte del tutorial. Os ha gustado. Hay algo que no haya quedado claro. Comentádmelo.<br><br><pre class="lang:c++ decode:true"><br>#include &lt;AppKit.h&gt;<br>#include &lt;InterfaceKit.h&gt;<br>#include &lt;Layout.h&gt;<br>#include &lt;GroupLayout.h&gt;<br><br>const uint32 MOSTRAR_DIALOGO = 1;<br><br>class AplicacionPrueba : public BApplication {<br>	public:<br>    	VentanaPrueba* ventana;<br>    	AplicacionPrueba() : BApplication(&quot;application/x-applicion-prueba&quot;){<br>        	ventana = new VentanaPrueba();<br>            ventana-&gt;Show();<br>        }<br>};<br><br>class VentanaPrueba : public BWindow{<br>	public:<br>VentanaPrueba() : BWindow(BRect(100,100,900,700),&quot;Mi ventana&quot;, B_TITLED_WINDOW,0){<br>         // iniciar ventana<br>         BGroupLayout* sizer = new BGroupLayout(B_HORIZONTAL);<br>         BView* panel = new BView(Bounds(), NULL, B_FOLLOW_ALL_SIDES,<br>                           B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE |<br>                               B_FRAME_EVENTS | B_DRAW_ON_CHILDREN);<br>         panel-&gt;SetViewColor(220, 220, 220);<br>         panel-&gt;SetLayout(sizer);<br>         <br>         BMessage* msg = new BMessage(MOSTRAR_DIALOGO);<br>         BButton* boton = new BButton(&quot;Hola Mundo&quot;,msg);<br>         <br>         sizer-&gt;AddView(boton);<br>         AddChild(panel);<br>        }<br>        bool QuitRequested(){<br>        	be_app_messenger.SendMessage(B_QUIT_REQUESTED);<br>            return BWindow::QuitRequested();<br>        }<br>        void MessageReceived(BMessage* msg){<br>        	switch(msg-&gt;what){<br>            	case MOSTRAR_DIALOGO:<br>                BAlert* alert = new BAlert(&quot;Hola&quot;, &quot;Sabes pulsar el boton, eh?&quot;, &quot;Sip&quot;);<br>                alert-&gt;Go();<br>                break;<br>            	default:<br>                	BWindow::MessageReceived(msg);<br>            }<br>        }<br>};<br><br>int main(int argc, char** argv)<br>{<br>	AplicacionPrueba app;<br>    return app.Run();<br>}<br></pre>