Hoy en día muchas webs se diseñan con Node.js. Es una solución fantástica para respuestas rápidas pero numerosos benchmarks han demostrado que su rendimiento empeora en respuestas complejas. Estos mismos benchmarks recomiendan usar Java o .NET si preveemos que nuestra aplicación web va a generar respuestas complejas. Sin embargo renunciar a las ventajas de Node.js no es del agrado de muchos. Afortunadamente hay otra solución, usar Rust. Todo ello gracias a <a href="https://www.neon-bindings.com/">Neon</a>.<br><br>Con Neon podemos generar módulos para Node.js que son escritos y compilados en Rust con las ventajas que supone desde un punto de vista de rendimiento y con la certeza de que en Rust la seguridad está garantizada.<br><br>Usando Neon puedes desarrollar tu aplicación en Node.js y si alguna parte tiene problemas de rendimiento sustituirla por su equivalente en Rust. Para el ejemplo voy a hacer un módulo de Markdown.<br><h2>Instalando Neon</h2><br>En primer lugar instalamos la herramienta de Neon desde npm.<br><br><pre class="lang:default decode:true"><br>npm install -g neon-cli<br></pre><br><br>Una vez esté instalado podemos usar la herramienta de Neon para construir un esqueleto de módulo. Este esqueleto tendrá dos partes, un punto de entrada para Node.js y otro para Rust.<br><br><pre class="lang:default decode:true"><br>neon new PROYECTO<br></pre><br><br><a href="https://files.adrianistan.eu/NeonNew.png"><img class="aligncenter size-full wp-image-695" src="https://files.adrianistan.eu/NeonNew.png" alt="" width="644" height="367" /></a>Hacemos un npm install como nos indica. Esto no solo obtendrá dependencias de Node.js sino que también se encargará de compilar el código nativo en Rust.<br><h2>El código Node.js</h2><br>Nuestro módulo contiene un archivo de Node.js que sirve de punto de entrada. Allí lo único que se debe hacer es cargar el módulo en Rust y hacer de pegamento. Puede ser algo tan simple como esto:<br><br><pre class="lang:js decode:true"><br>var addon = require(&quot;../native&quot;);<br><br>module.exports = addon; // se exportan todos los métodos del módulo nativo<br></pre><br><br>Aunque si queremos añadir un tratamiento específico también es posible.<br><br><pre class="lang:js decode:true"><br>var addon = require(&quot;../native&quot;);<br><br>module.exports = {<br>    render: function(str){<br>        return addon.render(str);<br>    }<br>}<br></pre><br><br><h2>El código en Rust</h2><br>Nos dirigimos ahora al archivo <em>native/src/lib.rs</em>. Ahí definimos los métodos nativos que va a tener el módulo. Lo hacemos a través de la macro <strong>register_module!</strong>.<br><br><pre class="lang:rust decode:true"><br>register_module!(m,{<br>    m.export(&quot;render&quot;,render)<br>});<br></pre><br><br>Ahora vamos a implementar la función render, que toma el texto en Markdown y lo devuelve en HTML.<br><br><pre class="lang:rust decode:true"><br>fn render(call: Call) -&gt; JsResult&lt;JsString&gt; {<br>    let scope = call.scope; // obtener el contexto<br>    let md: Handle&lt;JsString&gt; = try!(try!(call.arguments.require(scope,0)).check::&lt;JsString&gt;()); // obtener primer argumento como JsString. aquí puede hacerse tratamiento de fallos<br>    let string = md.value(); // Pasar JsString a String<br>    let html: String = markdown::to_html(&amp;string); // usamos la crate markdown para renderizar a html<br>    Ok(JsString::new(scope, &amp;html).unwrap()) // devolvemos un JsString con el contenido del HTML<br>}<br><br></pre><br><br>Las funciones que interactuan con Node deben devolver un JsResult de un tipo JsXXX, por ejemplo, JsString, JsUndefined o JsInteger. Siempre aceptan un argumento llamado de tipo Call que nos da toda la información necesaria y que podemos usar para sacar argumentos. El scope o contexto es muy importante y lo deberemos usar en las funciones que interactúen con Node.<br><h2>Código completo del fichero Rust</h2><br><br><pre class="lang:rust decode:true"><br>#[macro_use]<br>extern crate neon;<br>extern crate markdown;<br><br>use neon::vm::{Call, JsResult};<br>use neon::js::JsString;<br>use neon::mem::Handle;<br><br>fn render(call: Call) -&gt; JsResult&lt;JsString&gt; {<br>    let scope = call.scope;<br>    let md: Handle&lt;JsString&gt; = try!(try!(call.arguments.require(scope,0)).check::&lt;JsString&gt;());<br>    let string = md.value();<br>    let html: String = markdown::to_html(&amp;string);<br>    Ok(JsString::new(scope, &amp;html).unwrap())<br>}<br><br>register_module!(m, {<br>    m.export(&quot;render&quot;, render)<br>});<br></pre><br><br>Y no te olvides de añadir la dependencia <em>markdown</em> al fichero Cargo.toml.<br><h2>Probándolo</h2><br>Es muy fácil probarlo. Con el REPL de Node podemos probar partes del módulo antes de publicarlo a npm.<br><br>Para abrir el REPL ejecuta Node sin argumentos<br><br><pre class="lang:default decode:true"><br>node<br></pre><br><br>E introduce línea por línea lo que quieras probar:<br><br><pre class="lang:default decode:true"><br>var md = require(&quot;./&quot;);<br>md.render(&quot;__Esto es Markdown__&quot;);<br></pre><br><br>Verás el resultado por la pantalla:<br><br><a href="https://files.adrianistan.eu/NodeMd.png"><img class="aligncenter size-full wp-image-696" src="https://files.adrianistan.eu/NodeMd.png" alt="" width="642" height="96" /></a><br><br>Ahora que ya sabemos que funciona podemos publicarlo a npm si queremos con:<br><br><pre class="lang:default decode:true"><br>npm publish<br></pre><br><br>Aunque recuerda revisar antes el fichero package.json para especificar la licencia y la descripción. Una vez esté publicado su uso en un nuevo proyecto será muy sencillo y de forma transparente se compilará el código nativo.<br><br><pre class="lang:js decode:true"><br>var md = require(&quot;rust-markdown&quot;);<br>var http = require('http');<br>var fs = require(&quot;fs&quot;);<br><br>var server = http.createServer((req, res) =&gt; {<br>  fs.readFile(&quot;index.md&quot;,&quot;utf-8&quot;,function(err,data){<br>     var html = md.render(data);<br>     res.statusCode = 200;<br>     res.setHeader('Content-Type', 'text/html');<br>     res.end(html);<br>  });<br>});<br><br>server.listen(8080, &quot;127.0.0.1&quot;, () =&gt; {<br>  console.log(&quot;Server running&quot;);<br>});<br><br><br><br></pre><br>&nbsp;<br><br>&nbsp;