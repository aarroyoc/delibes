<blockquote><em>Este artículo lo escribí para el blog en español <a href="http://blog.desdelinux.net">DesdeLinux</a> el 29 de diciembre de 2013 y ahora lo dejo aquí, en mi blog personal. El artículo está tal cual, sin ninguna modificación desde aquella fecha.</em></blockquote><br>Bienvenidos a otro post sobre como crear nuestro propio sistema operativo, en este caso NextDivel.<br><br>Si retomamos el código del <a href="https://blog.adrianistan.eu/2015/11/26/emulando-linus-torvalds-crea-propio-sistema-operativo-desde-0-i/">primer post</a> al final de todo nos debería haber salido algo como esto:<br><br><img class="alignnone size-full wp-image-80" src="https://files.adrianistan.eu/NextDivel-1.png" alt="NextDivel-1" width="600" height="338" /><br><br>Si esto es correcto podemos continuar. Voy a usar el sistema y la estructura que tengo en GitHub (http://github.com/AdrianArroyoCalle/next-divel) ya que es más cómodo para mí y para vosotros. Como se puede apreciar el texto es un texto básico, no resulta atractiv0. Puede parecer algo más del montón. Pero como dice el dicho, para gustos colores, y en nuestro sistema operativo habrá colores. Los primeros colores que vamos a poder poner van a ser los que definen las tarjetas VGA y son 16:<br><ol><br> 	<li>Negro</li><br> 	<li>Azul</li><br> 	<li>Verde</li><br> 	<li>Cyan</li><br> 	<li>Rojo</li><br> 	<li>Magenta</li><br> 	<li>Marrón</li><br> 	<li>Gris claro</li><br> 	<li>Gris oscuro</li><br> 	<li>Azul claro</li><br> 	<li>Verde claro</li><br> 	<li>Cyan claro</li><br> 	<li>Rojo claro</li><br> 	<li>Magenta claro</li><br> 	<li>Marrón claro</li><br> 	<li>Blanco</li><br></ol><br>Estos colores los vamos a definir en un header para tenerlo más a mano y quizá en un futuro formar parte de la API del sistema. Así creamos el archivo ND_Colors.hpp en el include de NextDivel.<br><br><pre class="lang:c++ decode:true"><br>#ifndef ND_COLOR_HPP<br>#define ND_COLOR_HPP<br><br>typedef enum ND_Color{ <br>	ND_COLOR_BLACK			= 0,<br>	ND_COLOR_BLUE			= 1,<br>	ND_COLOR_GREEN			= 2,<br>	ND_COLOR_CYAN			= 3,<br>	ND_COLOR_RED			= 4,<br>	ND_COLOR_MAGENTA		= 5,<br>	ND_COLOR_BROWN			= 6,<br>	ND_COLOR_LIGHT_GREY		= 7,<br>	ND_COLOR_DARK_GREY		= 8,<br>	ND_COLOR_LIGHT_BLUE		= 9,<br>	ND_COLOR_LIGHT_GREEN	= 10,<br>	ND_COLOR_LIGHT_CYAN		= 11,<br>	ND_COLOR_LIGHT_RED		= 12,<br>	ND_COLOR_LIGHT_MAGENTA	= 13,<br>	ND_COLOR_LIGHT_BROWN	= 14,<br>	ND_COLOR_WHITE			= 15<br><br>} ND_Color;<br>#endif<br></pre><br><br>A su vez vamos a definir nuevas funciones para escribir en pantalla de una manera más cómoda (no, todavía no vamos a implementar printf, sé que lo estais deseando). Crearemos un archivo y su header para un set de funciones relacionadas con la pantalla (ND<em>Screen.cpp y ND</em>Screen.hpp). En ellas vamos a crear funciones para: cambiar el color de las letras y el fondo, escribir frases y letras, limpiar la pantalla y desplazarnos por la pantalla. Seguimos usando las pantallas VGA pero ahora usaremos unos bytes que darán el color. ND_Screen.cpp quedaría como:<br><br><pre class="lang:c++ decode:true"><br>#include &lt;ND_Types.hpp&gt;<br>#include &lt;ND_Color.hpp&gt;<br>#include &lt;ND_Screen.hpp&gt;<br><br>uint16_t *vidmem= (uint16_t *)0xB8000;<br>ND_Color backColour = ND_COLOR_BLACK;<br>ND_Color foreColour = ND_COLOR_WHITE;<br>uint8_t cursor_x = 0;<br>uint8_t cursor_y = 0;<br><br>/**<br> * @brief Gets the current color<br> * @param side The side to get the color<br> * */<br>ND_Color ND::Screen::GetColor(ND_SIDE side)<br>{<br>	if(side==ND_SIDE_BACKGROUND){<br>		return backColour;<br>	}else{<br>		return foreColour;<br>	}<br>}<br>/**<br> * @brief Sets the color to a screen side<br> * @param side The side to set colour<br> * @param colour The new colour<br> * @see GetColor<br> * */<br>void ND::Screen::SetColor(ND_SIDE side, ND_Color colour)<br>{<br>	if(side==ND_SIDE_BACKGROUND)<br>	{<br>		backColour=colour;<br>	}else{<br>		foreColour=colour;<br>	}<br>}<br>/**<br> * @brief Puts the char on screen<br> * @param c The character to write<br> * */<br>void ND::Screen::PutChar(char c)<br>{<br>	uint8_t  attributeByte = (backColour &lt;&lt; 4) | (foreColour &amp; 0x0F);<br>	uint16_t attribute = attributeByte &lt;&lt; 8;<br>	uint16_t *location;<br>	if (c == 0x08 &amp;&amp; cursor_x)<br>	{<br>		cursor_x--;<br>	}else if(c == '\r')<br>	{<br>		cursor_x=0;<br>	}else if(c == '\n')<br>	{<br>		cursor_x=0;<br>		cursor_y=1;<br>	}<br>	if(c &gt;= ' ') /* Printable character */<br>	{<br>		location = vidmem + (cursor_y*80 + cursor_x);<br>		*location = c | attribute;<br>		cursor_x++;<br>	}<br>	if(cursor_x &gt;= 80) /* New line, please*/<br>	{<br>		cursor_x = 0;<br>		cursor_y++;<br>	}<br>	/* Scroll if needed*/<br>	uint8_t attributeByte2 = (0 /*black*/ &lt;&lt; 4) | (15 /*white*/ &amp; 0x0F);<br>	uint16_t blank = 0x20 /* space */ | (attributeByte2 &lt;&lt; 8);<br>	if(cursor_y &gt;= 25)<br>	{<br>       int i;<br>       for (i = 0*80; i &lt; 24*80; i++)<br>       {<br>           vidmem[i] = vidmem[i+80];<br>       }<br><br>       // The last line should now be blank. Do this by writing<br>       // 80 spaces to it.<br>       for (i = 24*80; i &lt; 25*80; i++)<br>       {<br>           vidmem[i] = blank;<br>       }<br>       // The cursor should now be on the last line.<br>       cursor_y = 24;<br>   }<br>}<br>/**<br> * @brief Puts a complete string to screen<br> * @param str The string to write<br> * */<br>void ND::Screen::PutString(const char* str)<br>{<br>	int i=0;<br>	while(str[i]) <br>	{<br>		ND::Screen::PutChar(str[i++]);<br>	}<br>}<br>/**<br> * @brief Cleans the screen with a color<br> * @param colour The colour to fill the screen<br> * */<br> void ND::Screen::Clear(ND_Color colour)<br>{<br>   // Make an attribute byte for the default colours<br>   uint8_t attributeByte = (colour /*background*/ &lt;&lt; 4) | (15 /*white - foreground*/ &amp; 0x0F);<br>   uint16_t blank = 0x20 /* space */ | (attributeByte &lt;&lt; 8);<br><br>   int i;<br>   for (i = 0; i &lt; 80*25; i++)<br>   {<br>       vidmem[i] = blank;<br>   }<br><br>   // Move the hardware cursor back to the start.<br>   cursor_x = 0;<br>   cursor_y = 0;<br>}<br>/**<br> * @brief Sets the cursor via software<br> * @param x The position of X<br> * @param y The position of y<br> * */<br>void ND::Screen::SetCursor(uint8_t x, uint8_t y)<br>{<br>	cursor_x=x;<br>	cursor_y=y;<br>}<br></pre><br><br>El header será muy básico así que no lo incluyo aquí, pero destacar la definición del tipo ND_SIDE<br><br><pre class="lang:c++ decode:true"><br>typedef enum ND_SIDE{<br>		ND_SIDE_BACKGROUND,<br>		ND_SIDE_FOREGROUND<br>}ND_SIDE;<br></pre><br><br>También mencionar que hacemos uso del header ND<em>Types.hpp, este header nos define unos tipos básicos para uint8</em>t, uint16<em>t, etc basado en los char y los int. Realmente este header es el en el estándar C99 y de hecho mi ND</em>Types.hpp es un copia/pega del archivo desde Linux, así que podeis intercambiarlos y no pasaría nada (solo hay definiciones, ninguna función).<br><br>Para probar si este código funciona vamos a modificar el punto de entrada en C del kernel:<br><br><pre class="lang:c++ decode:true"><br>	ND::Screen::Clear(ND_COLOR_WHITE);<br>	ND::Screen::SetColor(ND_SIDE_BACKGROUND,ND_COLOR_WHITE);<br>	ND::Screen::SetColor(ND_SIDE_FOREGROUND,ND_COLOR_GREEN);<br>	ND::Screen::PutString(&quot;NextDivel\n&quot;);<br>	ND::Screen::SetColor(ND_SIDE_FOREGROUND,ND_COLOR_BLACK);<br>	ND::Screen::PutString(&quot;Licensed under GNU GPL v2&quot;);<br></pre><br><br>Y si seguimos estos pasos obtendríamos este resultado<br><br><img class="alignnone size-full wp-image-81" src="https://files.adrianistan.eu/NextDivel-3.png" alt="NextDivel-3" width="600" height="338" /><br><br>Gracias a estas funciones que hemos creado podemos empezar a hacer pequeñas GUI, como por ejemplo un kernel panic que mostraremos cada vez que haya un error irrecuperable. Algo tal que así:<br><br><img class="alignnone size-large wp-image-82" src="https://files.adrianistan.eu/NextDivel-4-1024x578.png" alt="NextDivel-4" width="840" height="474" /><br><br>Y esta pequeña GUI la hicimos solamente con estas funciones:<br><pre class="lang:c++ decode:true"><br>void ND::Panic::Show(const char* error)<br>{<br>	ND::Screen::Clear(ND_COLOR_RED);<br>	ND::Screen::SetColor(ND_SIDE_BACKGROUND, ND_COLOR_WHITE);<br>	ND::Screen::SetColor(ND_SIDE_FOREGROUND, ND_COLOR_RED);<br>	ND::Screen::SetCursor(29,10); //(80-22)/2<br>	ND::Screen::PutString(&quot;NextDivel Kernel Error\n&quot;);<br>	ND::Screen::SetCursor(15,12);<br>	ND::Screen::PutString(error);<br>}<br></pre><br><br>Y aprovecho para daros las gracias por la excelente acogida que tuvo el primer post.