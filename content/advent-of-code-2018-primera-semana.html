Este año, como ya viene siendo habitual, tiene lugar la competición de programación <a href="https://adventofcode.com">Advent of Code</a>. El objetivo es resolver un problema de programación al día, hasta el día de navidad, a modo de un particular calendario de adviento. Este año, como ya no viene siendo tan habitual, me he propuesto hacerlos todos y explicar mis soluciones. Esta semana todos han sido resueltos en Python.<br><br><a href="https://files.adrianistan.eu/AdventCode2018.png"><img class="aligncenter size-full wp-image-1643" src="https://files.adrianistan.eu/AdventCode2018.png" alt="" width="741" height="239" /></a><br><br>Los programas que he usado, así como los enunciados y los datos de entrada que me han tocado (a cada uno le tocan datos diferentes) están en <a href="https://github.com/aarroyoc/advent-of-code-2018">este repositorio de GitHub</a>.<br><h2>Día 1</h2><br>El primer reto que nos proponen es muy sencillo. Se nos pasa un archivo con sumas y restas y tenemos que calcular el resultado final. Pongamos un ejemplo trivial:<br><br><code>+1, +1, -2</code> = 0<br><br>El procesdimiento es sencillo, leer cada operación, extraer el signo, convertir a número y aplicar la operación detectada por el signo.<br><pre class="lang:python decode:true ">def apply_freq(freq):<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    for line in lines:<br>        signo = line[0:1]<br>        numero = int(line[1:])<br>        if signo == "+":<br>            freq += numero<br>        elif signo == "-":<br>            freq -= numero<br>    return freq<br><br>if __name__ == "__main__":<br>    freq = 0<br>    freq = apply_freq(freq)<br>    print("FREQ FINAL: %d" % freq)</pre><br>La segunda parte es más interesante, ya que nos dice que tenemos que aplicar la misma cadena de operaciones de forma indefinida hasta encontrar una resultado repetido.<br><br>Aquí la clave es conocer el funcionamiento de un <a href="https://docs.python.org/3/tutorial/datastructures.html"><strong>Set</strong></a> o conjunto. Se trata de una estructura de datos que no permite elementos repetidos. La idea está en ir almacenando los resultados que van saliendo hasta encontrar uno que ya esté dentro. Al encontrarlo salir e indicarlo.<br><pre class="lang:python decode:true ">FREQS = set()<br><br>def apply_freq(freq):<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    for line in lines:<br>        signo = line[0:1]<br>        numero = int(line[1:])<br>        if signo == "+":<br>            freq += numero<br>        elif signo == "-":<br>            freq -= numero<br>        if freq in FREQS:<br>            return (True,freq)<br>        else:<br>            FREQS.add(freq)<br>    return (False,freq)<br><br>if __name__ == "__main__":<br>    freq = 0<br>    while True:<br>        end,freq = apply_freq(freq)<br>        if end:<br>            break<br>    print("FREQ FINAL: %d" % freq)</pre><br>Aquí viene una anécdota interesante. Estoy haciendo estos retos con unos amigos en un grupo de Telegram y al poco de yo haberlo terminado empezaron a preguntar cuánto tardaba en ejecutarse la segunda parte. Al parecer les iba muy lento, yo sorprendido les dije que había sido instantáneo y que estaba usando Python. Ellos se preguntaban como podía ser, ya que lo habían hecho en C y les estaba tardando varios minutos.<br><br><a href="https://files.adrianistan.eu/Example_of_a_set.svg_.png"><img class="size-full wp-image-1644" src="https://files.adrianistan.eu/Example_of_a_set.svg_.png" alt="" width="562" height="480" /></a> Una representación de un set o conjunto. No puede haber elementos repetidos. No existe orden definido<br><br>La respuesta tiene que ver con el <strong>set</strong>. Yo sinceramente fui a él directamente pero otros compañeros no, y usaron listas y arrays. La búsqueda que realizaban para saber si el elemento estaba dentro era lineal. Comparada con la búsqueda en un set implementado con tabla hash que es constante, el rendimiento es muy inferior. He aquí un ejemplo de como lo más importante de cara a la eficiencia es el algoritmo y las estructuras de datos que usamos para resolver un problema.<br><h2>Día 2</h2><br>El segundo día se nos propone otro problema de dificultad similar. Sobre una lista de palabras tenemos que contar cuantas palabras tienen 2 letras repetidas y 3 letras repetidas, para finalmente multiplicar ambos números.<br><br>En este caso fui bastante pragmático y opté por usar la clase <a href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter</a> de Python. Counter cuenta cuantas veces aparece una letra y lo deja en un diccionario. Podemos ignorar las claves, ya que lo único que tenemos que hacer es buscar en los valores si está el 3 y el 2, y si es así, sumar uno a nuestro contador.<br><pre class="lang:python decode:true">from collections import Counter<br><br>twice = 0<br>triple = 0<br><br>with open("input.txt") as f:<br>    lines = f.readlines()<br>for line in lines:<br>    c = Counter(line)<br>    if 3 in c.values():<br>        triple += 1<br>    if 2 in c.values():<br>        twice += 1<br>total = twice*triple<br>print("CHECKSUM: %d" % total)</pre><br>La segunda parte ya es más interesante. Se nos pide que la misma lista de palabras, encontremos las dos palabras que solo se diferencian en una letra (se tiene en cuenta el orden). Aquí el algoritmo es un poco más lento ya que para cada palabra la comparamos con el resto de palabras, hasta encontrar aquella que efectivamente tiene un cambio de únicamente una palabra.<br><br>Para ello hace falta una función que nos diga cuantas palabras hay de diferencia entre dos palabras, que es bastante sencillita.<br><pre class="lang:python decode:true ">def changes(base,word):<br>    changes = 0<br>    for i,letter in enumerate(base.strip()):<br>        if not letter == word[i]:<br>            changes += 1<br>    return changes<br><br>def find_similar(lines):<br>    for base in lines:<br>        for word in lines:<br>            if changes(base,word) == 1:<br>                return (base,word)<br><br>with open("input.txt") as f:<br>    lines = f.readlines()<br>base,word = find_similar(lines)<br>final = str()<br>for i,letter in enumerate(base.strip()):<br>    if letter == word[i]:<br>        final += letter<br>print("FINAL %s"%final)</pre><br>Una vez tengamos las dos palabras que solo se diferencian en una letra, hacemos un bucle similar al usado para encontrarlas, solo que esta vez para formar la palabra con todas las letras que tienen en común, ignorando la diferente.<br><h2>Día 3</h2><br>En el día 3 nos proponen un problema muy interesante. Tenemos una lista de parcelas rectangulares, definidas por la posición de su esquina superior-izquierda y su ancho y alto, todo en metros. Para la primera parte tenemos que encontrar cuantos metros cuadrados del universo ficticio están en dos o más parcelas a la vez.<br><br>Lo primero que hay que hacer es leer la entrada, que esta vez ya no es tan trivial. <a href="https://docs.python.org/3/howto/regex.html">Un simple RegEx</a> nos permite obtener toda la información de forma sencilla.<br><pre class="lang:python decode:true ">from dataclasses import dataclass<br>import re<br><br>@dataclass<br>class Claim():<br>    id: int<br>    x: int<br>    y: int<br>    width: int<br>    height: int<br><br>def read_file():<br>    claims = []<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    prog = re.compile(r"#([0-9]+) @ ([0-9]+),([0-9]+): ([0-9]+)x([0-9]+)");<br>    for line in lines:<br>        result = prog.match(line.strip())<br>        claim = Claim(<br>            id=int(result.group(1)),<br>            x=int(result.group(2)),<br>            y=int(result.group(3)),<br>            width=int(result.group(4)),<br>            height=int(result.group(5))<br>        )<br>        claims.append(claim)<br>    return claims<br></pre><br>Para el algoritmo en sí, vamos a usar <strong>defaultdict</strong>. La idea es tener una t<a href="https://es.wikipedia.org/wiki/Tabla_hash">abla hash</a>, cuya clave sean las coordenadas del mundo y su valor, el número de parcelas que estan sobre ella. Usamos defaultdict para que por defecto cualquier coordenada que no existiese con anterioridad tenga valor 0.<br><br>Así pues vamos a recorrer todas las parcelas y para cada parcela vamos a visitar todos los metros cuadrados que contiene en la tabla hash, sumando 1 para indicar que ese metro cuadrado pertenece a una parcela (más).<br><pre class="lang:python decode:true ">if __name__ == "__main__":<br>    claims = read_file()<br>    area = defaultdict(lambda: 0)<br>    for claim in claims:<br>        for i in range(claim.x,claim.x+claim.width):<br>            for j in range(claim.y,claim.y+claim.height):<br>                area[(i,j)] += 1<br>    overlaps = count_overlaps(area)<br>    print("Overlaps: %d" % overlaps)</pre><br>La segunda parte nos indica que solo existe una parcela que no esté invadida por otra parcela. Hay que buscar cuál es e informar del ID que tiene. Para esto he simplemente vuelto a recorrer cada parcela comprobando si tienen algún metro cuadrado con uso por más de 1 parcela. Si para una parcela no se encuentran metros compartidos, automáticamente se devuelve su ID (ya que solo hay una parcela de estas características).<br><br>El código completo es el siguiente:<br><pre class="lang:python decode:true ">from dataclasses import dataclass<br>from collections import defaultdict<br>import re<br><br>@dataclass<br>class Claim():<br>    id: int<br>    x: int<br>    y: int<br>    width: int<br>    height: int<br><br>def read_file():<br>    claims = []<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    prog = re.compile(r"#([0-9]+) @ ([0-9]+),([0-9]+): ([0-9]+)x([0-9]+)");<br>    for line in lines:<br>        result = prog.match(line.strip())<br>        claim = Claim(<br>            id=int(result.group(1)),<br>            x=int(result.group(2)),<br>            y=int(result.group(3)),<br>            width=int(result.group(4)),<br>            height=int(result.group(5))<br>        )<br>        claims.append(claim)<br>    return claims<br><br>def count_overlaps(area):<br>    overlaps = 0<br>    for overlap in area.values():<br>        if overlap &gt; 1:<br>            overlaps += 1<br>    return overlaps<br><br>def find_nonoverlaping(claims,area):<br>    for claim in claims:<br>        overlaps = False<br>        for i in range(claim.x,claim.x+claim.width):<br>            for j in range(claim.y,claim.y+claim.height):<br>                if area[(i,j)] &gt; 1:<br>                    overlaps = True<br>        if not overlaps:<br>            return claim.id <br><br>if __name__ == "__main__":<br>    claims = read_file()<br>    area = defaultdict(lambda: 0)<br>    for claim in claims:<br>        for i in range(claim.x,claim.x+claim.width):<br>            for j in range(claim.y,claim.y+claim.height):<br>                area[(i,j)] += 1<br>    overlaps = count_overlaps(area)<br>    print("Overlaps: %d" % overlaps)<br>    non_overlaping = find_nonoverlaping(claims,area)<br>    print("ID: %d" % non_overlaping)</pre><br>En esta segunda parte, tengo la intuición de que existe una manera más eficiente de hacerlo, pero todavía no he encontrado esa solución más eficiente.<br><h2>Día 4</h2><br>El problema del día 4, aunque aparentemente distinto al anterior, tiene muchas cosas en común y mi forma de resolverlo fue bastante parecida.<br><br>Se nos pide que sobre un registro de todas las noches identifiquemos el guardia que duerme más horas, y posteriormente su minuto preferido para quedarse dormido.<br><br>En primer lugar, la entrada de texto ya es bastante más compleja, pero con unos simples regex se puede analizar rápidamente, al menos para extraer la información que necesitamos. Aquí conviene prestar atención a que los registros de dormirse y despertarse ya que todos ocurren a la misma hora, luego lo único importante son los minutos. Otro detalle respecto a la entrada es que nos indican que está desordenada, sin embargo el formato de representación de la fecha que nos dan (parecido al ISO), se ordena cronológicamente simplemente con una ordenación alfabética.<br><br>La idea es muy similar a la del algoritmo anterior, primero tenemos una tabla hash con todos los guardias. Allí almacenamos otra tabla hash con los minutos de la hora y ponemos un cero si nunca se han dormido en ese minuto. Si usamos <strong>defaultdict</strong>, como en el código anterior, el código se simplifica bastante. En definitiva estamos usando dos tablas hash en vez de una y aplicar la misma idea de sumar 1, salvo que esta vez con el tiempo en vez del espacio (aunque Einstein vino a decir que eran cosas muy parecidas).<br><pre class="lang:python decode:true ">import re<br>from collections import defaultdict<br><br>def read_file():<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    lines.sort()<br>    return lines<br><br><br>if __name__ == "__main__":<br>    lines = read_file()<br>    guard_prog = re.compile(r"[* ]+Guard #([0-9]+)")<br>    time_prog = re.compile(r"\[([0-9]+)-([0-9]+)-([0-9]+) ([0-9]+):([0-9]+)")<br>    current_guard = 0<br>    start_time = 0<br>    end_time = 0<br>    timetable = defaultdict(lambda: defaultdict(lambda: 0))<br>    for line in lines:<br>        # Hay tres tipos de líneas<br>        # Guardia, Sleep, Wake<br>        a = guard_prog.match(line.split("]")[1])<br>        if a != None:<br>            current_guard = a.group(1)<br>        elif "falls" in line:<br>            t = time_prog.match(line.split("]")[0])<br>            start_time = int(t.group(5))<br>        elif "wakes" in line:<br>            t = time_prog.match(line.split("]")[0])<br>            end_time = int(t.group(5))<br>            for i in range(start_time,end_time):<br>                timetable[current_guard][i] += 1<br><br>    # Calcular horas dormido<br>    max_guard = ""<br>    max_guard_sleeptime = 0<br>    for guard in timetable:<br>        s = sum(timetable[guard].values())<br>        if s &gt; max_guard_sleeptime:<br>            max_guard_sleeptime = s<br>            max_guard = guard<br><br>    print("El guardia que más duerme es el %s con %d minutos" % (max_guard,max_guard_sleeptime))<br><br>    #Calcular minuto ideal<br>    max_minute = 0<br>    max_minute_times = 0<br>    for minute in timetable[max_guard]:<br>        if timetable[max_guard][minute] &gt; max_minute_times:<br>            max_minute = minute<br>            max_minute_times = timetable[max_guard][minute]<br><br>    print("El guardia duerme más en el minuto %d (%d veces)" % (max_minute,max_minute_times))<br><br>    print("CHECKSUM %d" % (max_minute*int(max_guard)))<br></pre><br>Posteriormente se recorren estas tablas hash para calcular lo pedido.<br><br>La segunda parte nos pide algo similar pero no idéntico, el guardia que se ha quedado dormido más veces en el mismo minuto (e indicar que minuto es).<br><br>La estructura de datos es exactamente la misma y solamente añadimos otro bucle para que busque este otro dato:<br><pre class="lang:python decode:true ">import re<br>from collections import defaultdict<br><br>def read_file():<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    lines.sort()<br>    return lines<br><br><br>if __name__ == "__main__":<br>    lines = read_file()<br>    guard_prog = re.compile(r"[* ]+Guard #([0-9]+)")<br>    time_prog = re.compile(r"\[([0-9]+)-([0-9]+)-([0-9]+) ([0-9]+):([0-9]+)")<br>    current_guard = 0<br>    start_time = 0<br>    end_time = 0<br>    timetable = defaultdict(lambda: defaultdict(lambda: 0))<br>    for line in lines:<br>        # Hay tres tipos de líneas<br>        # Guardia, Sleep, Wake<br>        a = guard_prog.match(line.split("]")[1])<br>        if a != None:<br>            current_guard = a.group(1)<br>        elif "falls" in line:<br>            t = time_prog.match(line.split("]")[0])<br>            start_time = int(t.group(5))<br>        elif "wakes" in line:<br>            t = time_prog.match(line.split("]")[0])<br>            end_time = int(t.group(5))<br>            for i in range(start_time,end_time):<br>                timetable[current_guard][i] += 1<br><br>    # Calcular horas dormido<br>    max_guard = ""<br>    max_guard_sleeptime = 0<br>    for guard in timetable:<br>        s = sum(timetable[guard].values())<br>        if s &gt; max_guard_sleeptime:<br>            max_guard_sleeptime = s<br>            max_guard = guard<br><br>    print("El guardia que más duerme es el %s con %d minutos" % (max_guard,max_guard_sleeptime))<br><br>    #Calcular minuto ideal<br>    max_minute = 0<br>    max_minute_times = 0<br>    for minute in timetable[max_guard]:<br>        if timetable[max_guard][minute] &gt; max_minute_times:<br>            max_minute = minute<br>            max_minute_times = timetable[max_guard][minute]<br><br>    print("El guardia duerme más en el minuto %d (%d veces)" % (max_minute,max_minute_times))<br><br>    print("CHECKSUM %d" % (max_minute*int(max_guard)))<br><br>    # El guardia que ha estado un minuto concreto mas veces dormido<br>    max_guard = ""<br>    guard_minute = 0<br>    guard_minutes = 0<br>    for guard in timetable:<br>        for minute in timetable[guard]:<br>            if timetable[guard][minute] &gt; guard_minutes:<br>                max_guard = guard<br>                guard_minute = minute<br>                guard_minutes = timetable[guard][minute]<br>    print("El guardia %s se ha dormido en el minuto %d (%d veces)" % (max_guard,guard_minute,guard_minutes))<br>    print("CHECKSUM %d" % (guard_minute*int(max_guard)))</pre><br>En este caso, la segunda parte apenas ha implicado modificaciones, siendo la estructura de datos subyacente intacta.<br><h2>Día 5</h2><br>Este día se nos propone un reto aparentemente sencillo, pero cuya resolución puede ser muy lenta o rápida dependiendo de como lo hagamos. He de decir, que mi solución era muy lenta, extremadamente y tuve que mirar como lo habían hecho otras personas para entender como se podía optimizar.<br><br>La primera tarea consiste en reducir unas cadenas de reactivos. La norma es que si hay una letra minúscula y una mayúscula al lado, se pueden quitar. Se nos pide la longitud de la cadena de reactivos después de reducirlo al máximo.<br><pre class="lang:python decode:true ">if __name__ == "__main__":<br><br>    with open("input.txt") as f:<br>        line = f.readline()<br>    <br>    line = list(line.strip())<br>    end = False<br>    while not end:<br>        end = True<br>        for i in range(1,len(line)):<br>            if line[i-1] != line[i] and line[i-1].lower() == line[i].lower():<br>                end = False<br>                del line[i-1]<br>                del line[i-1]<br>                break<br>    print("Units: %d" % (len(line)))</pre><br>La versión original consistía en ir realizando elimaciones sobre la propia lista. Todo ello en un bucle que para cuando en una iteración no se modifica la cadena. Esto es extremadamente ineficiente. Tomando el código de <a href="https://github.com/petertseng/adventofcode-rb-2018/blob/master/05_alchemical_reduction.rb">Peter Tseng</a>, existe una opción mejor. Se puede ir haciendo un string nuevo poco a poco comprobando si la nueva letra reacciona con la última del string nuevo. Esto tiene la ventaja de que solo hace falta una iteración para cubrir todas las reacciones. La versión mejorada es la siguiente:<br><pre class="lang:python decode:true">def react(line):<br>    new = list()<br>    for c in line.strip():<br>        if len(new) &gt; 0 and c != new[-1] and c.lower() == new[-1].lower():<br>            del new[-1]<br>        else:<br>            new += c<br>    return new<br><br>if __name__ == "__main__":<br><br>    with open("input.txt") as f:<br>        line = f.readline()<br>    line = react(line)<br>    print("Units: %d" % (len(line)))</pre><br>Para la segunda parte se nos pida que encontremos la letra, que si eliminamos del compuesto antes de empezar la reacción, genera la cadena más pequeña. Hay que probar con todas las letras, mención especial a <strong>string.ascii_lowercase</strong> que tiene un iterador con todas las letras minúsculas del alfabeto inglés. Y posteriormente, encontrar la que de resultado inferior. Como no nos pide la letra, solamente la longitud que tendría esa cadena, no tenemos que pasar información extra.<br><pre class="lang:python decode:true">import string<br><br>def react(line):<br>    new = list()<br>    for c in line:<br>        if len(new) &gt; 0 and c != new[-1] and c.lower() == new[-1].lower():<br>            del new[-1]<br>        else:<br>            new += c<br>    return new<br><br>def min_react(line,letter):<br>    line = [c for c in line if c.lower() != letter]<br>    return len(react(line))<br><br>if __name__ == "__main__":<br><br>    with open("input.txt") as f:<br>        line = f.readline()<br>    l = react(line)<br><br>    print("Units: %d" % (len(l)))<br>    <br>    m = min([min_react(line,char) for char in string.ascii_lowercase])<br>    print("Minimum length: %d" % (m))</pre><br><h2>Día 6</h2><br>Esto se empieza a complicar. El día 6 nos pide que sobre una cuadrícula encontremos qué punto de control está más cercano a esa posición. De los puntos de control que un número de cuadrículas cercanas finitas, encontrar cuántas cuadrículas tiene el punto de control con más cuadrículas asociadas. Para saber la distancia de una cuadrícula al punto de control se usa la<a href="https://es.wikipedia.org/wiki/Geometr%C3%ADa_del_taxista"> distancia de Manhattan</a>.<br><br>Lo primero es reconocer que puntos de control tienen áreas infinitas, para no tenerlos en cuenta.<br><br>Para ello, voy a calcular dos puntos extremos (esquina superior izquierda y esquina inferior derecha), dentro del rectángulo que forman estos puntos están contenidos todos los puntos de control. El objetivo es calcular las distancias de las cuadrículas justo por fuera de este rectángulo. Las cuadrículas que estén más lejos de eso no van a cambiar de punto de control, ya que el más cercano en el borde seguirá siendo el más cercano en el borde + N, ya que no hay más puntos de control fuera.<br><br>Posteriormente, empezamos a calcular las distancias de todos los puntos de la cuadrícula. Para almacenar los datos vuelvo a usar una tabla hash (defaultdict de Python), donde la clave es la coordenada X,Y y el valor es el punto de control más cercano a esa cuadrícula. Si dos puntos de control están a la misma distancia o no se ha calculado, se usa -1.<br><br>Cuando se ha calculado el punto de control más cercano, se revisa si ese punto estaba fuera del rectángulo que contiene a los puntos de control. Si está fuera, el punto de control pasa a un conjunto de puntos con infinitas cuadrículas cercanas.<br><br>Para el conteo de cuántas cuadrículas tiene un punto de control que sabemos que es finito, uso otra tabla hash, inicializada por defecto a 0, cuya clave es el identificador de punto de control y su valor, el número de cuadrículas. Después, de los valores almacenados se calcula el máximo.<br><pre class="lang:python decode:true ">from dataclasses import dataclass<br>from collections import defaultdict<br>import math<br><br>@dataclass<br>class Punto:<br>    x: int<br>    y: int<br>    owner: int<br><br>def distancia(p1,p2):<br>    return abs(p1.x-p2.x)+abs(p1.y-p2.y)<br><br>if __name__ == "__main__":<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    puntosControl = list()<br>    xlist = list()<br>    ylist = list()<br>    for i,line in enumerate(lines):<br>        l = line.split(",")<br>        xlist.append(int(l[0]))<br>        ylist.append(int(l[1]))<br>        puntosControl.append(Punto(x=int(l[0]),y=int(l[1]),owner=i))<br>    esquinaSuperiorIzquierda = Punto(x=min(xlist),y=min(ylist),owner=-1)<br>    esquinaInferiorDerecha = Punto(x=max(xlist),y=max(ylist),owner=-1)<br><br>    # Los que están fuera del rango esquinaSuperiorIzquierdaxesquinaInferiorDerecha se excluyen automáticamente<br>    excluidos = set()<br>    world = defaultdict(lambda: -1)<br>    for i in range(esquinaSuperiorIzquierda.x-1,esquinaInferiorDerecha.x+2):<br>        for j in range(esquinaSuperiorIzquierda.y-1,esquinaInferiorDerecha.y+2):<br>            punto = Punto(x=i,y=j,owner=-1)<br>            distanciaMin = math.inf<br>            total = 0<br>            for p in puntosControl:<br>                if distancia(punto,p) == distanciaMin:<br>                    punto.owner = -1<br>                if distancia(punto,p) &lt; distanciaMin:<br>                    distanciaMin = distancia(punto,p)<br>                    punto.owner = p.owner<br>                <br>            if i == esquinaSuperiorIzquierda.x-1 or i == esquinaInferiorDerecha.x+1 or j == esquinaSuperiorIzquierda.y-1 or j == esquinaInferiorDerecha.y+1:<br>                excluidos.add(punto.owner)<br>            if punto.owner &gt; -1:<br>                world[(i,j)] = punto.owner<br>    conteo = defaultdict(lambda: 0)<br>    for p in world:<br>        if not world[p] in excluidos:<br>            conteo[world[p]] += 1<br>    print("Maximum finite area: %d" % max(conteo.values()))</pre><br>En la segunda parte nos dicen que hay una región de puntos cuya suma de distancias a todos los puntos de control es menor a 10000. ¿Cuántos puntos forman esta región? Aquí creo que el enunciado no fue demasiado claro, ya que en un principio pensé que podría haber varias áreas, o que podría haber puntos sueltos, no conectados a la región. Sin embargo eso no pasa. Yo diseñé un algoritmo que iba visitando las celdas adyacentes, pero en realidad no hacía falta, simplemente se puede contar cuantos puntos cumplen la condición. Y se puede hacer en el mismo bucle que la primera parte.<br><pre class="lang:python decode:true ">from dataclasses import dataclass<br>from collections import defaultdict<br>import math<br><br>@dataclass<br>class Punto:<br>    x: int<br>    y: int<br>    owner: int<br><br>def distancia(p1,p2):<br>    return abs(p1.x-p2.x)+abs(p1.y-p2.y)<br><br>if __name__ == "__main__":<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    puntosControl = list()<br>    xlist = list()<br>    ylist = list()<br>    for i,line in enumerate(lines):<br>        l = line.split(",")<br>        xlist.append(int(l[0]))<br>        ylist.append(int(l[1]))<br>        puntosControl.append(Punto(x=int(l[0]),y=int(l[1]),owner=i))<br>    esquinaSuperiorIzquierda = Punto(x=min(xlist),y=min(ylist),owner=-1)<br>    esquinaInferiorDerecha = Punto(x=max(xlist),y=max(ylist),owner=-1)<br><br>    # Los que están fuera del rango esquinaSuperiorIzquierdaxesquinaInferiorDerecha se excluyen automáticamente<br>    excluidos = set()<br>    world = defaultdict(lambda: -1)<br>    world_total = 0<br>    for i in range(esquinaSuperiorIzquierda.x-1,esquinaInferiorDerecha.x+2):<br>        for j in range(esquinaSuperiorIzquierda.y-1,esquinaInferiorDerecha.y+2):<br>            punto = Punto(x=i,y=j,owner=-1)<br>            distanciaMin = math.inf<br>            total = 0<br>            for p in puntosControl:<br>                if distancia(punto,p) == distanciaMin:<br>                    punto.owner = -1<br>                if distancia(punto,p) &lt; distanciaMin:<br>                    distanciaMin = distancia(punto,p)<br>                    punto.owner = p.owner<br>                total += distancia(punto,p)<br>            if total &lt; 10000:<br>                world_total += 1<br>                <br>            if i == esquinaSuperiorIzquierda.x-1 or i == esquinaInferiorDerecha.x+1 or j == esquinaSuperiorIzquierda.y-1 or j == esquinaInferiorDerecha.y+1:<br>                excluidos.add(punto.owner)<br>            if punto.owner &gt; -1:<br>                world[(i,j)] = punto.owner<br>    conteo = defaultdict(lambda: 0)<br>    for p in world:<br>        if not world[p] in excluidos:<br>            conteo[world[p]] += 1<br>    print("Maximum finite area: %d" % max(conteo.values()))<br>    print("Region size: %d" % world_total)</pre><br><h2>Día 7</h2><br>El día 7 se nos propone un reto muy interesante. En primer lugar, tenemos una lista de tareas que hacer en orden. Cada tarea depende de que otras hayan finalizado. Se nos pide el orden en el que se deberán hacer. Para resolver esto vamos a usar una estructura de datos nueva, el grafo dirigido. No voy a implementarlo yo, sino que voy a usar la magnífica librería <a href="https://networkx.github.io/">networkx</a>.<br><br>La idea es construir un grafo dirigido, con las tareas. Un nodo dirigido de C a A significa que antes de hacer la tarea A, C tiene que estar completado. Por supuesto puede darse el caso de que antes de hacer A haya que hacer C y otras tareas.<br><br>Vamos a realizar una búsqueda primero en anchura (DFS en inglés). Para ello mantenemos una lista con las tareas completadas y otra lista con las tareas que podríamos empezar a hacer. Cuando completamos una tarea vemos si las tareas a las que llevan necesitan todavía más tareas por realizar o en cambio ya pueden ser añadidas a la lista de "listas para empezar". El enunciado nos indica que ante la situación de dos tareas listas para empezar, se usa el orden alfabético para determinar cuál va antes.<br><br>Hace falta además una lista de tareas iniciales, que pueden empezar sin esperar. Esto se hace con dos conjuntos según leemos el archivo. Se hace la diferencia entre ellos y esas tareas no tienen prerrequisitos.<br><pre class="lang:python decode:true">import networkx as nx<br>import re<br><br>def read_file():<br>    first = set()<br>    second = set()<br>    G = nx.DiGraph()<br>    prog = re.compile("Step ([A-Z]) must be finished before step ([A-Z]) can begin.")<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    for line in lines:<br>        r = prog.match(line.strip())<br>        if not r.group(1) in G:<br>            G.add_node(r.group(1))<br>        if not r.group(2) in G:<br>            G.add_node(r.group(2))<br>        if not G.has_edge(r.group(1),r.group(2)):<br>            G.add_edge(r.group(1),r.group(2))<br>        first.add(r.group(1))<br>        second.add(r.group(2))<br>    return (G,first- second)<br><br>if __name__ == "__main__":<br>    G,starter = read_file()<br>    path = list()<br>    to_visit = sorted(starter,reverse=True)<br><br>    while len(to_visit) &gt; 0:<br>        node = to_visit.pop()<br>        path.append(node)<br>        neighbours = G[node]<br>        for n in neighbours:<br>            if not n in to_visit and not n in path:<br>                allCompleted = True<br>                for u,v in G.in_edges(nbunch=n):<br>                    if not u in path:<br>                        allCompleted = False<br>                if allCompleted:<br>                    to_visit.append(n)<br>        to_visit = sorted(to_visit,reverse=True)<br>    print("".join(path))</pre><br>La segunda parte también es muy interesante. Se nos indica que las tareas tienen una duración de N segundos, dependiendo del valor alfabético de la letra. Además, ahora existen 5 trabajadores que pueden ir haciendo tareas en paralelo. ¿En cuánto tiempo podemos acabar todas las tareas?<br><pre class="lang:python decode:true">import networkx as nx<br>import re<br><br>def read_file():<br>    first = set()<br>    second = set()<br>    G = nx.DiGraph()<br>    prog = re.compile("Step ([A-Z]) must be finished before step ([A-Z]) can begin.")<br>    with open("input.txt") as f:<br>        lines = f.readlines()<br>    for line in lines:<br>        r = prog.match(line.strip())<br>        if not r.group(1) in G:<br>            G.add_node(r.group(1))<br>        if not r.group(2) in G:<br>            G.add_node(r.group(2))<br>        if not G.has_edge(r.group(1),r.group(2)):<br>            G.add_edge(r.group(1),r.group(2))<br>        first.add(r.group(1))<br>        second.add(r.group(2))<br>    return (G,first- second)<br><br>def duration(step):<br>    return 60+ord(step)-64<br><br>if __name__ == "__main__":<br>    G,starter = read_file()<br>    path = list()<br>    to_visit = sorted(starter,reverse=True)<br><br>    while len(to_visit) &gt; 0:<br>        node = to_visit.pop()<br>        path.append(node)<br>        neighbours = G[node]<br>        for n in neighbours:<br>            if not n in to_visit and not n in path:<br>                allCompleted = True<br>                for u,v in G.in_edges(nbunch=n):<br>                    if not u in path:<br>                        allCompleted = False<br>                if allCompleted:<br>                    to_visit.append(n)<br>        to_visit = sorted(to_visit,reverse=True)<br>    print("".join(path))<br><br>    end_letter = path[-1]<br>    path = list()<br>    to_visit = sorted(starter,reverse=True)<br>    <br>    second = 0<br>    workers = list()<br>    # Trabajo Actual, segundo que termina<br>    workers.append(['.',0])<br>    workers.append(['.',0])<br>    workers.append(['.',0])<br>    workers.append(['.',0])<br>    workers.append(['.',0])<br>    def full_workers(workers):<br>        full = True<br>        for w in workers:<br>            if w[0] == ".":<br>                full = False<br>        return full<br>    end = False<br>    while not end:<br>        if len(to_visit) == 0 or full_workers(workers):<br>            second += 1<br>        for i in range(0,len(workers)):<br>            if workers[i][1] &lt;= second:<br>                if workers[i][0] != ".":<br>                    path.append(workers[i][0])<br>                    neighbours = G[workers[i][0]]<br>                    for n in neighbours:<br>                        if not n in to_visit and not n in path:<br>                            allCompleted = True<br>                            for u,v in G.in_edges(nbunch=n):<br>                                if not u in path:<br>                                    allCompleted = False<br>                            if allCompleted:<br>                                to_visit.append(n)<br>                    to_visit = sorted(to_visit,reverse=True)<br>                if workers[i][0] == end_letter:<br>                    print("Finish point")<br>                    print("Seconds: %d" % second)<br>                    end = True<br>                if len(to_visit) &gt; 0:<br>                    node = to_visit.pop()<br>                    workers[i][1] = second+duration(node)<br>                    workers[i][0] = node<br>                else:<br>                    workers[i][0] = "."</pre><br>Bien, partiendo del mismo grafo dirigido ahora vamos a hacer otro tipo de recorrido, también DFS, pero no vamos a añadir nuevos elementos a la lista de forma inmediata, sino cuando hayan sido acabados de procesar. Almacenamos los trabajadores como listas dentro de una lista de trabajadores. Cada trabajador guarda la tarea que estaba haciendo y el segundo en el que acabará. Defino una función para saber si los trabajadores están todos ocupados.<br><br>Lo primero a tener en cuenta es que el tiempo no avanza hasta que la lista de tareas que se puede realizar está vacía o los trabajadores están llenos. Luego en cada iteración del bucle, analizamos a los trabajadores. Si no han acabado, no se hace nada. Si ya han acabado y estaban con una tarea, se añade la tarea a la lista de tareas finalizadas, y se analiza si se han desbloqueado nuevas tareas disponibles para realizar. Si la tarea que ha realizado es la última tarea, se acaba el programa.<br><br>Por último si hay una tareas disponible para hacer, se la añadimos al trabajador y si no, pues le indicamos que no haga nada (así no añadimos por duplicado la tarea en el futuro).<br><br><a href="https://files.adrianistan.eu/Day7.png"><img class="size-full wp-image-1645" src="https://files.adrianistan.eu/Day7.png" alt="" width="663" height="565" /></a> Salida de debug que saqué en el día 7<br><h2>Conclusión</h2><br>Esta ha sido la primera semana del Advent of Code 2018. Como vemos, el nivel de los problemas ha ido aumentado de forma progresiva. La próxima semana comentaré las soluciones correspondientes. <a href="https://github.com/aarroyoc/advent-of-code-2018">Tenéis todo el código hasta ahora aquí.</a><br><br>&nbsp;