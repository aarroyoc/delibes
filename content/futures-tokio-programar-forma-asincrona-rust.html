Rust es un lenguaje muy potente y uno de sus principales focos de diseño es la <strong>concurrencia</strong>. Sin embargo, si damos un repaso por la librería estándar veremos un par de cosas nada más, algo que puede resultar <strong>decepcionante</strong>. Esto se debe a que Rust no impone ningún modelo específico de concurrencia como sí lo hacen Go o Erlang. Rust nos provee de los ladrillos de construcción necesarios.<br><br>De forma estándar, Rust nos provee de <strong>Mutex</strong>, <strong>atómicos</strong>, <strong>threads</strong>, <strong>variables de condición</strong>, <strong>RwLock</strong> y un modelo algo más avanzado de mensajería mediante canales de múltiples productores y un único consumidor (mpsc). En el exterior tenemos crates como <strong>Actix</strong> que nos proveen del modelo de actores en Rust (dicen que es similar a <strong>Akka</strong>, yo lo desconozco), modelos de mensajería por canales más flexibles (mpmc) y una cosa muy interesante llamado <strong>Futures</strong>. Los futures o futuros no son esos contratos que se realizan en bolsa sobre el valor futuro de una acción, sino que son una manera cómoda de manejar valores que existirán en el futuro. Si has usado JavaScript o C# igual te suenan las <strong>Promises</strong> o Promesas y los <strong>Task</strong> respectivamente. Los futuros de Rust son exactamente lo mismo.<br><h2>¿Qué es un futuro?</h2><br>Un futuro es una variable que representa un dato que todavía no existe. Tenemos la promesa de que ese valor existirá en el futuro. La ventaja es que podemos usarlo aun cuando todavía no tenga un valor. Esto además permite escribir código asíncrono con facilidad.<br><br>Una diferencia con respecto a los <strong>Promises</strong> de JavaScript es que los futuros se basan en <strong>poll</strong> en vez de en <strong>push</strong>. Es decir, los futuros van a ir preguntando si el valor ya está disponible. Ante esta pregunta se puede responder con un error, con <em>todavía no está disponible</em> y con <em>ya está disponible, aquí tienes</em>.<br><br>Veamos un ejemplo muy tonto pero que puede servirnos para entender algunas cosas.<br><pre class="lang:rust decode:true ">extern crate futures;<br><br>use futures::*;<br>use std::time;<br>use std::thread;<br><br>fn suma(a: i32, b: i32) -&gt; SumFuture {<br>    SumFuture{<br>        a: a,<br>        b: b<br>    }<br>}<br><br>struct SumFuture{<br>    a: i32,<br>    b: i32<br>}<br><br>impl Future for SumFuture {<br>    type Item = i32;<br>    type Error = String;<br><br>    fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;i32&gt;,String&gt; {<br>        thread::sleep(time::Duration::from_secs(1));<br>        Ok(Async::Ready(self.a+self.b))<br>    }<br>}<br><br>fn main() {<br>    let c = suma(4,5);<br>    println!("Suma: {}",c.wait().unwrap());<br>}<br></pre><br>Definimos un nuevo futuro, <em>SumFuture</em>, que devuelve el resultado de una suma. El futuro en su función <strong>poll</strong> duerme el hilo 1 segundo y después devuelve el resultado correcto. En la función main llamamos a suma que devuelve un futuro en vez del resultado. Con el futuro, esperamos con <strong>wait</strong> a que se resuelva y lo mostramos. Cuando un futuro se ejecuta se convierte en una <strong>tarea</strong>. Las <strong>tareas</strong> necesitan ejecutores. Wait ejecuta los futuros en el mismo hilo desde el que se hace la llamada, pero existen otras opciones. El programa, tarda un segundo en imprimir el número.<br><br><em>Pero esto no sirve para nada</em><br><br>Bueno, quizá ahora parezca una tontería, pero en cuanto introduzcamos más elementos, todo tendrá más sentido.<br><br>Una característica de los futuros es que se pueden encadenar, tal que así:<br><pre class="lang:rust decode:true ">fn main() {<br>    let c = suma(4,5)<br>    .and_then(|v|{<br>        suma(v,40)<br>    }).and_then(|v|{<br>        suma(v,40)<br>    }).wait().unwrap();<br>    println!("Suma: {}",c);<br>}</pre><br><h2>Ejecutores</h2><br>Los futuros nos ayudan con la concurrencia, esto es porque se puede esperar a varios futuros a la vez sin problema. Una manera de hacerlo es con <strong>CpuPool</strong>, un ejecutor que tiene un pool de hilos ya creados. Su uso es muy sencillo, en este ejemplo vemos como hago dos operaciones en paralelo:<br><pre class="lang:rust decode:true ">fn main() {<br>    let c = suma(4,5)<br>    .and_then(|v|{<br>        suma(v,40)<br>    }).and_then(|v|{<br>        suma(v,40)<br>    });<br>    let d = suma(15,14);<br>    <br>    let pool = CpuPool::new_num_cpus();<br>    let c = pool.spawn(c);<br>    let d = pool.spawn(d);<br>    let (c,d) = c.join(d).wait().unwrap();<br>    println!("SUMAS: {},{}",c,d);<br>}<br></pre><br>Con <strong>spawn</strong> añadimos un nuevo futuro a la ejecución y nos devuelve otro futuro. Con <strong>join</strong> podemos unir dos futuros en uno solo que se resuelva cuando ambos hayan resuelto. Finalmente hacemos <strong>wait</strong> en el hilo principal para esperar a que las sumas se hagan e imprimir el resultado. Existen otros ejecutores. Con Tokio usaremos otro.<br><h2>Tokio</h2><br><a href="https://files.adrianistan.eu/Screenshot-from-2018-02-23-17-16-38.png"><img class="aligncenter size-large wp-image-1345" src="https://files.adrianistan.eu/Screenshot-from-2018-02-23-17-16-38-1024x576.png" alt="" width="840" height="473" /></a><br><br>Tokio es una librería que nos permite ejecutar código de entrada/salida de forma asíncrona, usando futuros por debajo. Son especialmente útiles, la parte de red de Tokio y sus ejecutores correspondientes.<br><pre class="lang:rust decode:true">extern crate tokio;<br>extern crate tokio_io;<br>extern crate futures;<br><br>use futures::prelude::*;<br>use tokio_io::AsyncRead;<br>use futures::Stream;<br>use tokio_io::codec::*;<br>use std::net::*;<br>use tokio::prelude::*;<br><br>fn main(){<br>    let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);<br>    let listener = tokio::net::TcpListener::bind(&amp;socket).unwrap();<br>    let server = listener.incoming().for_each(|socket|{<br>       println!("Cliente recibido");<br>       Ok(())<br>    }).map_err(|err|{<br>        println!("error = {:?}",err);<br>    });<br>    tokio::run(server);<br>}</pre><br>En este ejemplo tenemos un pequeño servidor TCP que se mantiene a la espera de clientes, imprime un mensaje y cierra la conexión. Este servidor solo utiliza un hilo, no obstante, ya usa futuros. <strong>server</strong> es un futuro infinito, que nunca acaba, que ejecutamos en el hilo actual con run-&gt;spawn. El <strong>run</strong> solo es necesario para ejecutar el primer futuro, el que mantendrá viva la aplicación. <strong>spawn</strong> empieza a ejecutar el futuro, que entonces se pasa a denominar <strong>tarea</strong>. Aquí es Tokio en vez de CpuPool, el planificador de tareas.<br><h2>Servidor de Echo en Tokio</h2><br>Ahora vamos a ir con un ejemplo más interesante, ahora el cliente y el servidor estarán conectados durante un tiempo, mandando el cliente un mensaje y el servidor respondiendo. Pero queremos que haya varios clientes simultáneamente. Usando futuros y Tokio podemos hacerlo en un mismo hilo (al estilo Node.js).<br><pre class="lang:rust decode:true">extern crate tokio;<br>extern crate tokio_io;<br>extern crate futures;<br><br>use futures::prelude::*;<br>use tokio_io::AsyncRead;<br>use futures::Stream;<br>use tokio_io::codec::*;<br>use std::net::*;<br>use tokio::prelude::*;<br><br>fn main(){<br>    let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);<br>    let listener = tokio::net::TcpListener::bind(&amp;socket).unwrap();<br>    let server = listener.incoming().for_each(|socket|{<br>       let (writer,reader) = socket.framed(LinesCodec::new()).split();<br>       let action = reader<br>       .map(move |line|{<br>           println!("ECHO: {}",line);<br>           line<br>       })<br>       .forward(writer)<br>       .map(|_|{<br>        })<br>       .map_err(|err|{<br>           println!("error");<br>       });<br>       tokio::spawn(action);<br>       Ok(())<br>    }).map_err(|err|{<br>        println!("error = {:?}",err);<br>    });<br>    tokio::run(server);<br>}</pre><br>¿Qué hacemos ahora? Ahora a cada socket de cliente asignamos una tarea, que se encarga, de forma independiente, de ir leyendo línea a línea (gracias a <strong>LineCodec</strong>).<br><br>A partir de aquí se programa en forma de stream, un patrón muy común en la programación con futuros.<br><br>En el primer <strong>map</strong> imprimimos la línea en el servidor y la seguimos pasando por el stream. El siguiente paso es escribir en writer, con <strong>forward</strong> imprimimos y mandamos esa línea al cliente. Forward a su vez devuelve una tupla con datos (útil para seguir haciendo cosas). Como no los necesitamos, hacemos un <strong>map</strong> cuya única finalidad sea descartar los valores y finalmente un <strong>map_err</strong> para capturar posibles errores. Una vez hecho esto tenemos un futuro listo para ser ejecutado. Iniciamos la tarea con <strong>spawn</strong> y nos olvidamos, pasando a esperar a por un nuevo cliente.<br><br>Ahora, en el servidor podemos manejar varios clientes a la vez, cada uno en una tarea distinta, dentro de un mismo hilo.<br><h2>Cancelando la tarea</h2><br>Esta tarea que maneja el cliente es infinita, es decir, no se para. La razón es que <strong>reader</strong> es un lector que genera un futuro infinito esperando a nuevas líneas. Pero, ¿existe algún método para parar la tarea desde el servidor?<br><br>Esto no es algo demasiado trivial, pero se puede hacer de manera sencilla usando <strong>canales</strong> MPSC de Rust y futuros.<br><pre class="lang:rust decode:true">extern crate tokio;<br>extern crate tokio_io;<br>extern crate futures;<br><br>use futures::prelude::*;<br>use tokio_io::AsyncRead;<br>use futures::Stream;<br>use tokio_io::codec::*;<br>use tokio::prelude::*;<br><br>struct Cancellable{<br>    rx: std::sync::mpsc::Receiver&lt;()&gt;,<br>}<br><br>impl Future for Cancellable {<br>    type Item = ();<br>    type Error = std::sync::mpsc::RecvError;<br><br>    fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;Self::Item&gt;,Self::Error&gt; {<br>        match self.rx.try_recv() {<br>            Ok(_) =&gt; Ok(Async::Ready(())),<br>            Err(_) =&gt; Ok(Async::NotReady)<br>        }<br>    }<br>}<br><br>fn main() {<br>    let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);<br>    let listener = tokio::net::TcpListener::bind(&amp;socket).unwrap();<br>    let server = listener.incoming().for_each(|socket|{<br>        let (writer,reader) = socket.framed(LinesCodec::new()).split();<br>        let (tx,rx) = std::sync::mpsc::channel();<br>        let cancel = Cancellable {<br>            rx: rx,<br>        };<br>        let action = reader<br>        .map(move |line|{<br>            println!("ECHO: {}",line);<br>            if line == "bye"{<br>                println!("BYE");<br>                tx.send(()).unwrap();<br>            }<br>            line<br>        })<br>        .forward(writer)<br>        .select2(cancel)<br>        .map(|_|{<br><br>        })<br>        .map_err(|err|{<br>            println!("error");<br>        });<br>        tokio::spawn(action);<br>        <br>        Ok(())<br>    }).map_err(|err|{<br>        println!("error = {:?}",err);<br>    });<br>    tokio::run(server);<br>}</pre><br>La idea aquí es hacer que de alguna manera, el futuro pueda resolverse y así finalizar la tarea. Una función interesante es <strong>select2</strong> que devuelve un futuro fusión de dos futuros. Este futuro se resuelve (devuelve valor y acaba la tarea) cuando alguno de ellos lo haga. Como el futuro de <strong>reader</strong> nunca acabará, entonces basta con poner un futuro que cuando queramos cerrar la conexión resolveremos.<br><br>Este futuro es <strong>cancel</strong> de tipo <strong>Cancellable</strong>. No viene en la librería, lo he creado arriba y lo que hace es esperar a que el extremo del canal reciba una comunicación. El valor nos da igual, simplemente que se haya producido un ping. Una vez hecho eso, el futuro resuelve y la conexión se cierra.<br><br>En el ejemplo, cuando el cliente manda <em>bye</em> la conexión se cierra.<br><br><a href="https://files.adrianistan.eu/Screenshot-from-2018-02-23-17-15-42.png"><img class="aligncenter size-large wp-image-1344" src="https://files.adrianistan.eu/Screenshot-from-2018-02-23-17-15-42-1024x576.png" alt="" width="840" height="473" /></a><br><br>Y esto es una breve introducción a los futuros y a Tokio en Rust. Todavía queda ver como podemos usar <strong>async/await</strong> para no tener que escribir todo esto en forma de stream.