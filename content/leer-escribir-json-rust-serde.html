<strong>JSON</strong> es un formato muy popular para guardar y transmitir información. En Rust podemos leer y escribir JSON de forma transparente gracias a <a href="https://serde.rs"><strong>Serde</strong></a>. Serde es una librería para Rust, que permite transformar las structs nativas de Rust en ficheros JSON, YAML, BSON, MsgPack, XML y viceversa. Serde está compuesto de varios plugins, uno para cada formato de archivo, así que vamos a necesitar el plugin de JSON. Es lo que se dice serializar (guardar) y deserializar (leer).<br><h2>Deserializando JSON con Serde</h2><br>Para deserializar necesitamos primero definir el struct en Rust que se corresponde al JSON que vamos a cargar. Además, hay que incluir una cláusula <strong>derive</strong> e indicar que derivamos <strong>Deserializable</strong>.<br><pre class="lang:rust decode:true ">#[derive(Deserialize)]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    name: String<br>}<br></pre><br>Una vez hecho eso podemos realizar la transformación con Serde. Serde admite varios métodos de entrada. En mi caso voy a usar <strong>from_reader</strong>, que permite transformar desde cualquier <strong>std::io::Read</strong>. También se podría usar <strong>from_str</strong>, que permite leer desde un <strong>String</strong>.<br><br>Así pues un programa que lea Landmarks de un fichero JSON como este:<br><pre class="lang:js decode:true">[{<br>    "x": 42,<br>    "y" : -1,<br>    "name" : "Presa de Tibi"<br>},<br>{<br>    "x" : 50,<br>    "y" : 23,<br>    "name" : "Rollo de Villalón de Campos"<br>}]</pre><br>Quedaría así:<br><pre class="lang:rust decode:true">#[macro_use]<br>extern crate serde_derive;<br><br>extern crate serde;<br>extern crate serde_json;<br><br>use std::io::BufReader;<br>use std::fs::File;<br><br>#[derive(Deserialize)]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    name: String<br>}<br><br>fn main() {<br>    let file = File::open("landmarks.json").unwrap();<br>    let reader = BufReader::new(file);<br>    let landmarks: Vec&lt;Landmark&gt; = serde_json::from_reader(reader).unwrap();<br>    for landmark in landmarks{<br>        println!("Landmark name: {}\tPosition: ({},{})",landmark.name,landmark.x,landmark.y);<br>    }<br>}<br></pre><br>Nótese como usamos <strong>Vec&lt;Landmark&gt;</strong> para indicar que vamos a cargar un JSON que es un array de Landmarks.<br><h2>Serializar JSON</h2><br>Ahora si queremos generar un archivo JSON es muy sencillo. Simplemente marcamos <strong>Serialize</strong> en la misma estructura que queramos serializar. Posteriormente en Serde podemos utilizar diferentes métodos, como <strong>to_writer </strong>o <strong>to_string</strong>.<br><pre class="lang:rust decode:true ">#[macro_use]<br>extern crate serde_derive;<br><br>extern crate serde;<br>extern crate serde_json;<br><br>use std::io::{BufReader,BufWriter};<br>use std::fs::File;<br><br>#[derive(Serialize, Deserialize)]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    name: String<br>}<br><br>fn main() {<br>    let landmark = Landmark {<br>        x: 67,<br>        y: 23,<br>        name: String::from("Academia de Caballería")<br>    };<br>    let output = File::create("caballeria.json").unwrap();<br>    let writer = BufWriter::new(output);<br>    serde_json::to_writer(writer,&amp;landmark).unwrap();<br>}</pre><br><h2>Personalizando la serialización y la deserialización</h2><br>Serde permite a través de atributos, definir de forma precisa que ocurre con los elementos. En caso de no poner nada, por ejemplo, Serde usará los nombres del struct de Rust en los ficheros y si hay elementos de más, en el fichero al leer, los ignorará.<br><br>Por ejemplo, si queremos que en el fichero JSON, en vez de tener <strong>name</strong> sea <strong>nombre</strong>, podemos usar <strong>rename</strong>.<br><pre class="lang:rust decode:true ">#[derive(Serialize, Deserialize)]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    #[serde(rename = "nombre")]<br>    name: String<br>}</pre><br>Podemos también no querer guardar algún elemento del struct, usamos <strong>skip</strong>.<br><div><br><div><br><pre class="lang:rust decode:true">#[derive(Serialize, Deserialize)]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    name: String,<br>    #[serde(skip)]<br>    id: u32<br>}</pre><br>Si queremos que Serde falle en caso de que en el JSON haya más campos de los que hemos definido, usamos <strong>deny_unkown_fields</strong>.<br><pre class="lang:default decode:true ">#[derive(Serialize, Deserialize, Debug)]<br>#[serde(deny_unknown_fields)]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    name: String,<br>}</pre><br>Y si queremos que el nombre del struct sea distinto al que crea oportuno Serde, podemos redefinirlo también:<br><pre class="lang:rust decode:true ">#[derive(Serialize, Deserialize)]<br>#[serde(rename = "landmark")]<br>struct Landmark {<br>    x: i32,<br>    y: i32,<br>    name: String,<br>}</pre><br>Por último, mencionar que Serde permite serializar/deserializar cosas más complejas, con otros structs, con vectores, con <strong>HashMap</strong>, entre sus elementos,... Lo único que tendrá que pasar es que esas estructuras a su vez sean serializables/deserializables con Serde (es decir, hayan puesto <strong>derive(Serialize,Deserialize)</strong>).<br><br><a href="https://files.adrianistan.eu/SerdeJson.png"><img class="aligncenter size-large wp-image-1240" src="https://files.adrianistan.eu/SerdeJson-1024x546.png" alt="" width="840" height="448" /></a><br><br></div><br></div>