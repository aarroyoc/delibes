Hola, soy Adrián Arroyo y bienvenidos a un nuevo episodio de <em>Diversión con Punteros</em>.<br><br><a href="https://files.adrianistan.eu/FunWithPointers.jpg"><img class="aligncenter size-large wp-image-1057" src="https://files.adrianistan.eu/FunWithPointers-1024x576.jpg" alt="" width="840" height="473" /></a>Hoy vamos a hablar de un tema apasionante. Los bloques <strong>unsafe</strong> de Rust así como de los <strong>raw pointers</strong>. ¿Has programado en C? Si es así, los <strong>raw pointers</strong> de Rust son exactamente iguales a los punteros de C. Si no sabes lo que es un puntero, te lo explico.<br><h2>¿Qué es un puntero?</h2><br>Un puntero es un tipo de variable que en vez de almacenar el dato, almacena la posición en memoria donde se encuentra el dato.<br><br>En lenguajes en lo que todo es un objeto (como Python), nunca trabajamos con los datos reales, sino siempre con punteros, pero el lenguaje lo gestiona de forma automática. En lenguajes más cercanos al metal por contra sí que suele dejarse esta opción.<br><br><a href="https://files.adrianistan.eu/Puntero.png"><img class="wp-image-1058 size-full" src="https://files.adrianistan.eu/Puntero.png" alt="" width="400" height="200" /></a> Nuestro puntero es la variable que contiene 0x00ffbea0 y que apunta a la dirección de memoria donde se encuentra el dato<br><br>Rust tiene distintos tipos de punteros: <strong>Box, Rc, Arc, Vec, </strong>... Estos punteros son transparentes al usuario y muchas veces no tenemos que preocuparnos de su funcionamiento. Sin embargo, muchas veces queremos tener un control más fino del ordenador. Esto lo lograremos con los <strong>raw pointers</strong>. Se trata de punteros con los que podemos operar y desreferenciar.<br><br>Crear <strong>raw pointers</strong> no supone ningún problema, pero acceder al valor al que apuntan en memoria sí. Podría darse el caso de que no existiera valor alguno o hubiese sido modificado. En los punteros normales, el compilador de Rust se encarga de que no ocurra, pero en los raw pointers el compilador no lo puede saber. Es por ello, que para acceder al valor de un <strong>raw_pointer</strong> necesitas usar bloques de código <strong>unsafe</strong>, código inseguro en Rust.<br><h2>Creando un raw pointer</h2><br>Lo primero que hay que saber es que existen dos tipos de raw pointers en Rust, los mutables y los inmutables.<br><br>Los punteros inmutables tienen el tipo <strong>*const T</strong> y los mutables el tipo <strong>*mut T</strong>.<br><pre class="lang:rust decode:true">fn main(){ <br>    let numero = 5; <br>    let puntero = &amp;numero as *const i32; <br>    println!("Address: 0x{:x}", puntero as usize); <br>    println!("Value: {}",numero); <br>}</pre><br>&nbsp;<br><br>En este ejemplo, creamos una variable con valor 5 y le creamos un puntero, que contiene la dirección de memoria donde está el dato. Para representar la dirección de memoria se suele usar la notación hexadecimal. Antes debemos hacer un cast a <strong>usize</strong>. <strong>usize</strong> es un tipo en Rust cuyo tamaño depende de la máquina en cuestión (32 bits en máquinas de 32 bits, 64 bits en máquinas de 64 bits), siendo usado para representar direcciones de memoria, puesto que tiene el tamaño exacto para almacenarlas.<br><br>Hasta ahora no hemos usado <strong>unsafe</strong>. Esto es porque no hemos probado a acceder al valor. Para acceder a un valor, o <strong>deferrenciar</strong>, usamos el operador <strong>*</strong>.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let numero = 5;<br>    let puntero = &amp;numero as *const i32;<br>    println!("Address: 0x{:x}", puntero as usize);<br>    println!("Value: {}",numero);<br>    unsafe{<br>        println!("Value: {}",*puntero);<br>    }<br>}<br></pre><br><br>Ambos prints imprimen 5. Hasta aquí no hemos hecho nada interesante con punteros. Todo esto era más fácil hacerlo sin punteros. Veamos alguna aplicación práctica de los punteros.<br><h2>Modificar datos sin control</h2><br>Si te pongo este código, ¿me puedes decir que salida dará?<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let mut numero = 5;<br>    let puntero = &amp;mut numero as *mut i32;<br>    println!("Address: 0x{:x}", puntero as usize);<br>    unsafe{<br>        scary_things(puntero);<br>    }<br>    println!("Value: {}",numero);<br>}<br></pre><br><br>Uno podría pensar que como en ningún sitio reasignamos numero, y numero es una variable de tipo <strong>i32</strong>, que implementa <strong>Copy</strong>, es imposible modificarle el valor. Y eso es correcto en las reglas de Rust normales, pero en unsafe, podemos pasar el puntero hacia otras funciones (los punteros también son <strong>Copy</strong>, ocupan el tamaño de un <strong>usize</strong>). Y esas funciones pueden modificar los datos en memoria a su antojo. Así, pues, la respuesta correcta es indeterminado. Hacer esto es una mala práctica, pero en ocasiones se puede ganar rendimiento o interactuar con una librería de C usando estos métodos.<br><br><pre class="lang:rust decode:true"><br>unsafe fn scary_things(p: *mut i32) {<br>    *p = 12;<br>}<br><br>fn main(){<br>    let mut numero = 5;<br>    let puntero = &amp;mut numero as *mut i32;<br>    println!("Address: 0x{:x}", puntero as usize);<br>    unsafe{<br>        scary_things(puntero);<br>    }<br>    println!("Value: {}",numero);<br>}<br></pre><br><br>Esta sería la versión completa del programa.<br><h2>Aritmética de punteros</h2><br>Una vez tenemos acceso a memoria podemos acceder a <strong>cualquier</strong> parte de memoria (en sistemas operativos modernos, memoria que esté asignada a nuestro programa). En C simplemente podíamos operar con el puntero como si fuese un número, con sumas, restas, multiplicaciones y divisiones. Estas operaciones eran un poco traicioneras porque eran relativas a la máquina. Sumar 1 a un puntero de int equivalía en realidad a sumar 4 al puntero en una máquina de 32 bits. En Rust esto no se permite, pero a cambio tenemos métodos que nos permiten hacer lo mismo. El más importante es <strong>offset</strong>. El offset nos permite desplazarnos por la memoria hacia delante y hacia atrás.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let mut numero = 5;<br>    let b = 35;<br>    let c = 42;<br>    let puntero = &amp;mut numero as *mut i32;<br>    println!("Address: 0x{:x}", puntero as usize);<br>    unsafe{<br>        *puntero.offset(1) = 120;<br>    }<br>    println!("Value: {}",numero);<br>    println!("Value: {}",b);<br>    println!("Value: {}",c);<br>}<br></pre><br><br>Este programa parte de una suposición para funcionar. Y es que numero, b y c están contiguos en memoria y en el <strong>mismo</strong><strong> orden</strong> que como los que he declarado. En el puntero tenemos la dirección a numero, es decir, a 5. Sin embargo, si avanzamos en la memoria una posición llegaremos a al 35, y si avanzamos dos, llegamos a 42. Entonces podemos editar el contenido de esa memoria. Al acabar el programa b vale 120. Hemos modificado el valor y ni siquiera b se había declarado como <strong>mut</strong>. Esto os recuerdo, usadlo solo en casos excepcionales.<br><h2><a href="https://files.adrianistan.eu/UnsafeWorldModificarB.png"><img class="aligncenter size-full wp-image-1059" src="https://files.adrianistan.eu/UnsafeWorldModificarB.png" alt="" width="577" height="117" /></a>Reservar memoria al estilo C</h2><br>Estas cosas empiezan a tener utilidad en cuanto podemos usar memoria dinámica al estilo C, es decir, con <strong>malloc</strong>, <strong>free</strong>, <strong>calloc</strong> y compañía. El equivalente a <strong>malloc</strong> en Rust suele ser <strong>Box</strong> o <strong>Vec </strong>y es lo que debemos usar. Box sabe que espacio en memoria tiene que reservar de antemano y Vec ya está preparado para ir creciendo de forma segura.<br><br><pre class="lang:rust decode:true"><br>extern crate libc;<br><br>use libc::{malloc,free};<br>use std::mem::size_of;<br><br>fn main(){<br>    unsafe {<br>        let puntero = malloc(10*size_of::&lt;i32&gt;()) as *mut i32;<br>        for i in 0..10 {<br>            *puntero.offset(i) = 42;<br>        }<br>        for i in 0..10{<br>            println!("{}",*puntero.offset(i));<br>        }<br>        free(puntero as *mut libc::c_void);<br>    }<br>}<br></pre><br><br>En este caso usamos <strong>malloc</strong> como en C para generar un array de forma dinámica con espacio suficiente para almacenar 10 elementos de tamaño <strong>i32</strong>.<br><br>Con esto ya hemos visto el lado oscuro de Rust, la parte <strong>unsafe</strong>. No hemos visto como llamar a funciones de C directamente, algo que también require usar bloques <strong>unsafe</strong>.<br><br>Como vemos, Rust no nos limita a la hora de hacer cualquier cosa que queramos, solo que nos reduce a los bloques unsafe, para que nosotros mismos tengamos mejor control de lo que hagamos.