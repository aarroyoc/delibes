<blockquote><em>Este artículo lo escribí para el blog en español <a href="http://blog.desdelinux.net">DesdeLinux</a> el 11 de enero de 2014 y ahora lo dejo aquí, en mi blog personal. El artículo está tal cual, sin ninguna modificación desde aquella fecha.</em></blockquote><br>Bien, después de un pequeño paréntesis seguimos con nuestra serie de tutoriales. Si retomamos el código anterior debemos de tener el ISR de la división por cero. Ahora debemos de rellenar el resto de las ISR para las que habíamos puesto mensaje (las 32 primeras). Bien ahora vamos a seguir programando interrupciones, vamos a hacer las IRQ también conocidas como Interrupts Requests. Estas IRQ se generan por los dispositivos de hardware tales como teclados, ratones, impresoras, etc. Inicialmente las primeras 8 IRQ se mapean automáticamente en las posiciones de la IDT del 8 al 15. Como hemos usado las 32 primeras para las excepciones ahora tenemos que remapearlas. Nosotros pondremos la IRQ desde la 32 hasta la 45. Para ello primero debemos remapear los los IRQ:<br><br><pre class="lang:c++ decode:true"><br>void ND::IRQ::Remap(int pic1, int pic2)<br>{<br>    #define PIC1 0x20<br>    #define PIC2 0xA0<br>    #define ICW1 0x11<br>    #define ICW4 0x01<br>    /* send ICW1 */<br><br>    ND::Ports::OutputB(PIC1, ICW1);<br>    ND::Ports::OutputB(PIC2, ICW1);<br><br>    /* send ICW2 */<br><br>    ND::Ports::OutputB(PIC1 + 1, pic1); /* remap */<br>    ND::Ports::OutputB(PIC2 + 1, pic2); /* pics */<br><br>    /* send ICW3 */<br><br>    ND::Ports::OutputB(PIC1 + 1, 4); /* IRQ2 -&gt; connection to slave */<br>    ND::Ports::OutputB(PIC2 + 1, 2);<br><br>    /* send ICW4 */<br><br>    ND::Ports::OutputB(PIC1 + 1, ICW4);<br>    ND::Ports::OutputB(PIC2 + 1, ICW4);<br><br>    /* disable all IRQs */<br><br>    ND::Ports::OutputB(PIC1 + 1, 0xFF);<br>}<br></pre><br>Ahora creamos una función para instalar los IRQ:<br><pre class="lang:c++ decode:true"><br>void ND::IRQ::Install()<br>{<br>    ND::Screen::SetColor(ND_SIDE_FOREGROUND,ND_COLOR_BLACK);<br>    ND::Screen::PutString(&quot;\nInstalling IRQ...&quot;);<br>    ND::IRQ::Remap(0x20,0x28);<br>    ND::IDT::SetGate(32,(unsigned)ND::IRQ::IRQ1,0x08,0x8E);<br>    ND::IDT::SetGate(33,(unsigned)ND::IRQ::IRQ2,0x08,0x8E);<br>    ND::IDT::SetGate(34,(unsigned)ND::IRQ::IRQ3,0x08,0x8E);<br>    ND::IDT::SetGate(35,(unsigned)ND::IRQ::IRQ4,0x08,0x8E);<br>    ND::IDT::SetGate(36,(unsigned)ND::IRQ::IRQ5,0x08,0x8E);<br>    ND::IDT::SetGate(37,(unsigned)ND::IRQ::IRQ6,0x08,0x8E);<br>    ND::IDT::SetGate(38,(unsigned)ND::IRQ::IRQ7,0x08,0x8E);<br>    ND::IDT::SetGate(39,(unsigned)ND::IRQ::IRQ8,0x08,0x8E);<br>    ND::IDT::SetGate(40,(unsigned)ND::IRQ::IRQ9,0x08,0x8E);<br>    ND::IDT::SetGate(41,(unsigned)ND::IRQ::IRQ10,0x08,0x8E);<br>    ND::IDT::SetGate(42,(unsigned)ND::IRQ::IRQ11,0x08,0x8E);<br>    ND::IDT::SetGate(43,(unsigned)ND::IRQ::IRQ12,0x08,0x8E);<br>    ND::IDT::SetGate(44,(unsigned)ND::IRQ::IRQ13,0x08,0x8E);<br>    ND::IDT::SetGate(45,(unsigned)ND::IRQ::IRQ14,0x08,0x8E);<br>    ND::IDT::SetGate(46,(unsigned)ND::IRQ::IRQ15,0x08,0x8E);<br>    ND::IDT::SetGate(47,(unsigned)ND::IRQ::IRQ16,0x08,0x8E);<br>    ND::Screen::SetColor(ND_SIDE_FOREGROUND,ND_COLOR_GREEN);<br>    ND::Screen::PutString(&quot;done&quot;);<br>    asm volatile(&quot;sti&quot;);<br>}<br></pre><br><br>La sentencia de asm <em>sti</em> nos activa los <strong>IRQ</strong>. Bien ahora vamos con algo similar a los ISR. Las funciones de un IRQ básico:<br><br><pre class="lang:c++ decode:true"><br>void ND::IRQ::IRQ1()<br>{<br>	asm volatile(<br>	&quot;cli \n&quot;<br>	&quot;pushl 0\n&quot;<br>	&quot;pushl 32\n&quot;<br>	&quot;jmp ND_IRQ_Common&quot;<br>	);<br>}<br></pre><br><br>Una parte común (igual que la de los ISR):<br><br><pre class="lang:c++ decode:true"><br>extern &quot;C&quot;<br>void ND_IRQ_Common()<br>{<br>    asm volatile(<br>    &quot;pusha \n&quot;<br>    &quot;push %ds\n&quot;<br>    &quot;push %es\n&quot;<br>    &quot;push %fs\n&quot;<br>    &quot;push %gs\n&quot;<br>    &quot;movw $0x10, %ax \n&quot;<br>    &quot;movw %ax, %ds \n&quot;<br>    &quot;movw %ax, %es \n&quot;<br>    &quot;movw %ax, %fs \n&quot;<br>    &quot;movw %ax, %gs \n&quot;<br>    &quot;movl %esp, %eax \n&quot;<br>    &quot;push %eax \n&quot;<br>    &quot;movl $ND_IRQ_Handler, %eax \n&quot;<br>    &quot;call *%eax \n&quot;<br>    &quot;popl %eax \n&quot;<br>    &quot;popl %ds \n&quot;<br>    &quot;popl %es \n&quot;<br>    &quot;popl %fs \n&quot;<br>    &quot;popl %gs \n&quot;<br>    &quot;popa \n&quot;<br>    &quot;addl 8, %esp \n&quot;<br>    &quot;iret \n&quot;<br>    );<br>}<br></pre><br><br>Y un handler básico:<br><br><pre class="lang:c++ decode:true"><br>extern &quot;C&quot;<br>void ND_IRQ_Handler(struct regs* r)<br>{<br>	void (*handler)(struct regs *r);<br>	if(r-&gt;int_no &gt;= 40)<br>	{<br>	ND::Ports::OutputB(0xA0,0x20);<br>	}<br>	ND::Ports::OutputB(0x20,0x20);<br>}<br></pre><br><br>Con esto ya deberíamos tener activados los IRQ aunque todavía no hagan nada. En el siguiente capítulo veremos como obtener datos a partir de estos IRQ como el reloj o el teclado.<br><br><img class="alignnone size-full wp-image-85" src="https://files.adrianistan.eu/NextDivel-IRQ.png" alt="NextDivel-IRQ" width="600" height="337" /><br><br>Y con esto termina el post de hoy. Como habeis podido comprobar ahora escribo menos regularmente debido a otros asuntos. Aun así seguiré hasta tener un sistema operativo más completo