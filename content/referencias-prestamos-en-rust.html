Continuando con <a href="https://blog.adrianistan.eu/rust-101-tutorial-rust-espanol/">Rust 101, tutorial de Rust en español</a> vamos a adentrarnos en un concepto clave para entender y programar en Rust. Rust es un lenguaje seguro como hemos dicho, esto implica que no puede haber NULLs ni tampoco fugas de memoria. Es decir, tiene que gestionar la memoria de forma eficiente pero dejarla directamente al programador, ya que son una fuente de bugs peligrosa. Algunos lenguajes disponen de recolector de basura (GC, <em>Garbage Collector</em>), que reduce la eficiencia del lenguaje. Go, Swift o Java usan GC. Luego existen lenguajes que dejan la memoria al descubierto, como C y C++. Rust toma un enfoque diferente, ya que no deja la memoria al descubierto ni usa GC. Para ello el compilador realiza una tarea de dueños y préstamos que veremos a continuación.<br><h2>Las reglas</h2><br><ol><br> 	<li>Cada valor en Rust tiene una variable que es su dueña</li><br> 	<li>Un valor solo puede tener un dueño a la vez</li><br> 	<li>Cuando el dueño desaparece, el valor lo hace a su vez, de forma automática</li><br></ol><br>Así que cuando una variable desaparece del <em>entorno</em>, el dato del que era dueño es liberado. Estas reglas vistas así permiten poca flexibilidad en la programación. Es por ello que los dueños pueden prestar los valores.<br><h2>La trait Copy y la trait Clone</h2><br>En primer lugar hay que distinguir distinto comportamiento según el tipo de un valor. Si implementan la trait Copy (la mayoría de tipos primitivos), entonces su comportamiento por defecto es de copia. Son datos en los que la copia es barata y rápida y no influye que existan varias copias de lo mismo. Cualquier cosa que no requería <em>malloc</em> en C puede ser Copy en Rust. Se trata de valores que se almacenan en el stack.<br><br>Otra trait es Clone, que permite hacer copias de datos más complejos, por ejemplo de un vector. Veamos un ejemplo de un código sin Copy pero con Clone.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let s1 = String::from(&quot;Adios - Xavier Cugat&quot;);<br>    let s2 = s1;<br>    println!(&quot;{}&quot;,s1); // ERRROR<br><br>}<br></pre><br><br>Este código da error porque el tipo String no implementa Copy. Entonces la línea <em>let s2 = s1;</em> lo que ha hecho en realidad ha sido mover el valor. Mover significa que le ha transferido el ser dueño del valor de la cadena de texto a s2. Por tanto s1 ya no es dueña del valor y no puede operar con él. Esto pasa en los tipos que no implementan Copy, que transfieren la propiedad a otra variable. Si queremos hacer una <em>copia</em> real, tendremos que recurrir al clonado. El tipo String implementa Clone así que es posible generar otro dato String exactamente igual pero independiente al original.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let s1 = String::from(&quot;Adios - Xavier Cugat&quot;);<br>    let s2 = s1.clone();<br>    println!(&quot;{}&quot;,s1);<br><br>}<br></pre><br><br><h2>Implicaciones</h2><br>Esto tiene una implicación sorprendente y es que pasar una variable tal cual a una función si no es del tipo Copy implica que ¡perdemos el acceso a ese valor! Pongamos un ejemplo:<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let s1 = String::from(&quot;Bolero - Maurice Ravel &quot;);<br>    f(s1);<br>    println!(&quot;{}&quot;,s1);<br>}<br></pre><br><br>Este código da error. Al hacer la llamada a la función f hemos transferido la propiedad del valor de s1 a f. Por ello, cuando intentamos hacer el print no vamos a poder ya que s1 ya no es dueña de la cadena de texto. Para solucionar estos problemas tenemos los préstamos.<br><h2>Prestando en Rust</h2><br>Rust permite prestar los valores de los que una variable es dueña de dos maneras: solo lectura o con escritura. Siempre ha de cumplirse la norma de que solo puede haber una con permiso de escritura pero puede haber infinidad con permiso de lectura. Y nunca se pueden dar las dos cosas a la vez.<br><br>El préstamo de lectura se realiza con el operador &amp;, que lo que hace es una referencia de lectura al valor. La variable sigue siendo sueña así del valor, solo lo ha prestado y entrega una referencia.<br><br><pre class="lang:rust decode:true"><br>fn main(){<br>    let s1 = String::from(&quot;Bolero - Maurice Ravel &quot;);<br>    f(&amp;s1);<br>    println!(&quot;{}&quot;,s1);<br>}<br></pre><br><br>Este código ya sí funciona y podemos ver en pantalla <a href="https://www.youtube.com/watch?v=r30D3SW4OVw" target="_blank" rel="noopener">Bolero - Maurice Ravel</a>.<br><br>Si queremos hacer el préstamo en modo escritura, hemos de usar &amp;mut. Sin entrar muchos detalles, así funcionaría un préstamo de escritura.<br><br><pre class="lang:rust decode:true"><br>fn f(s: &amp;mut String){<br>    s.push_str(&quot; &amp; Adios - Xavier Cugat&quot;);<br>}<br><br>fn main(){<br>    let mut s1 = String::from(&quot;Bolero - Maurice Ravel&quot;);<br>    f(&amp;mut s1);<br>    println!(&quot;{}&quot;,s1);<br>}<br></pre><br><br>Así tenemos por pantalla la frase <em>Bolero - Maurice Ravel &amp; <a href="https://www.youtube.com/watch?v=noWtmrsEQfw">Adios - Xavier Cugat</a></em>.<br><br>Este tipo de sintaxis, a priori compleja, nos ayudará mucho con la concurrencia pero de momento ya hemos visto suficiente.<br><br>&nbsp;