En la inocentada sobre Rust puse un vídeo de Jonathan Blow titulado <strong>Ideas about a new programming language for games</strong>. En el vídeo, Blow analiza los problemas que presenta C++ para el desarrollo de juegos y por qué según él ni Go ni D ni Rust consiguen mejorar la situación. El lenguaje de programación perfecto para juegos debería tener las siguientes características:<br><ul><br> 	<li>Poca fricción</li><br> 	<li>Placer por programar</li><br> 	<li>Rendimiento</li><br> 	<li>Simplicidad</li><br> 	<li>Diseñado para buenos programadores</li><br></ul><br>Con poca fricción se refiere a que la tarea de programar no debe añadir mucha complejidad para solucionar problemas que tendríamos si programásemos de la forma más simple posible. Fricción es para él RAII en C++. Fricción es la gestión de errores en Rust. Fricción se entiende como código que no añade significativamente nada pero que es necesario para un correcto funcionamiento. Fricción es rellenar papeleo de Hacienda. Muchos defensores de estas posturas argumentan que en realidad esa productividad perdida se recupera con el tiempo al reducir el número de bugs que pueden ocurrir. Blow dice que según su experiencia en juegos AAA realmente no compensa. Tardas más tiempo solventado bugs potenciales que bugs reales. Su solución no es evitar al 100% este tipo de bugs (como hace Rust) sino habilitar unas herramientas potentes que ayuden a solucionar estos bugs si alguna vez suceden.<br><br><a href="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-12-36-31.png"><img class="aligncenter size-full wp-image-650" src="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-12-36-31.png" alt="" width="855" height="481" /></a>Esto se relaciona con el placer por programar. Un lenguaje que te invite a programar, a experimentar, donde te sientas a gusto. Muchos lenguajes han perdido esa esencia. Con el tiempo muchos lenguajes se han ido complicando de forma innecesaria y se han ido volviendo pesadillas. Ruby sería el caso contrario, un lenguaje que conserva ese placer. Pero Ruby no entra en juego por razones obvias de rendimiento.<br><br>Con rendimiento básicamente dice que cualquier lenguaje que disponga de GC (recolector de basura) no es válido. Incluso Go, que tiene un GC mucho mejor que Java o la plataforma .NET no lo considera correcto.<br><br>Con simplicidad se busca legibilidad y potencia. El lenguaje debe ser uniforme, con cohesión en todos sus elementos.<br><br>Y con diseñado para buenos programadores se refiere a que el lenguaje no debe suponer que el programador es idiota e intentar corregir sus errores. Debe permitir hacer virguerías si así lo desea el programador. Rust está bien pues permite tener código <em>unsafe</em>. Justo lo que se necesita para hacer virguerías. Pero hace falta más trabajo en este aspecto pues supone un cambio de mentalidad.<br><h2>La idea detrás de RAII es incorrecta</h2><br>Mucha gente opina que RAII es una de las mejores cosas que han pasado en la programación. Muchos lenguajes presuponen RAII. D por ejemplo considera que RAII es la manera correcta de programar. <em>Resource Acquisition Is Initialization</em> consiste en que cada vez que vamos a acceder a un recurso tenemos que codificarlo en una clase, inicializar el recurso en un constructor y liberar el recurso en un destructor. Añades operadores para permitir copia, ... Este sistema presenta una elevada fricción. Y además no funciona bien, en el sentido de que todo se acaba sobrecomplicando. Alejándose de esa simplicidad que estamos buscando.<br><br>Uno de los principales problemas de este patrón de diseño es que no existe un <em>recurso.</em> Es una generalización errónea de varios conceptos. Un recurso puede ser memoria, otro recurso puede ser un archivo, una entrada de teclado, etc El problema es que estos recursos son demasiado diferentes como para ser tratados con un mismo patrón de forma óptima. Mientras RAII puede ser interesante hablando de archivos, es una muy mala opción si hablamos de memoria. Porque la memoria es el recurso más importante para un programador. Se podría simplificar diciendo que un programador lo único que hace es modificar la memoria constantemente.<br><br><a href="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-12-54-00.png"><img class="aligncenter size-full wp-image-651" src="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-12-54-00.png" alt="" width="854" height="480" /></a>Pero muchos de los usos de RAII tienen que ver con las excepciones. Y a Blow tampoco le gustan las excepciones. La gestión de errores en C es pésima pero las excepciones son muy complejas. Una de las cosas más complejas que implementan los lenguajes de programación que disponen de ellas. Y la implementación de C++ más todavía. Blow se lamenta de que haya gente que siga pensando que es una buena idea. Reduce la claridad del código, complica el flujo del programa. RAII en C++ ayuda a que en caso de que se de una excepción los recursos puedan ser liberados.<br><br>No solo lo dice él, sino que enlaza el siguiente vídeo: <em>Systematic Error Handling in C++</em> por Andrei Alexandrescu.<br><br><iframe src="https://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Andrei-Alexandrescu-Systematic-Error-Handling-in-C/player" width="960" height="540" frameborder="0" allowfullscreen="allowfullscreen"></iframe><br><a href="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-13-04-35.png"><img class="aligncenter size-full wp-image-652" src="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-13-04-35.png" alt="" width="854" height="479" /></a><br><h2>Un mejor sistema que las excepciones</h2><br>Go implementa múltiples valores de retorno (al contrario que la mayoría de lenguajes derivados de C donde solo de devuelve una cosa). Go lo soporta de forma nativa. Pero Matt Newport le responde como podría hacer eso en C++11 con <em>std::tie</em>.<br><br><pre class="lang:c++ decode:true"><br>#include &lt;iostream&gt;;<br>#include &lt;tuple&gt;;<br>#include &lt;functional&gt;;<br> <br>std::tuple&lt;int, int&gt; f()<br>{<br>    int x = 5;<br>    return std::make_tuple(x, 7); // return {x,7}; en C++17<br>}<br> <br>int main()<br>{<br>    int a, b;<br>    std::tie(a, b) = f();<br>    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;<br>}<br></pre><br><br>Rust, como Go, soporta esto de forma nativa:<br><br><pre class="lang:c++ decode:true"><br>fn f() -&gt; (i32,i32) {<br>	(4,7)<br>}<br><br>fn main() -&gt; () {<br>	let (a,b) = f();<br>	println!(&quot;A es {}, B es {}&quot;,a,b);<br>}<br></pre><br><br>Aunque no es la manera en la que Rust maneja los errores. En su lugar posee Option y Result que en C++17 también van a ser implementados en <em>std::optional</em> y que es en realidad un concepto presente en Haskell.<br><h2>Sintaxis exasperante</h2><br>En la charla Blow sigue hablando y comenta que desde un punto de visto purista y correcto la sintaxis de punteros de C++11 es incorrecta. Que <em>std::unique_ptr&lt;Vector3[]&gt;</em> implica que quieres un Unique Ptr basado en Vector3 pero en realidad la idea correcta sería quiero un Vector3 con características de Unique Ptr. Lo mismo es aplicable para <em>std::shared_ptr</em>. Este tipo de punteros no deberían estar expresados de esta forma sino que deberían entrar en la sintaxis del lenguaje, por su utilidad práctica.<br><br><a href="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-13-31-14.png"><img class="aligncenter size-full wp-image-653" src="https://files.adrianistan.eu/screenshot-www.youtube.com-2017-01-08-13-31-14.png" alt="" width="853" height="480" /></a>En Rust, el equivalente a <em>std::unique_ptr</em> sería <em>Box</em> que es el puntero más usado. El equivalente a <em>std::shared_ptr </em>sería <em>Rc</em>, no tan usado pero disponible.<br><br>Blow sigue hablando en este vídeo y en el siguiente de más errores que tiene C++, aunque de menor importancia. En todo caso, Blow sigue en el desarrollo de su compilador de Jai. C++ ha avanzado un montón y me ha llegado a sorprender que existiesen cosas como constexpr y los módulos de C++, una solución a los archivos de cabecera que son tan tediosos de escribir.<br><br>Si tenéis tiempo y sabéis inglés miráos el vídeo original. Creo que esta mucho mejor explicado que esto. Y también <a href="http://blog.mattnewport.com/raii/">la respuesta de Matt Newport en la que dice que C++ SÍ es válido</a> para todo lo que dice Blow.<br><iframe src="https://www.youtube-nocookie.com/embed/TH9VCN6UkyQ" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"></iframe>