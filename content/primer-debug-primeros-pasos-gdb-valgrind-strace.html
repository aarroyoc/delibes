¿A quién no le ha pasado? Estas programando en C++ y de repente cuando antes todo iba bien, ahora el programa se cierra inesperadamente (un <em>crash</em>) y no sabes el motivo. En algunos lenguajes como <a href="http://rust-lang.org">Rust</a>, el propio compilador y el lenguaje evitan estas situaciones, pero en C++ la situación es mucho más <em>estimulante</em>.<br><br>Recientemente, trabajando en <a href="http://adrianistan.eu/kovel/">Kovel</a> tuve uno de estos incidentes inesperados. Pero más inesperada fue su aparición, pues en <a href="http://debian.org">Debian</a>, donde programo actualmente, el programa se ejecutaba normalmente. Sin embargo en Windows el programa no llegaba a arrancar. Pensé que sería una diferencia Linux-Windows pero al probar en Fedora ocurrió lo mismo que en Windows, no llegaba a arrancar. Si encontraba el fallo en Fedora, que no se daba en Debian, resolvería también el fallo en Windows.<br><h2 id="preparandolaaplicacinyelentorno">Preparando la aplicación y el entorno</h2><br><h3 id="smbolosdedepuracin">Símbolos de depuración</h3><br>Aunque no es obligatorio, es recomedable compilar los ejecutables que vayamos a someter a depuración con símbolos de depuración. En Windows se usan archivos independientes (ficheros PDB) mientras que en Linux se usan los mismos ejecutables con más metadatos en su interior. En GCC simplemente hay que añadir la opción <strong>-g</strong> para retener los datos de depuración.<br><h3 id="ficheroscore">Ficheros core</h3><br>Ahora sería conveniente activar la generación de los ficheros <strong>core</strong> en el sistema. En algunas distro ya está activado:<br><pre><code>ulimit -c unlimited </code></pre><br>Los ficheros <strong>core</strong> los usaremos si nuestra aplicación se paró en un punto de difícil acceso o que no podemos recrear nosotros mismos.<br><h3 id="instalargdbvalgrindylossmbolosdelaslibreras">Instalar gdb, Valgrind y los símbolos de las librerías</h3><br>Ahora vamos a instalar el componente más importante, el debugger, la aplicación que usaremos para analizar la ejecución del programa.<br><br><img class="alignnone size-full wp-image-42" src="https://files.adrianistan.eu/gdb.png" alt="gdb" width="706" height="540" /><br><pre><code># En Fedora sudo dnf install gdb </code></pre><br>Además querremos tener los símbolos de depuración de las bibliotecas que use nuestro ejecutable. Con DNF, en Fedora, el proceso usa un comando específico:<br><pre><code>sudo dnf debuginfo-install wxGTK SDL libstdc++ # Y las librerías que usemos </code></pre><br>Y si queremos mantener los símbolos de depuración actualizados:<br><pre><code>sudo dnf --enablerepo=updates-debuginfo update </code></pre><br>Vamos a usar Valgrind también, aunque menos<br><pre><code>sudo dnf install valgrind </code></pre><br><h2 id="cazandoalvuelo">Cazando al vuelo</h2><br>Supongamos que sabemos como generar el error. Llamamos a nuestro programa desde <strong>gdb</strong>:<br><pre><code>gdb ./MiPrograma </code></pre><br>Entraremos en gdb, con su propios comandos de herramientas. Lo primero que haremos será iniciar el programa, con el comando <em>run</em> o <em>r</em><br><pre><code>(gdb) r </code></pre><br>El programa se iniciará. Nosotros provocaremos el error. Una vez lo hayamos provocado podremos introducir más comandos. Vamos a ver que pasos se han seguido para producir el error.<br><pre><code>(gdb) bt full </code></pre><br>Y desde aquí podemos inspeccionar que funciones fueron llamadas justo antes de que el programa <em>petase</em>. En este punto también podemos buscar el valor de ciertas variables que nos interesen con <em>p nombrevariable</em>.<br><h2 id="volviendoalpasado">Volviendo al pasado</h2><br>No sabemos como se produjo el error, pero tenemos un fichero <strong>core</strong> que nos va a permitir restablecer la situación del pasado para poder analizarla. Llamamos a gdb con el fichero core y nuestra aplicación.<br><pre><code>gdb ./MiPrograma ./core </code></pre><br>Una vez dentro podemos dirigirnos al punto crítico.<br><pre><code>(gdb) where </code></pre><br>Y analizamos como antes.<br><h2 id="valgrindyfugasdememoria">Valgrind y fugas de memoria</h2><br>Valgrind es muy usado para comprobar en que partes nuestro programa tiene fugas de memoria. En determinados casos puede ser más útil que gdb.<br><pre><code>valgrind --leak-check=yes ./MiPrograma </code></pre><br>Nuestro programa se ejecutará aproximadamente 20 o 30 veces más lento, pero se nos informará en todo momento de la gestión errónea de memoria que está produciéndose. En alguna situación será interesante saber de donde provienen estos fallos con mayor precisión, la opción <em>--track-origins=yes</em> es nuestra amiga.<br><pre><code>valgrind --leak-check=yes --track-origins=yes ./MiPrograma </code></pre><br>Valgrind es muy estricto y puede generar falsos positivos. Hay varias GUI disponibles para Valgrind, una de ellas es <a href="https://kcachegrind.github.io/html/Home.html">KCacheGrind</a>.<br><br><img class="alignnone size-large wp-image-55" src="https://files.adrianistan.eu/KCacheGrind-1024x859.gif" alt="KCacheGrind" width="840" height="705" /><br><br>Otra de ellas es <a href="https://web.archive.org/web/20170605084204/http://www.open-works.net:80/projects/valkyrie.html">Valkyrie</a><br><br><img class="alignnone size-large wp-image-127" src="https://files.adrianistan.eu/Valkyrie-1024x578.png" alt="Valkyrie" width="840" height="474" /><br><h2 id="ysialgnficheronoexiste">¿Y si algún fichero no existe?</h2><br>Para terminar vamos a suponer que nuestro programa falla porque hay un archivo que no logra encontrar y no puede abrirlo. Gracias a <strong>strace</strong> es posible saber que archivos está abriendo el programa.<br><pre><code>strace -eopen ./MiPrograma </code></pre><br>Y nos saldrá en tiempo real los archivos que ha abierto nuestro programa.<br><br><img class="alignnone size-large wp-image-107" src="https://files.adrianistan.eu/Strace-1024x578.png" alt="Strace" width="840" height="474" /><br><br>Y espero que con este pequeño resumen ya sepais que hacer cuando vuestro programa se cierra inesperadamente.