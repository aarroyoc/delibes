Ya he hablado de Rust varias veces en este blog. La última vez fue en el <a href="https://blog.adrianistan.eu/2016/11/20/usando-iron-web-framework-rust/">tutorial de Iron</a>, que os recomiendo ver si os interesa el tema del desarrollo web backend.<br><br>Hoy vamos a hablar de <a href="http://www.piston.rs">Piston</a>. Piston es una de las librerías más antiguas del ecosistema Rust. Surgida cuando todavía no existía Cargo, esta librería está pensada para el desarrollo de juegos. No es la única que existe en Rust pero sí la más conocida. Piston es una librería que te enseñará Rust de la mejor forma. Y ahora quiero disculparme, porque Piston no es una librería, son un montón, pero eso lo veremos enseguida. En primer lugar creamos un proyecto nuevo con Cargo.<br><pre>cargo new --bin ejemplo_piston<br>cd ejemplo_piston</pre><br>Ahora abrimos el archivo Cargo.toml, vamos a añadir las dependencias necesarias. Las dependencias en Piston son un poco complicadas, veamos:<br><ul><br> 	<li>Existen las dependencias core, implementan la API fundamental pero no pueden usarse por separado, son window, input y event_loop. Se usan a través de <em>piston</em>.</li><br> 	<li>Los backends de window, existen actualmente 3 backends: glutin, glfw, sdl2. Se importan manualmente.</li><br> 	<li>Graphics, una API 2D, no presente en core, pero al igual que las dependencias core necesita un backend.</li><br> 	<li>Los backends de graphics son varios: opengl, gfx y glium.</li><br> 	<li>Existe una dependencia que nos deja todo montado, <em>piston_window</em>. Esta trae por defecto el core de Piston, glutin, graphics y gfx.</li><br> 	<li>Luego existen dependencias extra, como por ejemplo para cargar texturas, estas las podremos ir añadiendo según las necesite el proyecto.</li><br></ul><br>Para simplificar añadimos <em>piston_window</em> únicamente:<br><br>&nbsp;<br><br><pre class="lang:rust decode:true"><br>[package]<br>name = &quot;piston_example&quot;<br>version = &quot;0.1.0&quot;<br>authors = [&quot;Adrián Arroyo Calle&quot;]<br><br>[dependencies]<br>piston_window = &quot;0.59.0&quot;<br></pre><br><br>&nbsp;<br><br>Ahora abrimos el archivo <em>main.rs</em>. Añadimos la crate de piston_window y los módulos que vamos a usar.<br><br><pre class="lang:rust decode:true"><br>extern crate piston_window;<br><br>use piston_window::*;<br>use std::path::Path;<br></pre><br><br>&nbsp;<br><br>Así mismo definimos un par de cosas para el resto del programa, la versión de OpenGL que usará Piston internamente y una estructura para guardar los movimientos de teclado.<br><br><pre class="lang:rust decode:true"><br>const OPENGL: OpenGL = OpenGL::V3_1;<br><br>struct Movement{<br>    up: bool,<br>    down: bool,<br>    left: bool,<br>    right: bool<br>}<br></pre><br><br>&nbsp;<br><br>En la función main podemos crear la ventana, especificando título y tamaño. Más opciones como V-Sync, pantalla completa y demás también están disponibles.<br><br><pre class="lang:rust decode:true"><br>fn main() {<br><br>    let mut window: PistonWindow = WindowSettings::new(&quot;Piston - Adrianistan&quot;,[640,480])<br>        .exit_on_esc(true)<br>        .opengl(OPENGL)<br>        .build()<br>        .unwrap();<br></pre><br><br>&nbsp;<br><br>Ahora cargamos la tipografía Sinkin Sans, que vamos a usar para dibujar texto en pantalla. Como hay dos posibles localizaciones comprobamos esos dos lugares antes de salir del programa si no se consigue cargar la fuente.<br><br><pre class="lang:rust decode:true"><br>    let mut glyphs = Glyphs::new(Path::new(&quot;SinkinSans.ttf&quot;),window.factory.clone()).unwrap_or_else(|_|{<br>        let glyphs = Glyphs::new(Path::new(&quot;target/debug/SinkinSans.ttf&quot;),window.factory.clone()).unwrap_or_else(|_|{<br>            panic!(&quot;Failed to open the font file. Check that SinkinSans.tff is in the folder&quot;);<br>        });<br>        glyphs<br>    });<br></pre><br><br>&nbsp;<br><br>Inicializamos la estructura de movimientos, generamos las dimensiones iniciales del rectángulo (que será un cuadrado en este caso), su color y la posición del ratón.<br><br><pre class="lang:rust decode:true"><br>    let mut mov = Movement{<br>        up: false,<br>        down: false,<br>        left: false,<br>        right: false<br>    };<br><br>    let mut dims = rectangle::square(50.0,50.0,100.0);<br>    let mut rect_color = color::BLACK;<br><br>    let mut mc: [f64; 2] = [0.0,0.0];<br></pre><br><br>&nbsp;<br><br>Ahora viene la parte importante, el bucle de eventos. El bucle va a funcionar infinitamente generando eventos por el camino (pueden ser eventos de inactividad también). Usamos la función draw_2d para dibujar en 2D. Hay dos maneras de dibujar un rectángulo, en primer lugar tenemos la forma abreviada y en segundo lugar una más completa que permite más opciones. Por último dibujamos el texto usando la fuente y realizando una transformación para que no quede el texto en la posición 0,0.<br><br><pre class="lang:rust decode:true"><br> while let Some(e) = window.next() {<br>        window.draw_2d(&amp;e, |c, g| {<br>            clear([0.5, 0.5, 0.5, 1.0], g);<br>            rectangle([1.0, 0.0, 0.0, 1.0], // color rojo, rgba<br>                        [0.0, 0.0, 100.0, 100.0], // dimensiones<br>                        c.transform, g); // transormacion y donde se va a dibujar<br><br>            let rect = Rectangle::new(rect_color);<br>            rect.draw(dims,&amp;c.draw_state,c.transform,g);<br>            text(color::BLACK,18,&quot;¡Saludos desde Piston!&quot;,&amp;mut glyphs,c.transform.trans(100.0,200.0),g); // aplicamos una transormacion, movemos las X 100 y las Y 200<br>        });<br></pre><br><br>&nbsp;<br><br>A continuación vamos a tratar cada evento de forma independiente, como todos los métodos devuelven Option, hemos de usar esta sintaxis con Some. En primer lugar tenemos un UpdateEvent, que básicamente nos informa del tiempo delta transcurrido. Recomiendo usar este evento para realizar los cambios en las geometrías, en este caso para mover el rectángulo.<br><br><pre class="lang:rust decode:true"><br>if let Some(upd_args) = e.update_args() {<br>            let dt = upd_args.dt;<br>            <br>                if mov.right {<br>                    dims[0] += dt*100.0;<br>                }<br>                if mov.left {<br>                    dims[0] -= dt*100.0;<br>                }<br>                if mov.up {<br>                    dims[1] -= dt*100.0;<br>                }<br>                if mov.down {<br>                    dims[1] += dt*100.0;<br>                }<br>        }<br></pre><br><br>Los siguientes dos eventos son opuestos, uno se activa cuando pulsamos una tecla y el otro cuando la soltamos. Comprobamos la tecla y modificamos la estructura movement en consecuencia.<br><br><pre class="lang:rust decode:true"><br>if let Some(Button::Keyboard(key)) = e.press_args() {<br>            if key == Key::W {<br>                mov.up = true;<br>            }<br>            if key == Key::S {<br>                mov.down = true;<br>            }<br>            if key == Key::A {<br>                mov.left = true;<br>            }<br>            if key == Key::D {<br>                mov.right = true;<br>            }<br>        };<br>        if let Some(Button::Keyboard(key)) = e.release_args() {<br>            if key == Key::W {<br>                mov.up = false;<br>            }<br>            if key == Key::S {<br>                mov.down = false;<br>            }<br>            if key == Key::A {<br>                mov.left = false;<br>            }<br>            if key == Key::D {<br>                mov.right = false;<br>            }<br>        };<br></pre><br><br>Por último, si queremos comprobar clicks del ratón hacemos algo similar. He añadido código para que cambio el color del rectángulo si pulsamos sobre él.<br><br><pre class="lang:rust decode:true"><br>if let Some(Button::Mouse(mb)) = e.release_args() {<br>            if mb == MouseButton::Left {<br>                let x = mc[0];<br>                let y = mc[1];<br>                if x &gt; dims[0] &amp;&amp; x &lt; dims[0] + dims[2] { if y &gt; dims[1] &amp;&amp; y &lt; dims[1] + dims[3] {<br>                        rect_color = if rect_color == [1.0,0.0,0.0,0.7]{<br>                            [0.0,1.0,0.0,0.7]<br>                        } else if rect_color == [0.0,1.0,0.0,0.7] {<br>                            [0.0,0.0,1.0,0.7]<br>                        } else{<br>                            [1.0,0.0,0.0,0.7]<br>                        }<br>                    }<br>                }<br>                <br>            }<br>        }<br></pre><br><br>A continuación un pequeño evento que guarda la última posición del ratón.<br><br><pre class="lang:rust decode:true"><br>        if let Some(mouse_cursor) = e.mouse_cursor_args() {<br>            mc = mouse_cursor;<br>        }<br>    }<br>}<br></pre><br><br>&nbsp;<br><br>Y con esto ya tenemos hecho un ejemplo en Piston.<br><br><a href="https://files.adrianistan.eu/Piston2DEjemplo.png"><img class="aligncenter size-full wp-image-686" src="https://files.adrianistan.eu/Piston2DEjemplo.png" alt="" width="657" height="518" /></a> <a href="https://files.adrianistan.eu/Piston2DEjemplo2.png"><img class="aligncenter size-large wp-image-687" src="https://files.adrianistan.eu/Piston2DEjemplo2.png" alt="" width="653" height="520" /></a><a href="https://files.adrianistan.eu/PistonEjemplo3.png"><img class="aligncenter size-full wp-image-688" src="https://files.adrianistan.eu/PistonEjemplo3.png" alt="" width="656" height="519" /></a><br><br>Si quieres tener un ejecutable para Windows sin que se muestre primero la consola debes compilar la versión que vas a distribuir con unos parámetros especiales. Si usas Rust con GCC usarás:<br><pre>cargo rustc --release -- -Clink-args="-Wl,--subsystem,windows"</pre><br>Si por el contrario usas Visual C++:<br><pre>cargo rustc --release -- -Clink-args="/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup"</pre><br>&nbsp;<br><br>Piston todavía se encuentra en fuerte desarrollo, en la API estan documentados todos los métodos pero aun así muchas veces no se sabe como hacer ciertas cosas. Piston soporta además 3D, contando con una librería especializada en vóxels. Veremos como evoluciona esta librería.