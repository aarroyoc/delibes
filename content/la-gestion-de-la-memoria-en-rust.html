Finalmente <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html">ha sido publicada la versión 1.0 de Rust</a>. El lenguaje diseñado por Mozilla basado en 3 principios:<br><ul><br> 	<li>Seguridad</li><br> 	<li>Concurrencia</li><br> 	<li>Rendimiento</li><br></ul><br>Hoy voy a hablar del primer principio, la razón principal para querer ser un sustituto de C++. Porque C++ está bien, pero puedes liarla mucho si no sabes lo que haces.<br><br><img class="alignnone size-large wp-image-100" src="https://files.adrianistan.eu/Rust-1024x576.jpg" alt="Rust" width="840" height="473" /><br><h2>El concepto de dueño</h2><br>En Rust todo tiene un dueño. No puede haber más de uno ni ninguno, debe ser uno exactamente.<br><pre class="lang:rust decode:true">fn main(){<br>	let A = 5;<br>    // El dueño de A es main()<br><br>}<br></pre><br>Hasta aquí todo es sencillo. Ahora pasaremos la variable A a otra función.<br><pre class="lang:rust decode:true">fn sumar(a: i32, b: i32) -&gt; i32{<br>	a+b<br>}<br>fn main(){<br>	let A = 5;<br>	let suma = sumar(A,4);<br>	println!("{}",suma);<br>}<br></pre><br>El programa compila y nos da el resultado, que es 9. En los lenguajes de bajo nivel las variables pueden usar memoria del stack o del heap. Un pequeño repaso sobre sus diferencias.<br><h6>Stack</h6><br><ul><br> 	<li>Se reserva su espacio en RAM cuando el programa arranca</li><br> 	<li>Son más rápidas de acceder</li><br> 	<li>No se les puede cambiar el tamaño</li><br> 	<li>Son más seguras</li><br></ul><br><h6>Heap</h6><br><ul><br> 	<li>Se debe reservar manualmente la RAM cuando queramos</li><br> 	<li>Son más lentas de acceder</li><br> 	<li>Pueden cambiar su tamaño en tiempo real</li><br> 	<li>Son menos seguras. Pueden dar lugar a fugas de memoria.</li><br></ul><br>En este último caso, la variable A cuyo dueño es main() le pasa la propiedad temporalmente a sumar(). La propiedad se devuelve a main() rápidamente y esta garantizado que así suceda. El compilador lo permite. Veamos ahora un ejemplo más complejo.<br><br>Veamos ahora un código más complejo<br><pre class="lang:rust decode:true">struct Config{<br>	debug_mode: bool<br>}<br><br>struct App{<br>	config: Config<br>}<br><br>fn main(){<br>	let config=Config{debug_mode: true};<br>	<br>	let app=App{config: config};<br>	<br>	println!("OK");<br>}<br></pre><br>Por supuesto el código compila pero este de aquí abajo no y solo he cambiado una línea.<br><pre class="lang:rust decode:true">struct Config{<br>	debug_mode: bool<br>}<br><br>struct App{<br>	config: Config<br>}<br><br>fn main(){<br>	let config=Config{debug_mode: true};<br>	<br>	let app=App{config: config};<br>	let backup=App{config: config}; // He añadido esta línea<br>	<br>	println!("OK");<br>}<br></pre><br>La razón es que cuando creamos la estructura de App por primera vez le prestamos config a la estructura app. Así la función main no le puede pasar la propiedad a backup porque ya se la prestó a app.<br><h2>Préstamos</h2><br>Para solucionar este problema Rust usa los préstamos. Así la propiedad de config seguirá siendo main() pero lo podrán usar las estructuras app y backup. Para usar referencias usamos el símbolo <em>&amp;</em>.<br><pre class="lang:rust decode:true">struct Config{<br>	debug_mode: bool<br>}<br><br>struct App{<br>	config: &amp;Config<br>}<br><br>fn main(){<br>	let config=Config{debug_mode: true};<br>	<br>	let app=App{config: &amp;config};<br>	let backup=App{config: &amp;config};<br>	<br>	println!("OK");<br>}<br></pre><br>La estrucura ahora acepta &amp;Config en vez de Config. Es de decir usa una referencia en vez de un valor. Sin embargo esto no compilará. El compilador normalmente deduce si es posible hacer una referencia a algo no existente, un fallo común en C++. En caso de tener dudas no compilará. Rust es bastante inteligente pero no es mágico. En el caso de la estructura App, es necesario indicar que la propiedad config vivirá el mismo tiempo que la estructura.<br><pre class="lang:rust decode:true">struct Config{<br>	debug_mode: bool<br>}<br><br>struct App&lt;'a&gt;{<br>	config: &amp;'a Config<br>}<br><br>fn main(){<br>	let config=Config{debug_mode: true};<br><br>	let app=App{config: &amp;config};<br>	let backup=App{config: &amp;config};<br>	println!("OK");<br>}<br></pre><br>He usado la anotación de tiempo llamada <em>a</em>. Puedes poner cualquier nombre pero <em>a</em> es muy corto.<br><h2>Implementaciones y préstamos</h2><br>Voy a introducir un concepto de Rust que son las implementaciones. Para haceros una idea rápida, serían como clases de C++, pero solo alojan funciones.<br><pre class="lang:rust decode:true">impl&lt;'a&gt; App&lt;'a&gt;{<br>	fn isDebugMode(&amp;self) -&gt; (){<br>		println!("DEBUG MODE: {}",self.config.debug_mode);<br>	}<br>	<br>	fn delete(self) -&gt; (){<br>		<br>	}<br>}<br></pre><br>He creado dos funciones para implementar App. Son idénticas salvo por un pequeño detalle, una toma el valor self (como this en C++) por referencia y la otra toma el valor directamente.<br><pre class="lang:rust decode:true">	let app=App{config: &amp;config};<br>	app.isDebugMode();<br>	app.delete();<br></pre><br>Compila y funciona. Cambiemos el orden.<br><pre class="lang:rust decode:true">    let app=App{config: &amp;config};<br>    app.delete();<br>    app.isDebugMode();<br></pre><br>Ya no compila. La razón es que cuando llamamos a delete() estamos prestando app entera. Ahora delete() es la dueña de app y cuando salimos de la función eliminamos app porque si su dueña ha muerto, app también debe morir (no es tan sangriento como pensais). Rust lo detecta y delete() será la última función que podemos llamar de app. Por cierto si os preguntais como funcionan las implementaciones en Rust (que no son clases), este código haría lo mismo llamando a funciones estáticas. Quizá así veais mejor como se pasa el concepto de dueños y préstamos.<br><pre class="lang:rust decode:true">	let app=App{config: &amp;Config};<br>    App::isDebugMode(&amp;app);<br>    App::delete(app);<br></pre><br><h2>Diversión con punteros en el heap</h2><br>Todo estas variables eran del stack que siempre es la manera más sencilla de operar. Vamos ahora a ver como funcionaría esto con punteros. Los punteros operan como variables en el stack que hacen referencia a partes de la memoria que están en el heap. En Rust podemos operar con punteros con máxima seguridad pues todo lo aplicable a variables en el stack sigue siendo válido. Solo hay un dueño y podemos hacer referencias, aunque quizá necesitemos marcar el tiempo de vida manualmente.<br><pre class="lang:rust decode:true">	let puntero: Box&lt;i32&gt;=Box::new(42);<br></pre><br>Ahora el valor 42 estará en el heap y con puntero podremos acceder a él. Sin embargo como es lógico, no podemos operar directamente con él.<br><pre class="lang:rust decode:true">	puntero+1 //No funciona<br></pre><br>Para operar el valor directamente tenemos que derreferenciarlo. Se usa *<br><pre class="lang:rust decode:true">	*puntero+1 // Sí funciona, y será 43<br></pre><br>Así que esta operación sería correcto. Nótese el uso de <strong>mut</strong> para permitir editar el valor. En Rust por defecto las variables no son mutables. Ese privilegio tiene que ser declarado por adelantado.<br><pre class="lang:rust decode:true">	let mut puntero: Box&lt;i32&gt;=Box::new(41);<br>    *puntero+=1;<br>  	println!("La respuesta es: {}",*puntero);<br></pre><br>Como curiosidad mencionar que la macro println! (en Rust si algo termina con <strong>!</strong> es una macro) acepta puntero o *puntero indistintamente ya que se da cuenta si es necesario derreferenciar o no.<br><h2>El problema final</h2><br>¿Qué pasaría si copiamos un puntero en otro? Pues como un valor en el heap solo puede tener un dueño, la propiedad será del último puntero.<br><pre class="lang:rust decode:true">	let mut puntero: Box&lt;i32&gt;=Box::new(41);<br>    *puntero+=1;<br>    let puntero_inmutable=puntero;<br>    println!("La respuesta es: {}",puntero); // Esta línea no compilará pues el acceso a la respuesta última del universo ahora es propiedad de puntero_inmutable<br>    println!("La respuesta, ahora sí, es: {}",puntero_inmutable);<br></pre><br>Como curiosidad, este es un curioso método para bloquear en un determinado momento el acceso de escritura a nuestro puntero aunque es fácil volver a obtener el acceso a escritura con un nuevo cambio de dueño.<br><h2>Conclusiones</h2><br>Podemos ver que es un lenguaje que presta mucha atención a la seguridad. C++ es mucho más liberal en ese sentido y Mozilla cree que es un problema a la hora de desarrollar grandes aplicaciones. ¿Qué te ha parecido? Si tienes alguna duda no titubees y pregunta.