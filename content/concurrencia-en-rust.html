Rust destaca por su soporte nativo a la concurrencia. Aquí veremos exactamente qué es lo que hace.<br><h2>Crear threads</h2><br>Todas las funciones relacionadas con threads están en <strong>std::thread</strong> así que primero hemos de importarlo con <strong>use</strong>. Para crear un thread usamos <strong>thread::spawn</strong>, que toma una función como argumento. Esta operación devuelve un <strong>JoinHandler</strong> que puede ser usado para esperar a que finalicen los hilos de ejecución.<br><br><pre class="lang:rust decode:true"><br>use std::thread;<br><br>fn main(){<br>    let handle = thread::spawn(||{<br>        for i in 1..100{<br>            println!(&quot;Attens ou va t'en - France Gall&quot;);<br>        }<br>    });<br>    handle.join();<br>    println!(&quot;Hilo finalizado&quot;);<br>}<br></pre><br><br>Aquí ya se presenta una cuestión interesante, ¿qué pasa si queremos llevar datos del hilo principal al nuevo thread? Si lo intentamos hacer, Rust se quejará. En realidad, tenemos que activar la closure con <strong>move</strong>. Lo que hace es transferir la propiedad del dato a la closure. Con eso podemos procesarlo tranquilamente en el hilo nuevo, siempre y cuando no intentemos acceder a él desde el hilo principal.<br><br><pre class="lang:rust decode:true"><br>use std::thread;<br><br>fn main(){<br>    let v = vec![&quot;Attens ou va t'en - Paul Mauriat&quot;,&quot;Attens ou va t'en - France Gall&quot;];<br>    let handle = thread::spawn(move ||{<br>        for i in v{<br>            println!(&quot;{}&quot;,i);<br>        }<br>    });<br>    handle.join();<br>    println!(&quot;Hilo finalizado&quot;);<br>}<br></pre><br><br><h2>Mensajes</h2><br>Una de las opciones que permite Rust para concurrencia es el paso de mensajes.<br><br><pre class="lang:rust decode:true"><br>use std::thread;<br>use std::sync::mpsc;<br>use std::time::Duration;<br><br><br>fn main(){<br>    let (tx,rx) = mpsc::channel();<br><br>    let h = thread::spawn(move ||{<br>        thread::sleep(Duration::new(5,0));<br>        let val = String::from(&quot;Attens ou va t'en - France Gall&quot;);<br>        tx.send(val).unwrap();<br>    });<br><br>    loop {<br>        if let Ok(msg) = rx.try_recv() {<br>            println!(&quot;{}&quot;,msg);<br>            break;<br>        }<br>    }<br>    // Opción síncrona<br>    //let msg = rx.recv().unwrap();<br>    //println!(&quot;{}&quot;,msg);<br><br>    // Opción Iterable<br>    // for msg in rx{<br>    //     println!(&quot;{}&quot;,msg);<br>    // }<br>}<br></pre><br><br>Tx es el objeto usado para transmitir y Rx para recibir. Tx lo puede tener cualquier hilo para mandar mensajes mientras que Rx está limitado al hilo principal. Existen varias formas de recibir los mensajes. <strong>try_recv</strong> no bloquea el hilo de ejecución, por lo que puede usarse en un bucle con <strong>if-let</strong>. <strong>recv</strong> es síncrono y bloquea el hilo de ejecución si hace falta. Tx también es <strong>Iterable</strong> así que podemos leer los mensajes en un bucle <strong>for-in</strong>.<br><h2>Mutex y Arc</h2><br>Cuando queremos compartir memoria en Rust tenemos que recurrir a una combinación de <strong>Mutex</strong> y <strong>Arc</strong>.<br><br><strong>Mutex</strong> provee de gestión del acceso a memoria. Para acceder al dato es necesario hacer <strong>lock</strong>. No es estrictamente necesario hacer unlock una vez hayamos modificado el dato, pues cuando Rust libere memoria, también hará unlock. Sin embargo, Mutex por sí solo no es suficiente.<br><br><strong>Arc</strong> (Atomic Reference Counter) permite tener datos con múltiples dueños. Esto funciona con una especie de recolector de basura y es útil porque cuando hablamos de hilos podría darse la situación de que el hilo dueño muriese y un hilo con los datos prestados todavía siguiese vivo. Con <strong>clone</strong> conseguimos una copia para mover libremente que en realidad referencia al mismo dato en memoria.<br><br><pre class="lang:rust decode:true"><br>use std::thread;<br>use std::sync::{Mutex,Arc};<br><br>fn main(){<br>    let counter = Arc::new(Mutex::new(42));<br>    let mut handles = vec![];<br><br>    for _ in 0..10 {<br>        let counter = counter.clone();<br>        let handle = thread::spawn(move || {<br>            let mut num = counter.lock().unwrap();<br><br>            *num += 1;<br>        });<br>        handles.push(handle);<br>    }<br><br>    for handle in handles {<br>        handle.join().unwrap();<br>    }<br><br>    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());<br>}<br></pre><br><br>Con esto ya tendremos lo suficiente para manejar concurrencia en Rust. Por supuesto, esto es más complejo que esto y si de verdad quieres aprovechar el potencial al máximo quizá debas revisar la documentación de las traits <strong>Send</strong> y <strong>Sync</strong>.<br><br>&nbsp;<br><br>&nbsp;