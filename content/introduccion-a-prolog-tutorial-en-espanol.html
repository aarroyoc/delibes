<strong>Prolog</strong> es un lenguaje de programación lógico, quizá uno de los más populares de este paradigma ya que fue el primero en implementarlo, en el año 1972 en Francia.<br><br>Durante un tiempo, se creyó que PROLOG supondría la revolución de los lenguajes de programación,<a href="http://hemeroteca.abc.es/nav/Navigate.exe/hemeroteca/madrid/abc/1986/10/12/171.html"> siendo uno de los estandartes de los lenguajes de programación de quinta generación</a>. Tanto se creía que Borland, la famosa empresa de compiladores para MS-DOS, tenía <em>Turbo Prolog</em>, junto a <em>Turbo C++, Turbo Pascal, Turbo Assembler y Turbo Basic</em>.<br><br>Desafortunadamente, Prolog no triunfó como se esperaba y solo fue usado dentro del mundo de la Inteligencia Artificial. Existe un estándar ISO sobre Prolog (al igual que Ada, C++ y otros lenguajes estandarizados) pero no es demasiado influyente. Tampoco ha habido ningún éxito en alguna de las versiones propuestas para dotarle de orientación a objetos al lenguaje.<br><br>Prolog sin embargo ha influenciado a algunos lenguajes como <a href="https://www.erlang.org/">Erlang</a>, que toman algunos aspectos de él.<br><br>No obstante, Prolog sigue siendo un lenguaje muy interesante, diferente al resto de lenguajes (tanto imperativos, como funcionales), así que pongámonos a ello.<br><br>Actualmente existen varios compiladores de Prolog: SWI Prolog, GNU Prolog, Visual Prolog (al mucha gente no lo considera Prolog de verdad), ...<br><br>La mejor versión bajo mi punto de vista es <a href="http://www.swi-prolog.org/">SWI Prolog</a>, que tiene una librería de <em>predicados</em> bastante extensa. Es rápido y permite generar ejecutables <em>nativos</em> (realmente no lo son, pero la máquina virtual de Prolog ocupa muy poco y apenas se nota en el tamaño del ejecutable).<br><br>Lo podéis descargar gratuitamente desde <a href="http://www.swi-prolog.org/">su página oficial</a> que como curiosiad, está hecha en SWI Prolog. También está en la paquetería de las distribuciones GNU/Linux habituales.<br><h2>Nuestro primer programa</h2><br>Para empezar con Prolog voy a tomar un camino distinto de muchos tutoriales y voy a empezar haciendo un programa con Entrada/Salida y que se ejecute como un binario independiente. La potencia de Prolog no está ahí especialmente, pero es un buen punto de partida<br><br>Para ello definimos un <strong>predicado</strong> main de la siguiente forma y lo guardamos en un fichero <strong>main.pl</strong>.<br><pre class="lang:default decode:true">main :- <br>	write("Hola Mundo"),<br>	nl,<br>	write("¿Cuál es tu nombre? "),<br>	read_string(user_input,['\n'],[],_,Nombre),<br>	write("Hola "),write(Nombre),nl,<br>	halt.<br></pre><br>¿Qué hace el programa? Imprime en pantalla Hola Mundo (<strong>write</strong>), una nueva línea (<strong>nl</strong>), lee un string de teclado con el separador \n y lo <em>unifica </em>con la variable Nombre. Esto ya veremos que significa, pero de momento puedes pensar que Nombre es una variable de salida y que a partir de ahí Nombre tiene un valor establecido.<br><br>Compilamos con el siguiente comando:<br><pre class="lang:default decode:true">swipl --goal=main --stand_alone=true -o main -c main.pl</pre><br><a href="https://files.adrianistan.eu/PrologCompile.png"><img class="aligncenter size-full wp-image-1418" src="https://files.adrianistan.eu/PrologCompile.png" alt="" width="726" height="383" /></a>Con esto le decimos a SWI Prolog que el objetivo a demostrar es <strong>main</strong> y que nos genere un fichero <strong>stand_alone</strong> (independiente).<br><br>Y ejecutamos el fichero ejecutable como uno más.<br><br><a href="https://files.adrianistan.eu/PrologExecute.png"><img class="aligncenter size-full wp-image-1417" src="https://files.adrianistan.eu/PrologExecute.png" alt="" width="724" height="89" /></a>Ahora que ya sabemos como se generan programas compilados, vamos a introducirnos más en lo que hace especial a Prolog.<br><h2>La terminal de Prolog</h2><br>Prolog fue diseñado con una terminal interactiva en mente. La idea era que el usuario fuese introduciendo preguntas y el programa en Prolog fuese contestando. Este enfoque, similar a usar un programa desde el REPL de tu lenguaje, no ha acabado cuajando, pero es necesario pasar por él. Más adelante veremos como con SWI Prolog no hace falta usar la terminal. La terminal se abre escribiendo <strong>swipl</strong> en la línea de comandos:<br><br><a href="https://files.adrianistan.eu/SWIProlog.png"><img class="aligncenter size-full wp-image-1404" src="https://files.adrianistan.eu/SWIProlog.png" alt="" width="726" height="237" /></a>Vemos un símbolo de interrogación. Eso nos permite saber que estamos en una terminal de Prolog. Podemos escribir <em>write("Hola").</em> y tener nuestro hola mundo tradicional, aunque no es muy interesante, pero sí es muy interesante que después escribe <strong>true</strong>. Más adelante veremos por qué.<br><h2>Los programas Prolog</h2><br>En Prolog los programas son algo diferentes a lo que estamos acostumbrados. Realmente en Prolog no hay <em>programas</em> sino una <em>base de datos</em>. Un programa se compone de <em>predicados</em>, muy parecidos a los del <a href="https://es.wikipedia.org/wiki/L%C3%B3gica_de_primer_orden"><em>Cálculo de Predicados</em></a>. Los predicados aportan información sobre las relaciones entre elementos. Todos los predicados tienen que acabar en punto.<br><br>Siguiendo las mismas normas que el cálculo de predicados:<br><ul><br> 	<li>Las constantes empiezan por minúscula</li><br> 	<li>Las variables empiezan por mayúscula</li><br> 	<li>Las funciones son constantes seguidas de N teŕminos. Son funciones estrictamente matemáticas.</li><br> 	<li>Los predicados pueden ser atómicos o compuestos, con operadores lógicos (and, or, implica, etc)</li><br></ul><br>Prolog durante la ejecución, va a intentar <strong>demostrar</strong> que el predicado es cierto, usando el <a href="https://en.wikipedia.org/wiki/Backtracking">algoritmo de backtracking</a>. Y ahí está la verdadera potencia de Prolog. Veamos unos ejemplos:<br><pre class="lang:default decode:true" title="comida.pl">fruta(manzana).<br>fruta(naranja).<br>fruta(platano).</pre><br>Guarda ese archivo con extensión .pl y ejecuta <strong>swipl comida.pl<em>.</em></strong><br><br><a href="https://files.adrianistan.eu/PrologArchivo.png"><img class="aligncenter size-full wp-image-1405" src="https://files.adrianistan.eu/PrologArchivo.png" alt="" width="729" height="346" /></a>Ahora en la terminal podemos hacer preguntas. ¿Es la manzana una fruta? Prolog responde verdadero. ¿Es la pera una fruta? Prolog responde que falso, porque según el archivo comida.pl, no lo es. Prolog no es inteligente, no sabe que significan las palabras, simplemente actúa siguiendo un conjunto de normas formales.<br><br>Hemos dicho que Prolog tiene variables. Una variable en Prolog es un marcador de <em>hueco</em>, es algo que no existe, porque no es ninguna constante en específico. Veamos la potencia de las variables con este otro predicado.<br><br><a href="https://files.adrianistan.eu/PrologMultiple.png"><img class="aligncenter size-full wp-image-1406" src="https://files.adrianistan.eu/PrologMultiple.png" alt="" width="728" height="130" /></a>En este caso pedimos demostrar <em>fruta(X).</em>. Prolog buscará la primera solución que demuestra el predicado, que es que X valga manzana. Aquí podemos pulsar ENTER y Prolog se para o pulsar N y Prolog busca otra solución. ¿Potente, verdad? Prolog realiza un proceso interno que se llama <strong>unificación</strong>, es importante saber como funciona para ver que hace Prolog en realidad.<br><h2>Unificación</h2><br>La unificación es un proceso que combina dos predicados en uno que encaja. Para ello buscamos las sustituciones de valores con los que dos predicados son compatibles (realmente solo se pueden modificar las variables). No obstante, Prolog busca siempre el unificador más general, que es aquel que unifica dejando los predicados de forma más genérica posible, es decir, que pueden usarse con más valores.<br><br><a href="https://files.adrianistan.eu/Unificacion-2.png"><img class="aligncenter size-large wp-image-1414" src="https://files.adrianistan.eu/Unificacion-2-724x1024.png" alt="" width="724" height="1024" /></a><br><br>Espero que esta imagen aclare el concepto de unificación. Básicamente Prolog para intentar demostrar un predicado intentará unificar con otros predicados del programa. Así cuando ponemos por ejemplo <em>comida(manzana)</em> , unifica con <em>comida(X)</em> así que Prolog toma ese predicado para continuar.<br><h2>Backtracking</h2><br>Cuando Prolog intenta demostrar un predicado aplica el algoritmo de backtracking. Este algoritmo recorre todas las soluciones posibles pero de forma más inteligente que la fuerza bruta. Backtracking intenta conseguir una solución hasta que un predicado falla, en ese momento, Prolog <strong>va hacia atrás</strong> y continúa por otra vía que pueda seguir.<br><br><a href="https://files.adrianistan.eu/Backtracking.png"><img class="aligncenter size-full wp-image-1420" src="https://files.adrianistan.eu/Backtracking.png" alt="" width="500" height="447" /></a>Cada predicado es un nodo. Si un predicado falla se vuelve atrás. Esto es muy interesate ya que Prolog técnicamente puede <strong>ejecutar código hacia atrás</strong>.<br><br>Un predicado Prolog sigue esta estructura:<br><br><a href="https://files.adrianistan.eu/PrologFlow.png"><img class="aligncenter size-full wp-image-1421" src="https://files.adrianistan.eu/PrologFlow.png" alt="" width="256" height="256" /></a><br><h2>Predicados avanzados</h2><br>Pero los predicados de Prolog no tienen por qué ser así de simples. Normalmente se usa el operador :- para indicar algo que para que se cumpla la parte de la izquierda, tiene que cumplirse la parte de la derecha antes (en cálculo de predicados es ←).<br><br>Por ejemplo, todas las frutas son comidas, así que podemos añadir esto a nuestro archivo.<br><pre class="lang:default decode:true ">fruta(manzana).<br>fruta(naranja).<br>fruta(platano).<br><br>comida(X) :- fruta(X).</pre><br>Y los predicados en Prolog se pueden repetir y repetir y repetir. Prolog siempre intenta demostrar de arriba a abajo, si falla un predicado, prueba con el siguiente más para abajo y termina cuando no hay más predicados que probar. ¡Así que podemos definir comida en base a más predicados!<br><pre class="lang:default decode:true">fruta(manzana).<br>fruta(naranja).<br>fruta(platano).<br><br>carne(pollo).<br>carne(vaca).<br>carne(cerdo).<br>carne(caballo).<br><br>comida(paella).<br>comida(pulpo).<br><br>comida(X) :- fruta(X).<br>comida(X) :- carne(X).<br></pre><br><h2><a href="https://files.adrianistan.eu/TodoComidas.png"><img class="aligncenter size-full wp-image-1407" src="https://files.adrianistan.eu/TodoComidas.png" alt="" width="722" height="229" /></a>Operaciones</h2><br>En Prolog existen varios operadores importantes:<br><ul><br> 	<li>, (coma) AND</li><br> 	<li>; (punto y coma) OR</li><br> 	<li>A = B, se intenta unificar A y B. Devuelve true si funciona</li><br> 	<li>A \= B es falso si A y B unifican</li><br> 	<li>A is B, se evalúa B (es decir, se calcula lo que representa) y se unifica con A</li><br> 	<li>A =:= B , evalúa A, evalúa B y los compara. Verdadero si son iguales</li><br> 	<li>A =\= B, evalúa A, evalúa B y los compara. Falso si son iguales</li><br> 	<li>Y muchos otros como =&lt;, &gt;=, &gt;, &lt; que tienen el comportamiento esperado.</li><br> 	<li>Las operaciones matemáticas solo se pueden introducir en expresiones que vayan a ser evaluadas.</li><br></ul><br>Quiero prestar especial atención en símbolo de igual que <strong>no es asignación</strong> sino unificación, pero puede parecerse. Estas dos líneas son equivalentes:<br><pre class="lang:default decode:true ">X = 5<br>% y <br>5 = X</pre><br>Ya que en ambos casos se unifica X con 5.<br><br>Veamos un ejemplo de todo esto, ya mucho más realista.<br><pre class="lang:default decode:true " title="restaurante.pl">%%%%%%%%%%%%%%%%%%%%%%%%%%%<br>%   Programa restaurante  %<br>%%%%%%%%%%%%%%%%%%%%%%%%%%%	<br><br>% menu<br><br>entrada(paella).<br>entrada(gazpacho).<br>entrada(pasta).<br><br>carne(filete_de_cerdo).<br>carne(pollo_asado).<br><br>pescado(trucha).<br>pescado(bacalao).<br><br>postre(flan).<br>postre(nueces_con_miel).<br>postre(naranja).<br><br>% Valor calorico de una racion<br><br>calorias(paella, 200).<br>calorias(gazpacho, 150).<br>calorias(pasta, 300).<br>calorias(filete_de_cerdo, 400).<br>calorias(pollo_asado, 280).<br>calorias(trucha, 160).<br>calorias(bacalao, 300).<br>calorias(flan, 200).<br>calorias(nueces_con_miel, 500).<br>calorias(naranja, 50).<br><br>% plato_principal(P) P es un plato principal si es carne o pescado<br><br>plato_principal(P):- carne(P).<br>plato_principal(P):- pescado(P).<br><br>% comida(Entrada, Principal, Postre)<br><br>comida(Entrada, Principal, Postre):-<br>        entrada(Entrada),<br>        plato_principal(Principal),<br>        postre(Postre).<br>    <br>% Valor calorico de una comida<br><br>valor(Entrada, Principal, Postre, Valor):-<br>        calorias(Entrada, X),<br>        calorias(Principal, Y),<br>        calorias(Postre, Z),<br>        sumar(X, Y, Z, Valor).<br><br>% comida_equilibrada(Entrada, Principal, Postre)<br><br>comida_equilibrada(Entrada, Principal, Postre):-<br>        comida(Entrada, Principal, Postre),<br>        valor(Entrada, Principal, Postre, Valor),<br>        menor(Valor, 600).<br><br><br>% Conceptos auxiliares<br><br>sumar(X, Y, Z, Res):-<br>        Res is X + Y + Z.             % El predicado "is" se satisface si Res se puede unificar<br>                                      % con el resultado de evaluar la expresion X + Y + Z <br>menor(X, Y):- <br>        X &lt; Y.                        % "menor" numerico<br><br>dif(X, Y):-<br>        X =\= Y.                      % desigualdad numerica <br><br><br>% cuantas comidas llevan naranja de postre<br>%<br><br>comidas_con_naranja :-<br>	write("Comidas con naranja: "),<br>	aggregate_all(count,comida(_,_,naranja),X),<br>	write(X),<br>	nl.<br></pre><br>Lo cargamos con <strong>swipl restaurante.pl </strong>y podemos contestar a las siguientes preguntas de forma sencilla:<br><br><em>¿Qué valor calórico tiene la comida de paella, trucha y flan?</em><br><pre class="lang:default decode:true ">valor(paella,trucha,flan,N).</pre><br><em>Dime una comidas equilibrada que lleve naranja de postre</em><br><pre class="lang:default decode:true ">comida_equilibrada(X,Y,Z),Z=naranja.</pre><br><a href="https://files.adrianistan.eu/PrologRestaurante.png"><img class="aligncenter size-full wp-image-1415" src="https://files.adrianistan.eu/PrologRestaurante.png" alt="" width="727" height="342" /></a><em>¿Cuántas comidas con naranja hay?</em><br><pre class="lang:default decode:true">comidas_con_naranja.</pre><br><h2>Variables anónimas y predicados predefinidos</h2><br>Si te fijas en el predicado <em>comidas_con_naranja</em>, es diferente al resto. Esta programado de otra forma. La salida por pantalla se hace con write como ya habíamos visto al principio, write es un predicado que siempre es cierto y en caso de backtracking simplemente pasa. <strong>aggregate_all</strong> es también otro predicado incluido en SWI Prolog, para en este caso, contar cuantas soluciones tiene el predicado <em>comida(_,_,naranja)</em>. X unifica en aggregate_all con el valor que toca (que es una constante, los números son constantes) y en las siguientes sentencias (write), X ha sido sustituido por el valor con el que unificó en aggregate_all.<br><br>Por otro lado, ¿qué significa la barra baja? Es una <strong>variable anónima</strong>. Cuando no usamos una variable en más lugares y no nos interesan sus valores podemos simplemente poner barra baja.<br><h2>Listas en Prolog</h2><br>Prolog tiene un tipo de dato más avanzado, las listas. Su tamaño es dinámico y es conveniente distinguir la cabeza de la cola. La cabeza es el primer elemento de una lista, la cola el resto de la lista.<br><br>Las listas se crean con corchetes:<br><pre class="lang:default decode:true">X = [1,2,3,4,5],<br>sumlist(X,N).</pre><br><strong>sumlist</strong> es un predicado de SWI que hace la suma de todos los elementos de una lista.<br><br>Con la barra podemos separar cabeza y cola de una lista:<br><pre class="lang:default decode:true">[1,2,3,4] = X,<br>[H|T] = X.</pre><br><h3><a href="https://files.adrianistan.eu/PrologLista.png"><img class="aligncenter size-full wp-image-1422" src="https://files.adrianistan.eu/PrologLista.png" alt="" width="726" height="140" /></a>Implementando sumlist</h3><br>Vamos a ver como se puede implementar sumlist con Prolog de forma sencilla.<br><pre class="lang:default decode:true">sumar([],0).<br>sumar([H|T],N) :-<br>	sumar(T,X),<br>	N is X+H.</pre><br>El predicado es sencillo, para un caso base de lista vacía, la suma es 0. Para otros casos más complejos separamos la lista en cabeza H y cola T y la suma es N. Esta suma se define como el resultado de sumar T (queda en X) y la cabeza H.<br><h2><strong>Assert y retract<br></strong></h2><br>¿Podemos crear predicados en tiempo real? Claro. Prolog provee de los predicados especiales <strong>assert</strong> para añadir y <strong>retract</strong> para eliminar un predicado.<br><h2><a href="https://files.adrianistan.eu/PrologAssert.png"><img class="aligncenter size-full wp-image-1423" src="https://files.adrianistan.eu/PrologAssert.png" alt="" width="721" height="365" /></a>Operador de corte</h2><br>Prolog tiene un operador muy controvertido, el operador de corte, !. Se trata de un operador que permite no volver hacia atrás. Hay que intentar no usarlo, pero muchas veces mejora el rendimiento.<br><h2>Metaprogramación</h2><br>Prolog tiene un gran soporte para la metaprogramación. Assert y Retract son ya formas de metaprogramación, no obstante Prolog tiene muchas más.<br><br><strong>call</strong> permite ejecutar código Prolog desde Prolog.<br><br><strong>setarg</strong> permite modificar un término de un predicado y <strong>arg </strong>unifica una variable con el término de un predicado que queramos. <strong>nb_setarg</strong> es la versión de setarg que en caso de backtracking no deshace la operación. Un ejemplo de esto lo podemos encontrar en la definición de <strong>aggregate_all</strong> en la librería de SWI Prolog:<br><pre class="lang:default decode:true ">aggregate_all(count, Goal, Count) :-<br>    !,<br>    aggregate_all(sum(1), Goal, Count).<br>aggregate_all(sum(X), Goal, Sum) :-<br>    !,<br>    State = state(0),<br>    (  call(Goal),<br>           arg(1, State, S0),<br>           S is S0 + X,<br>           nb_setarg(1, State, S),<br>           fail<br>    ;  arg(1, State, Sum)<br>).</pre><br>&nbsp;<br><h2>Debug con trace</h2><br>Prolog posee un predicado muy útil para hacer debugging. Es <strong>trace</strong> y con el predicado que vaya a continuación podremos inspeccionar todas las operaciones del motor de backtracking.<br><br><a href="https://files.adrianistan.eu/PrologTrace.png"><img class="aligncenter size-full wp-image-1424" src="https://files.adrianistan.eu/PrologTrace.png" alt="" width="720" height="428" /></a>