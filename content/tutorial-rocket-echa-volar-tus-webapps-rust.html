Previamente ya hemos hablado de <a href="https://blog.adrianistan.eu/2016/11/20/usando-iron-web-framework-rust/">Iron como un web framework</a> para Rust. Sin embargo desde que escribí ese post ha surgido otra librería que ha ganado mucha popularidad en poco tiempo. Se trata de Rocket. Un web framework que propone usar el rendimiento que ofrece Rust sin sacrificar la facilidad de uso de otros lenguajes.<br><h2>Rocket lleva las pilas cargadas</h2><br>A diferencia de Iron, Rocket incluye bastantes prestaciones por defecto con soporte para:<br><ul><br> 	<li>Plantillas</li><br> 	<li>Cookies</li><br> 	<li>Formularios</li><br> 	<li>JSON</li><br> 	<li>Soporte para rutas dinámicas</li><br></ul><br><h2><a href="https://files.adrianistan.eu/Rocket.png"><img class="aligncenter size-large wp-image-746" src="https://files.adrianistan.eu/Rocket-1024x499.png" alt="" width="840" height="409" /></a>Un "Hola Mundo"</h2><br>Rocket necesita una versión nightly del compilador de Rust. Una vez lo tengas creamos una aplicación con Cargo.<br><pre class="lang:default decode:true">cargo new --bin rocket_app<br></pre><br>Ahora modificamos el fichero Cargo.toml generado en la carpeta rocket_app para añadir las siguientes dependencias:<br><pre class="lang:default decode:true">rocket = "0.2.4"<br>rocket_codegen = "0.2.4"<br>rocket_contrib = "*"<br></pre><br>Editamos el archivo src/main.rs para que se parezca algo a esto:<br><pre class="lang:rust decode:true">#![feature(plugin)]<br>#![plugin(rocket_codegen)]<br><br>extern crate rocket;<br><br>#[get("/")]<br>fn index() -&gt; &amp;'static str {<br>    "El cohete ha despegado"<br>}<br><br>fn main() {<br>    rocket::ignite().mount("/",routes![index]).launch();<br>}<br></pre><br>Con esto iniciamos Rocket y dejamos a la función index que gestione las peticiones GET encaminadas a /. El servidor devolverá <em>El cohete ha despegado</em>.<br><br>Ahora si ejecutamos <strong>cargo run</strong> veremos algo similar a esto:<br><br><a href="https://files.adrianistan.eu/RocketLaunch.png"><img class="aligncenter size-full wp-image-749" src="https://files.adrianistan.eu/RocketLaunch.png" alt="" width="668" height="440" /></a>Vemos que el servidor ya está escuchando en el puerto 8000 y está usando todos los cores (en mi caso 4) del ordenador.<br><h2>Configurar Rocket</h2><br>Rocket dispone de varias configuraciones predeterminadas que afectan a su funcionamiento. Para alternar entre las configuraciones debemos usar variables de entorno y para modificar las configuraciones en sí debemos usar un fichero llamado Rocket.toml.<br><br>Las configuraciones por defecto son: dev (development), stage (staging) y prod (production). Si no indicamos nada, Rocket se inicia con la configuración dev. Para arrancar con la configuración de producción modificamos el valor de ROCKET_ENV.<br><pre class="lang:default decode:true">ROCKET_ENV=prod cargo run --release<br></pre><br>Sería el comando para arrancar Rocket en modo producción. En el archivo Rocket.toml se puede modificar cada configuración, estableciendo el puerto, el número de workers y parámetros extra pero no vamos a entrar en ello.<br><h2>Rutas dinámicas</h2><br>Rocket soporta rutas dinámicas. Por ejemplo, si hacemos <em>GET  /pelicula/Intocable</em> podemos definir que la parte del nombre de la película sea un parámetro. Esto hará que la función encargada de /pelicula/Intocable y de /pelicula/Ratatouille sea la misma.<br><pre class="lang:rust decode:true">#![feature(plugin)]<br>#![plugin(rocket_codegen)]<br><br>extern crate rocket;<br><br>#[get("/pelicula/&lt;pelicula&gt;")]<br>fn pelicula(pelicula: &amp;str) -&gt; String {<br>    format!("Veo que te gusta {}, a mi también!",pelicula)<br>}<br><br>#[get("/")]<br>fn index() -&gt; &amp;'static str {<br>    "El cohete ha despegado"<br>}<br><br>fn main() {<br>    rocket::ignite().mount("/",routes![index,pelicula]).launch();<br>}<br></pre><br>Los argumentos de la función son los parámetros de la petición GET. ¿Qué pasa si no concuerda el tipo de la función con lo que se pasa por HTTP? Nada. Sencillamente Rocket ignora esa petición, busca otra ruta (puede haber sobrecarga de rutas) y si encuentra otra que si satisfaga los parámetros será esa la escogida. Para especificar el orden en el que se hace la sobrecarga de rutas puede usarse rank. En caso de no encontrarse nada, se devuelve un error 404.<br><h2>POST, subir JSON y formularios</h2><br>Rocket se integra con Serde para lograr una serialización/deserialización con JSON inocua. Si añadimos las dependencias <strong>serde,</strong> <strong>serde_json</strong> y <strong>serde_derive</strong> al fichero Cargo.toml podemos tener un método que acepete una petición POST solo para mensajes del tipo application/json con deserialización incorporada.<br><pre class="lang:rust decode:true">#![feature(plugin)]<br>#![plugin(rocket_codegen)]<br><br>#[macro_use] extern crate rocket_contrib;<br>#[macro_use] extern crate serde_derive;<br>extern crate serde_json;<br>extern crate rocket;<br><br>use rocket_contrib::{JSON, Value};<br><br>#[derive(Serialize,Deserialize)]<br>struct User{<br>    name: String,<br>    email: String<br>}<br><br>#[post("/upload", format="application/json", data="&lt;user&gt;")]<br>fn upload_user(user: JSON&lt;User&gt;) -&gt; JSON&lt;Value&gt; {<br>    JSON(json!({<br>        "status" : 200,<br>        "message" : format!("Usuario {} registrado con éxito",user.email)<br>    }))<br>}<br><br>fn main() {<br>    rocket::ignite().mount("/",routes![upload_user]).launch();<br>}<br></pre><br>Si el JSON no se ajusta a la estructura User simplemente se descarta devolviendo un error 400.<br><br>Lo mismo que es posible hacer con JSON puede hacerse con formularios usando el trait FromForm.<br><pre class="lang:rust decode:true">#![feature(plugin,custom_derive)]<br>#![plugin(rocket_codegen)]<br><br>#[macro_use] extern crate rocket_contrib;<br>#[macro_use] extern crate serde_derive;<br>extern crate serde_json;<br>extern crate rocket;<br><br>use rocket_contrib::{JSON, Value};<br>use rocket::request::{FromForm, Form};<br><br>#[derive(FromForm)]<br>struct User{<br>    name: String,<br>    email: String<br>}<br><br>#[post("/upload", data="&lt;user&gt;")]<br>fn upload_user(user: Form&lt;User&gt;) -&gt; String {<br>    format!("Hola {}",user.get().name)<br>}<br><br>fn main() {<br>    rocket::ignite().mount("/",routes![upload_user]).launch();<br>}<br></pre><br><h2>Errores</h2><br>En Rocket, como es lógico, es posible crear páginas personalizadas para cada error.<br><pre class="lang:rust decode:true">#![feature(plugin,custom_derive)]<br>#![plugin(rocket_codegen)]<br><br>#[get("/")]<br>fn index() -&gt; &amp;'static str {<br>    "El cohete ha despegado"<br>}<br><br>#[error(404)]<br>fn not_found() -&gt; &amp;'static str {<br>    "La página no ha podido ser encontrada"<br>}<br><br>fn main() {<br>    rocket::ignite().mount("/",routes![index]).catch(errors![not_found]).launch();<br>}<br></pre><br>La lista de métodos que manejan errores hay que pasarla en el método catch de rocket::ignite<br><h2>Respuestas</h2><br>Rocket nos permite devolver cualquier cosa que implemente el trait <strong>Responder</strong>. Algunos tipos ya lo llevan como String, File, JSON, Option y Result. Pero nada nos impide que nuestros propios tipos implementen Responder. Con Responder tenemos el contenido y el código de error (que en la mayoría de casos será 200). En el caso de Result es muy interesante, pues si Err contiene algo que implementa Responder, se devolverá la salida que implemente también, pudiendo así hacer mejores respuestas de error, mientras que si no lo hacen se llamará al método que implemente el error 500 de forma genérica. Con Option, si el valor es Some se devolverá el contenido, si es None se generará un error 404.<br><pre class="lang:rust decode:true">#![feature(plugin,custom_derive)]<br>#![plugin(rocket_codegen)]<br><br>#[macro_use] extern crate rocket_contrib;<br>extern crate rocket;<br><br>use rocket::response::{self, Responder, Response};<br>use std::io::Cursor;<br>use rocket::http::ContentType;<br><br>struct Pelicula{<br>    nombre: &amp;'static str,<br>    pais: &amp;'static str<br>}<br><br>impl&lt;'r&gt; Responder&lt;'r&gt; for Pelicula{<br>    fn respond(self) -&gt; response::Result&lt;'r&gt; {<br>        Response::build()<br>        .sized_body(Cursor::new(format!("La película {} se hizo en {}",self.nombre,self.pais)))<br>        .header(ContentType::new("text","plain"))<br>        .ok()<br>    }<br>}<br><br>#[get("/pelicula/&lt;pelicula&gt;")]<br>fn pelicula(pelicula: &amp;str) -&gt; Result&lt;Pelicula,String&gt; {<br>    let intocable = Pelicula{<br>        nombre: "Intocable",<br>        pais: "Francia"<br>    };<br>    let madMax = Pelicula{<br>        nombre: "Mad Max",<br>        pais: "Estados Unidos"<br>    };<br>    match pelicula {<br>        "Intocable" =&gt; Ok(intocable),<br>        "Mad Max" =&gt; Ok(madMax),<br>        _ =&gt; Err(format!("No existe esa película en nuestra base de datos"))<br>    }<br>}<br><br>#[get("/")]<br>fn index() -&gt; Result&lt;String,String&gt; {<br>    Err(format!("No implementado"))<br>}<br><br>#[error(404)]<br>fn not_found() -&gt; &amp;'static str {<br>    "La página no ha podido ser encontrada"<br>}<br><br>fn main() {<br>    rocket::ignite().mount("/",routes![index,pelicula]).catch(errors![not_found]).launch();<br>}<br></pre><br>Este ejemplo para /pelicula/Intocable devolverá: La película Intocable se hizo en Francia mientras que para /pelicula/Ratatouille dirá No existe esa película en nuestra base de datos.<br><br>También es posible devolver plantillas. Rocket se integra por defecto con Handlebars y Tera, aunque no es muy costoso añadir cualquier otra como Maud.<br><h2>Conclusión</h2><br>Rocket es un prometedor web framework para Rust, bastante idiomático, que se integra muy bien con el lenguaje. Espero con ansia las nuevas veriones. Es posible que la API cambie bastante hasta que salga la versión 1.0, no obstante así es como ahora mismo funciona.