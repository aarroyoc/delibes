Los algoritmos nos ayudan a resolver problemas. Hay muchas maneras de diseñarlos, un método que no conocía hasta hace poco y que me ha resultado muy interesante conocer es la <strong>programación dinámica</strong>. La idea fundamental de la programación dinámica es dividir el problema en subproblemas y posteriormente calcular una única vez cada subproblema. Existen dos acercamientos: <strong>top-down</strong> y <strong>bottom-up</strong>. La programación dinámica nos permite resolver problemas más rápidamente que con fuerza bruta, gastando a cambio mucha más memoria del ordenador.<br><br>Como explicado así, es un poco abstracto, vamos a intentar resolver un problemas clásico de programación dinámica, el problema de <strong>knapsack</strong> (o de la mochila).<br><h2>Problema de Knapsack</h2><br>Imagina que tenemos una mochila con capacidad para 10 kg. Tenemos 400 elementos para meter en la bolsa, cada uno de ellos con un peso y un valor. ¿Cuál es el valor máximo que podemos llevar en la bolsa?<br><br><a href="https://files.adrianistan.eu/KnapSack.jpeg"><img class="aligncenter wp-image-1352 size-medium" src="https://files.adrianistan.eu/KnapSack-228x300.jpeg" alt="" width="228" height="300" /></a><br><br>Este problema parece muy complicado de resolver. Quizá lo único que se nos ocurra es probar todas las combinaciones posibles de elementos, descartar las combinaciones que exceden el peso que puede llevar la mochila y de las restantes quedarnos con el máximo. Funcionaría, pero sería extremadamente lento.<br><br>Como cada elemento puede estar o no estar en la mochila, y son 400, las combinaciones son 2⁴⁰⁰=2582249878086908589655919172003011874329705792829223512830659356540647622016841194629645353280137831435903171972747493376. Excesivo.<br><br>Otra idea que podría surgir es <strong>backtracking</strong>. Básicamente recorreríamos todos los elementos posibles en forma de árbol, pero en cuanto veamos que ya no entran más elementos cortamos la búsqueda por esa rama y tomamos otra. Mejoraría el rendimiento, pero no es tampoco lo mejor que se podría hacer.<br><br>La solución es usar <strong>programación dinámica</strong>, vamos a aplicar el enfoque <strong>top-down</strong>. Lo primero es expresar la solución de forma recursiva.<br><br>La función <strong>mochila</strong> se define como el valor máximo que puede llevar una mochila, con N elementos a elegir y con una capacidad C.<br><pre class="lang:python decode:true ">def mochila(n,c):<br>    if n == 0 or c == 0:<br>        # solucion optima para cuando no quedan elementos o la capacidad disponible es 0<br>        return 0<br>    elif datos[n].peso &gt; c:<br>        # no metemos el elemento<br>        return mochila(n-1,c)<br>    else:<br>        #sin meter el elemento<br>        a = mochila(n-1,c)<br>        # metiendo el elemento<br>        b = datos[n].valor + mochila(n-1,c-datos[n].peso)<br>        return max(a,b)<br></pre><br>El primer if es la solución óptima, que es trivial si sabemos que ya no quedan elementos por revisar o si la capacidad que queda en la mochila es cero. El elif y else siguientes nos dan las soluciones óptimas también, pero de forma recursiva. En el primer caso, si el elemento es demasiado grande, solo se puede continuar probando con otro elemento, en el otro caso, hacemos los dos cálculos. Miramos si obtenemos más valor metiendo el elemento o sin meterlo y devolvemos el máximo. Este es el primer paso, básicamente es backtracking lo que hemos hecho.<br><h2>Memoizar</h2><br>Si bien la solución funcionaba, podemos darnos cuenta de que el ordenador iba a calcular muchas veces lo mismo. En programación dinámica no se calcula nunca nada más de una vez. Una solución sencilla para lograrlo es aplicar <strong>memoización</strong>, es decir, mantenemos un historial de llamadas a la función con argumentos. Piensa en ello como una caché.<br><br>En Python existe desde 3.2 en el módulo <strong>functools</strong> una caché que cumple lo necesario para memoizar.<br><pre class="lang:python decode:true ">import functools<br><br>@functools.lru_cache(maxsize=None)<br>def mochila(n,c):<br>    if n == 0 or c == 0:<br>        # solucion optima para cuando no quedan elementos o la capacidad disponible es 0<br>        return 0<br>    elif datos[n].peso &gt; c:<br>        # no metemos el elemento<br>        return mochila(n-1,c)<br>    else:<br>        #sin meter el elemento<br>        a = mochila(n-1,c)<br>        # metiendo el elemento<br>        b = datos[n].valor + mochila(n-1,c-datos[n].peso)<br>        return max(a,b)</pre><br>Este ligero cambio mejora drásticamente el rendimiento, haciendo que se calcule de forma casi instantánea (mientras que la otra versión tarda minutos).<br><h2>Recursividad</h2><br>Python no es un lenguaje que optimice las llamadas recursivas. Tampoco lo es Java. Ciertamente, en muchos lenguajes hacer demasiadas llamadas recursivas provoca un Stack Overflow. Ante esto se puede reescribir el algoritmo para que sea un bucle (el enfoque <strong>bottom-up</strong>) o se puede reescribir en un lenguaje que optimice las llamadas recursivas como Haskell o Lisp.<br><br>La solución bottom-up de este problema (usando una matriz) sería la siguiente:<br><pre class="lang:python decode:true ">V = list()<br>def mochila_two(n,c):<br>    for x in range(n):<br>        V.append([])<br>        for y in range(c+1):<br>            V[x].append(0)<br>    for i in range(n):<br>        for w in range(c+1):<br>            if datos[i].peso &lt;= w:<br>                V[i][w] = max(V[i-1][w],datos[i].valor+V[i-1][w-datos[i].peso])<br>            else:<br>                V[i][w] = V[i-1][w]<br>    <br>    return V[n-1][c]</pre><br>Esta versión es más rápida y no tiene el problema del límite de recursividad, pero es menos legible.<br><br><a href="https://files.adrianistan.eu/BottumUp.png"><img class="aligncenter size-full wp-image-1351" src="https://files.adrianistan.eu/BottumUp.png" alt="" width="805" height="378" /></a>(en la esquina encontraremos la solución óptima)