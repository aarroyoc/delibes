Vuelvo a la carga con un problema que me ha tenido entretenido un rato y que me parece interesante contaros.<br><br>Como muchos sabréis, este año me pasé el videojuego <a href="https://blog.adrianistan.eu/2016/03/25/analisis-the-witness/">The Witness</a>. Es un juego muy interesante y que os recomiendo. El caso es que nunca llegué a escuchar todas las citas célebres del juego, y en YouTube solo encontré vídeos sueltos con subtítulos en... francés. Así que me propuse hacer un vídeo que recogiese todas las citas célebres del juego, con subtítulos en Español. Antes esta situación hay dos opciones:<br><ul><br> 	<li>Lo que una persona normal haría sería buscar en la guía las localizaciones de las citas e ir grabándolas.</li><br> 	<li>Lo que haría un perturbado sería meterse en los archivos del juego, decodificar los archivos e implementar un complejo sistema para generar el vídeo.</li><br></ul><br>Por supuesto, hice lo último.<br><br><a href="https://files.adrianistan.eu/TheWitnessQuotes.png"><img class="aligncenter size-large wp-image-619" src="https://files.adrianistan.eu/TheWitnessQuotes-1024x576.png" alt="thewitnessquotes" width="840" height="473" /></a><br><h2>Encontrando archivos del juego</h2><br>Los archivos del juego no están escondidos, se encuentran en un archivo llamado <em>data-pc.zip</em>. Hasta ahí fácil. Una vez dentro encontramos cientos de archivos con unas extensiones peculiares que nos informan de lo que hay dentro (.texture, .lightmap,...). Sin embargo los archivos de sonido no los encontramos de manera sencilla. Necesitan una conversión. Estaba ya buscando soluciones (sospecho que tiene que ver con Audiokinetic Wwise) cuando <a href="https://www.reddit.com/r/TheWitness/comments/451hlx/exploring_the_data_files_major_spoilers/">encontré en reddit a un buen samaritano</a> que había subido, ya decodificados, los archivos de sonido a Mega.<br><br>Al ver los archivos observé cantidad de ficheros .WAV y muy poquitos .OGG. Eso ya nos da una pista, pues las citas célebres han tenido que ser codificadas como Ogg, ya que si fuesen con WAV el fichero sería demasiado grande. Extraigo los archivos y borro todos los WAV, pues sé que ahí no están.<br><br>Pero no hemos acabado. Los Ogg no solo eran de citas célebres, también había efectos de sonido largos. Afortunadamente, los archivos de efectos de sonido solían llevar un prefijo común (<em>amb_, spec_,...</em>).<br><h2>Los subtítulos</h2><br>Tenemos los ficheros de audio de las citas en formato Ogg. Ahora hacen falta los subtítulos. Están fuera de ese fichero ZIP gigante y no es difícil encontrarlos. En concreto el archivo <em>es_ES.subtitles</em>. Sin embargo, una vez lo abres descubres la primera sorpresa. Es un formato del que desconocía su existencia. Os pongo un poco para ver si alguien es capaz de saber el formato:<br><br>&nbsp;<br><br><pre class="lang:default decode:true"><br>: tagore_voyage<br><br>= 1.000000<br>Creía que mi viaje había llegado al final<br>al estar al límite de mis fuerzas...<br><br>= 6.700000<br>que el camino ante mí estaba cerrado,<br>las provisiones agotadas<br>y que había llegado la hora de refugiarse en la silenciosa oscuridad.<br><br>= 17.299999<br>Pero encuentro que la voluntad no se me acaba,<br><br>= 21.299999<br>y cuando las palabras se apagan en la lengua,<br>surgen nuevas melodías del corazón;<br><br>= 27.200001<br>y cuando se pierde el antiguo camino,<br>una nueva tierra revela sus maravillas.<br><br>= 32.700001<br><br>= 32.709999<br>Rabindranath Tagore, 1910<br><br><br>: tagore_end<br><br>= 1.000000<br>En mi vida te he buscado con mis canciones.<br>Fueron ellas las que me guiaron de puerta en puerta,<br><br>= 8.800000<br>y con ellas me he sentido a mí,<br>buscando y tocando mi mundo.<br><br>= 14.400000<br><br>= 14.900000<br>Fueron mis canciones las que me enseñaron<br>todas las lecciones que he aprendido<br><br>= 18.900000<br>me mostraban caminos secretos,<br>condujeron mi vista hacia más de una estrella<br>en el horizonte de mi corazón.<br><br>= 25.500000<br><br>= 26.100000<br>Me guiaron todo el día<br>hacia los misterios del país del placer y el dolor<br><br>= 32.500000<br>y, finalmente,<br>¿a las puertas de qué palacio me han<br>guiado en el atardecer al final de mi viaje?<br><br>= 39.299999<br><br><br>: tagore_boast<br><br>= 1.000000<br>Presumí ante los hombres de conocerte.<br><br>= 4.300000<br>Ven tus imágenes en mis trabajos.<br>Vienen y me preguntaban &quot;¿Quién es él?&quot;<br><br>= 10.900000<br>No tengo respuesta para ellos.<br>Les digo &quot;No sabría decirlo&quot;.<br><br>= 16.799999<br>Me culpan y se marchan con desprecio.<br>Y tú te sientas ahí, sonriendo.<br><br>= 23.500000<br><br>= 24.700001<br>Mis historias sobre ti quedan en canciones duraderas.<br>El secreto sale a borbotones de mi corazón.<br><br>= 31.000000<br>Vienen y me piden<br>&quot;Cuéntame todo lo que significan&quot;.<br><br>= 34.900002<br>No tengo respuesta para ellos.<br>Les digo &quot;Ah, ¡quién sabrá!&quot;<br><br>= 40.500000<br><br>= 41.000000<br>Sonríen y se marchan con desprecio absoluto.<br>Y tú te sientas ahí, sonriendo.<br><br>= 48.000000<br><br>= 49.500000<br>- Rabindranath Tagore, 1910<br></pre><br><br>Pero no me iba a detener. Así que empecé a diseñar un programa que permitiese traducir este archivo a un archivo SRT normal y corriente. Para ello usaría Regex a saco (me leí el libro, para algo me tendría que servir).<br><br><a href="https://files.adrianistan.eu/regexp.png"><img class="aligncenter size-large wp-image-620" src="https://files.adrianistan.eu/regexp-529x1024.png" alt="regexp" width="529" height="1024" /></a><br><br>Para hacer el programa usé Node.js. Sí, se que para este tipo de cosas el mejor lenguaje es Perl, o un derivado como Ruby pero todavía no he aprendido lo suficiente de Ruby como para plantearmelo. JavaScript cuenta de forma estándar (tanto Node.js como navegador) con la clase RegExp, que permite ejecutar expresiones regulares y esa es la que he usado.<br><br>Finalmente conseguí hacer un script de Node.js, sin dependencias externas, que traduciese este archivo subtitles en un SRT.<br><h2>Generando un vídeo para cada cita</h2><br>Ya tenemos el audio, tenemos los subtítulos en un formato conocido. Vamos ahora a generar un vídeo. Primero necesitaremos una imagen de fondo. Pillo una cualquiera de Internet y empiezo a hacer pruebas con <strong>ffmpeg</strong>. El formato de salida va a ser MP4 codificado con H264 porque realmente es el formato que más rápido se codifica en mi ordenador.<br><br>Nada más empezar empiezo a ver que los subtítulos no están funcionando, no se fusionan con la imagen y el audio. Al parecer es un problema que involucra a fontconfig, ffmpeg y Windows. Sí, estaba usando Windows hasta ahora.<br><br>Me muevo a Debian y ahora ya funciona bien el fusionado de subtítulos.<br><br>Ahora intento unir dos vídeos con ffmpeg también. Fracaso. Lo vuelvo a intentar, FRACASO. Si os digo que la mayor parte del tiempo que me ha llevado este proyecto ha sido encontrar como concatenar varios MP4 en ffmpeg sin que me diese errores extraños quizá no os lo creeríais, pero es verídico. No me creeríais porque la wiki de ffmpeg lo explica correctamente y si buscáis por Internet os van a decir lo mismo. ¿Qué era lo que pasaba?<br><ol><br> 	<li>Las dimensiones de los vídeos no cuadraban<br><ol><br> 	<li>Esto fue obvio y fue lo primero que pensé. ffmpeg tiene un filtro de escalado, pero por alguna razón no funcionaba. La razón era que estaba usando dos veces la opción "-vf" (filtro de vídeo), una con los subtítulos y otra con el escalado. ffmpeg no admite nos veces la opción, si quieres aplicar dos filtros de vídeo tienes que usar una coma entre ellos.</li><br></ol><br></li><br> 	<li>Formato de píxeles<br><ol><br> 	<li>Este era el verdadero problema. Normalmente no suele pasar, pero como las imágenes de los dos vídeos venían de fuentes distintas, ffmpeg usó un formato de píxeles distinto en cada una. Forzando a ffmpeg a usar siempre "yuv420p" funcionó y la concatenación se pudo realizar.</li><br></ol><br></li><br></ol><br>Probé también con <strong>mkvmerge</strong>, pero me decía que la longitud de los códecs era distinta. No entendí el error hasta que no me enteré que había sido el formato de píxeles, cada vídeo usaba uno distinto en su codificación.<br><br>El comando necesario para generar cada vídeo fue entonces:<br><br><pre class="lang:default decode:true"><br>ffmpeg -loop 1 -i imagen.jpg -i audio.ogg -c:v libx264 -tune stillimage -pix_fmt yuv420p -s 1280x720 -vf scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2,subtitles=subtitulos.srt video.mp4<br></pre><br><br><h2>Concatenar los vídeos</h2><br>Para concatenar los vídeos es necesario tener un archivo de texto donde se indiquen los archivos y su orden, siguiendo este formato:<br><br><pre class="lang:default decode:true"><br># Archivo de concatenacion ffmpeg<br>file 'video1.mp4'<br>file 'video2.mp4'<br>file 'video3.mp4'<br></pre><br><br>Luego, su uso es bastante sencillo:<br><br><pre class="lang:default decode:true"><br>ffmpeg -f concat -i videos.txt -c:v copy video.mp4<br></pre><br><br><h2>El script final</h2><br>Ahora solo hacía falta convertir todos los archivos de audio en vídeo con sus subtítulos. Usando un script de bash se puede hacer esto:<br><br><pre class="lang:default decode:true"><br>for f in *.ogg; do<br>	node main.js &quot;${f%.*}&quot;<br>done<br></pre><br><br>Y el código de main.js es el siguiente. main.js se encarga de traducir los ficheros subtitles a SRT, de llamar a ffmpeg y de añadir el vídeo a la lista de videos.txt para la posterior concatenación.<br><br><pre class="lang:js decode:true"><br>var fs = require(&quot;fs&quot;);<br>var spawn = require(&quot;child_process&quot;).spawn;<br><br>var ZONE = process.argv[2];<br>var IMG = process.argv[2]+&quot;.jpg&quot;;<br><br>function timeFormat(SEC,MILISEC){<br>	var date = new Date(SEC * 1000);<br>	var regex = new RegExp(&quot;([0-9]+:[0-9]+:[0-9]+)&quot;);<br>	var str = regex.exec(date.toUTCString())[1] + &quot;,&quot; + MILISEC.substring(0,3);<br>	return str;<br>}<br><br>var witness = fs.readFileSync(&quot;es_ES.subtitles&quot;,&quot;utf-8&quot;);<br>var srt = fs.createWriteStream(ZONE+&quot;.srt&quot;);<br><br>var regex = &quot;: &quot;+ZONE+&quot;\n\n= ([0-9]+).([0-9]+)\n&quot;;<br><br>var LINE = 1;<br><br>while(!(new RegExp(regex + &quot;\n: &quot;,&quot;g&quot;).test(witness))){<br>	var start = new RegExp(regex,&quot;g&quot;);<br>	var match = start.exec(witness);<br>	<br>	var START_TIME_SEC = parseInt(match[match.length - 2]);<br>	var START_TIME_MILISEC = match[match.length - 1];<br>	var TEXT = &quot;&quot;;<br><br>	do{<br>		var text = new RegExp(regex + &quot;(.+)\n&quot;,&quot;g&quot;);<br>		var exec = text.exec(witness);<br>		if(exec!=null){<br>			TEXT = TEXT + &quot;\n&quot; + exec[exec.length - 1];<br>			regex = regex + &quot;(.+)\n&quot;;<br>		}<br>	}while(exec != null);<br>	<br>	regex = regex + &quot;\n= ([0-9]+).([0-9]+)\n&quot;;<br>	var time = new RegExp(regex,&quot;g&quot;);<br>	var end_time = time.exec(witness);<br>	if(end_time != null){<br>		var END_TIME_SEC = parseInt(end_time[end_time.length - 2]);<br>		var END_TIME_MILISEC = end_time[end_time.length - 1];<br>		srt.write(LINE + &quot;\n&quot;);<br>		srt.write(timeFormat(START_TIME_SEC,START_TIME_MILISEC)+&quot; --&amp;amp;amp;amp;gt; &quot;+timeFormat(END_TIME_SEC,END_TIME_MILISEC));<br>		srt.write(TEXT);<br>		srt.write(&quot;\n\n&quot;);<br>	}else{<br>		srt.write(LINE + &quot;\n&quot;);<br>		srt.write(timeFormat(START_TIME_SEC,START_TIME_MILISEC)+&quot; --&amp;amp;amp;amp;gt; &quot;+timeFormat(5*60,&quot;000000&quot;));<br>		srt.write(TEXT);<br>		srt.write(&quot;\n\n&quot;);<br>		break;<br>	}<br>	LINE++;<br>}<br><br>srt.end();<br><br>var ffmpeg = spawn(&quot;ffmpeg&quot;,[&quot;-loop&quot;,&quot;1&quot;,&quot;-i&quot;,IMG,&quot;-i&quot;,ZONE+&quot;.ogg&quot;,&quot;-c:v&quot;,&quot;libx264&quot;,&quot;-tune&quot;,&quot;stillimage&quot;,&quot;-pix_fmt&quot;,&quot;yuv420p&quot;,&quot;-s&quot;,&quot;1280x720&quot;,&quot;-shortest&quot;,&quot;-vf&quot;,&quot;scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2,subtitles=&quot;+ZONE+&quot;.srt&quot;,ZONE+&quot;.mp4&quot;]);<br><br>ffmpeg.stderr.on('data', (data) =&amp;amp;amp;amp;gt; {<br>  console.log(`stderr: ${data}`);<br>});<br><br>fs.appendFileSync(&quot;video.txt&quot;,&quot;file '&quot;+ZONE+&quot;.mp4'\n&quot;);<br></pre><br><br>Se trata de un programa que hice deprisa y corriendo y aunque el código es feo (o eso me parece a mi), la verdad es que me ha servido.<br><h2>Y el resultado...</h2><br><iframe src="https://www.youtube-nocookie.com/embed/lXvHJsFwUR0" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"></iframe><br>&nbsp;