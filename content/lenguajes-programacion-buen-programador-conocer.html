Dice Bjarne Stroustrup (creador de C++) que nadie <a href="https://www.youtube.com/watch?v=NvWTnIoQZj4">debería llamarse un profesional si no conoce al menos 5 lenguajes suficientemente diferentes entre sí.</a> Comparto con él esa afirmación, así que he decidido hacer una lista con esos 5 lenguajes suficientemente diferentes entre sí. La razón de que sean diferentes entre sí es que implementan paradigmas distintos.<br><h2>Paradigmas de programación</h2><br>Cada lenguaje está moldeado en base a uno o varios paradigmas de programación. Aunque no hay una teoría con la que todos los autores esten de acuerdo, bajo mi punto de vista existen dos grandes grupos de paradigmas de programación. <strong>Imperativos</strong> y <strong>Declarativos</strong>. Los imperativos responden a la pregunta de <em>¿Cómo se calcula esto?</em> y los declarativos <em>¿Cuál es el resultado de esto?</em>. Otra manera de verlo es ver al paradigma imperativo como un intento de simplificar la electrónica subyacente. El paradigma declarativo por contra muchas veces se origina de la teoría matemática y posteriormente se aplica al ordenador.<br><br>Cada uno de estos paradigmas a su vez tienen más sub-paradigmas y luego existen paradigmas <em>transversales</em>, es decir, que se pueden aplicar (o no) tanto en lenguajes imperativos como en lenguajes declarativos.<br><br>Un buen programador necesita conocer estos paradigmas.<br><h2>Prolog</h2><br>Prolog es un claro ejemplo de <strong>programación lógica</strong>. Se trata de un lenguaje declarativo. Diseñado en los años 70 en Francia, Prolog tuvo mucha popularidad en el desarrollo de Inteligencia Artificial debido a sus características lógicas. En esencia, Prolog se basa en la demostración de predicados, similares a los del álgebra de predicados.<br><br><a href="https://files.adrianistan.eu/LogicaPredicados.png"><img class="size-full wp-image-1326" src="https://files.adrianistan.eu/LogicaPredicados.png" alt="" width="554" height="154" /></a> Ejemplos de lógica de predicados<br><br>Un programa Prolog es en realidad un conjunto de afirmaciones o <strong>predicados</strong>. En tiempo de ejecución se realizan preguntas sobre predicados. Prolog intenta entonces demostrar la veracidad del predicado, para ello usa el mecanismo de <em>backtracing</em>. Una característica muy interesante de Prolog es el <em>pattern matching</em>, que básicamente permite preguntar para qué valor de una variable se cumple un predicado. Esto permite realizar cosas muy interesantes:<br><pre class="lang:lisp decode:true">% PROGRAMA EN PROLOG<br>% PREDICADOS QUE SON VERDADEROS<br><br>hijo(bernardo,sonia).<br>hijo(veronica,sonia).<br>hijo(bernardo,luis).<br>hijo(veronica,luis).<br><br>varon(bernardo).<br>varon(luis).<br>mujer(veronica).<br>mujer(sonia).<br><br>% REGLAS<br><br>madre(X,Y) :- hijo(X,Y), mujer(X).<br></pre><br>Ahora, para saber quién es la madre de Sonia intentamos demostrar:<br><pre class="lang:default decode:true">?- madre(X,sonia).</pre><br>Y responderá X = veronica.<br><br>En predicados sin variables, Prolog solo devuelve true o false.<br><br>Existen varios compiladores/intérpretes de Prolog, siendo el más conocido SWI-Prolog, multiplataforma y con una extensa librería que incluye GUI multiplataforma y framework web. También existe GNU Prolog y Visual Prolog (antiguamente conocido como Turbo Prolog), aunque este último no se le considera Prolog auténtico por ser demasiado diferente al resto.<br><h2>Haskell</h2><br><a href="https://www.haskell.org/">Haskell</a> es un lenguaje declarativo que implementa el <strong>paradigma funcional</strong>. Es uno de los pocos lenguajes funcionales que son 100% puros. Se entiende por puros como la capacidad de no generar efectos colaterales. Haskell es un lenguaje fuertemente tipado y deriva de la <strong>teoría de categorías</strong>. Haskell ha sido objeto (hasta cierto punto merecido) de muchas bromas sobre este asunto, ya que para la mayoría de programadores, conocer teoría de categorías no es demasiado práctico.<br><br><a href="https://files.adrianistan.eu/MemeHaskell.jpg"><img class="aligncenter size-full wp-image-1328" src="https://files.adrianistan.eu/MemeHaskell.jpg" alt="" width="625" height="412" /></a>Otra característica de Haskell es que es <strong>perezoso</strong>, lo que significa que no calculará nada que no sea estrictamente necesario (esto puede parecer muy raro hasta que lo entiendes en la práctica).<br><pre class="lang:haskell decode:true ">module Main where<br><br>import Data.Matrix<br>import qualified Data.Vector as Vector<br>import qualified Reader<br>import qualified Data.Maybe as Maybe<br><br>main :: IO ()<br>main = do<br>    matrix &lt;- Reader.readFile "gosperglidergun.txt"<br>    putStrLn "Iterar cuantas veces?"<br>    n &lt;- getLine<br>    let times = read n :: Int<br>    let finalMatrix = Prelude.iterate Main.iterate matrix<br>    putStrLn $ prettyMatrix $ finalMatrix !! times<br><br><br>iterate :: Matrix Int -&gt; Matrix Int<br>iterate m = <br>    if hasToGrow then<br>        matrix (nrows m +2) (ncols m +2) (\(i,j) -&gt; builder (i-1,j-1))<br>    else<br>        matrix (nrows m) (ncols m) builder<br>    where<br>        builder (i,j) = <br>            if get (i,j) == 0 then<br>                if hasToBorn (i,j) then<br>                    1<br>                else<br>                    0<br>            else<br>                if hasToDie (i,j) then<br>                    0<br>                else<br>                    1<br>        hasToGrow = <br>            Vector.sum (getCol (ncols m) m) &gt; 0 || <br>            Vector.sum (getRow (nrows m) m) &gt; 0 ||<br>            Vector.sum (getCol 1 m) &gt; 0 ||<br>            Vector.sum (getRow 1 m) &gt; 0<br>        get (i,j) = Maybe.fromMaybe 0 (safeGet i j m)<br>        hasToBorn (i,j) = sumNeighbors (i,j) == 3<br>        hasToDie (i,j) = sumNeighbors (i,j) /= 2 &amp;&amp; sumNeighbors (i,j) /= 3<br>        sumNeighbors (i,j) = <br>            get (i-1,j-1) + get (i,j-1) + get (i+1,j-1) <br>            + get (i-1,j) + get (i+1,j)<br>            + get (i-1,j+1) + get (i,j+1) + get (i+1,j+1)<br></pre><br>Este código pertenece al <a href="https://blog.adrianistan.eu/2018/01/20/juego-la-vida-conway-c-interfaz-grafica/">juego de la vida de Conway</a> que (también) implementé en Haskell, simplemente por curiosidad, ya que no está optimizado. Faltaría el módulo Reader, así que no intentéis compilarlo directamente.<br><br>Haskell como tal no tiene variables ni bucles y sus <em>condicionales</em> no son exactamente iguales a los de los lenguajes imperativos (aunque se use if, en el caso de Haskell son bloques que siempre deben devolver un valor).<br><br><a href="https://files.adrianistan.eu/Screenshot-2018-2-18-Haskell-Language.png"><img class="aligncenter size-large wp-image-1329" src="https://files.adrianistan.eu/Screenshot-2018-2-18-Haskell-Language-1024x481.png" alt="" width="840" height="395" /></a>Aunque siempre ha sido un lenguaje académico (nació en 1994, un año antes que Java), ahora ha alcanzado bastante popularidad y algunas empresas como <a href="https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/">Facebook lo usan en producción</a>.<br><br>El compilador más conocido, capaz de generar código nativo, es GHC. Este dispone de un REPL llamado GHCi y también compila a JavaScript y se está trabajando en WebAssembly. Otro intérprete es <strong><a href="https://www.haskell.org/hugs/">Hugs</a></strong>, pero solo es compatible con Haskell98.<br><br>La forma recomendada de instalar GHC es con <strong>Stack</strong>. <a href="http://haskellstack.org">Usa Stack</a> y ahórrate quebraderos de cabeza.<br><br>Otros lenguajes similares a Haskell son <a href="https://blog.adrianistan.eu/2017/07/15/formulario-registro-elm/"><strong>Elm</strong></a>, <strong>PureScript</strong>, <strong>Eta</strong> e <strong>Idris</strong>. Este último compila a JavaScript y pone énfasis en su librería, que es capaz de competir con Angular y React.<br><h2>Racket (Lisp)</h2><br><strong>Lisp</strong> no puede faltar nunca. Se trata de uno de los primeros lenguajes de programación y sigue siendo tan actual como el primer día, gracias a su simple pero efectivo diseño, inspirado en el <strong>cálculo lambda</strong> de Alonzo Church. No obstante, Lisp ha evolucionado mucho, si me preguntan que dialecto/lenguaje de Lisp merece la pena aprender ahora diría <a href="https://racket-lang.org/"><strong>Racket</strong></a>. Racket es un lenguaje de <strong>programación funcional</strong> y <strong>programación orientada a objetos</strong>. Racket no es 100% puro como Haskell (la mayoría de dialectos de Lisp no lo son) pero sigue siendo muy interesante. También, tiene <strong>tipado débil</strong> en contraposición al tipado fuerte de Haskell.<br><br>Racket desciende a su vez de <strong>Scheme</strong>, que es una de los ramas principales de Lisp, siendo la otra <strong>Common Lisp</strong>. ¿Por qué estas diferencias? La gente de Scheme prefiere un lenguaje elegante, lo más funcional posible mientras que la gente de Common Lisp prefirieron sacrificar eso a cambio de un lenguaje más práctico en el mundo real.<br><br>Racket cuenta con una extensísima librería estándar capaz de realizar todo lo que te imagines sin gran problema. Racket también soporta las famosas y potentes macros.<br><pre class="lang:scheme decode:true ">#lang racket<br><br>(require 2htdp/image) ; draw a picture<br>(let sierpinski ([n 8])<br>  (cond<br>    [(zero? n) (triangle 2 'solid 'red)]<br>    [else (define t (sierpinski (- n 1)))<br>          (freeze (above t (beside t t)))]))</pre><br><a href="https://files.adrianistan.eu/Screenshot-from-2018-02-18-16-23-34.png"><img class="aligncenter size-large wp-image-1330" src="https://files.adrianistan.eu/Screenshot-from-2018-02-18-16-23-34-1024x576.png" alt="" width="840" height="473" /></a><a href="https://blog.adrianistan.eu/2017/05/24/triangulo-sierpinski-javascript/">Triángulo de Sierpinski</a> en el IDE DrRacket.<br><h2>JavaScript</h2><br>JavaScript está en todas partes. Es uno de los lenguajes con mayor aplicación práctica. Web, servidor, bases de datos, scripting, plugins e incluso IoT. Por eso JavaScript me parece un lenguaje que deba estar en esta lista. Y sin embargo no es fácil categorizarlo correctamente. Ante todo, estamos ante un lenguaje de programación <strong>imperativo</strong>, con <strong>orientación a objetos</strong> y buen soporte a la <strong>orientación a eventos</strong>.<br><br>Y antes de que se me venga alguien a comerme, sí, JavaScript está orientado a objetos, aunque no siguen el patrón de clase/herencia que C++ y Java tienen tan acostumbrados a la gente. La orientación a objetos por <strong>prototipos</strong> no la inventó JavaScript, sino que ya estaba en otros lenguajes como <strong>Self</strong> y más actualmente <strong>Io</strong>. Y realmente lenguajes como Python o Ruby no se alejan mucho de esto internamente.<br><br>Actualmente, con la versión ES7, tenemos muchas cosas interesantes en <strong>programación asíncrona</strong> y clases al estilo Java que no son más que azúcar sintáctico sobre el verdadero modelo de JS.<br><br>Definitivamente, JavaScript es un lenguaje muy interesante y aunque a algunas personas les pueda parecer un <em>caos</em>, ciertamente es muy productivo y útil. Aprovechar al máximo JavaScript requiere pensar de forma distinta a como lo harías en otros lenguajes imperativos.<br><pre class="lang:js decode:true ">async function lastGist(username){<br>    let f = await fetch(`https://api.github.com/users/${username}/gists`);<br>    let data = await f.json();<br>    try{<br>        return data[0].description;<br>    }catch(e){<br>        return undefined;<br>    }<br>}<br><br>let users = ["aarroyoc","DanielBV","hecsaen"];<br>Promise.all(users.map(lastGist)).then((gists)=&gt;{<br>    gists.forEach((gist)=&gt;{<br>        console.log(`Last gist: ${gist}`);<br>    });<br>});<br></pre><br><h2>C# (o Java)</h2><br>C# es otro lenguaje bastante complejo, <strong>imperativo</strong>, <strong>orientado a objetos por clases</strong>, con partes de <strong>programación funcional</strong> y <strong>programación asíncrona</strong>. Pero el sistema de la orientación a objetos aquí es distinto. Aunque Alan Kay, creador de <strong>Smalltalk</strong> y casi casi de la orientación a objetos, opine que el estilo de C++ y de Java son <em>putas mierdas</em>, lo cierto es que es lo más usado actualmente. Herencia, clases, interfaces, etc<br><br>Personalmente prefiero C#, ya que como lenguaje es más potente que Java, pero ambos al final tienen bastantes características comunes entre sí.<br><pre class="lang:c# decode:true">using System;<br><br>class MainClass {<br>  public static void Main (string[] args) {<br>    var names = new List&lt;String&gt;<br>    {<br>        "Ana",<br>        "Felipe",<br>        "Emilia"<br>    };<br><br>    foreach (var name in names)<br>    {<br>        Console.WriteLine($"Hello {name}");<br>    }<br>  }<br>}</pre><br>Para C# el compilador más usado es Roslyn, actualmente disponible en .NET Framework, .NET Core y Mono.<br><br>Otros lenguajes parecidos son <strong>Java</strong> o si preferimos una sintaxis tipo Pascal: <strong>Delphi/Object-Pascal</strong> tiene conceptos muy similares.<br><h2>Conclusión</h2><br>Con esto ya tendríamos 5 lenguajes suficientemente diferentes. Ahora bien, nos hemos dejado lenguajes muy interesantes, tanto desde el punto de vista práctico como teórico. No puedo dejar de mencionar a <strong>Smalltalk</strong> por su implementación de los objetos, a <strong>C</strong> por su ligera capa de abstracción sobre ensamblador, al propio <strong>Ensamblador</strong> porque es lo que ejecuta la CPU realmente, a <strong>Python</strong> por su diseño así como su gran uso en ciencia de datos y scripts o a <strong>Rust</strong>, un lenguaje imperativo con sistema de <strong>traits,</strong> <strong>semántica de movimiento</strong>, <strong>pattern matching</strong>.<br><br>Merece también la pena mirar <strong>FORTH</strong>, <strong>SQL</strong> (quizá el lenguaje declarativo más usado del mundo) y lenguajes que se adapten bien a la <strong>programación reactiva</strong> (hay sobre todo librerías, aunque algún lenguaje como <strong>Simulink</strong> lo implementa). <strong>Mathemathica</strong> implementa también el paradigma de <strong>programación simbólica</strong>, muy poco explotado en otros lenguajes.<br><br>Estos han sido mis 5 lenguajes, ¿cuáles serían los tuyos?