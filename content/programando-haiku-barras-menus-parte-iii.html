Seguimos con los <a href="https://blog.adrianistan.eu/2016/05/18/programando-haiku-bapplication-bwindow-bbutton-parte-i/">tutoriales de Haiku</a>, hoy veremos como crear barras de menú. Partimos del código de la ventana vacía, lo tienes en la foto junto con el comando de compilación.<br><br><a href="https://files.adrianistan.eu/MiAplicacionHaikuCodigo.png" target="_blank"><img class="wp-image-502 size-large" src="https://files.adrianistan.eu/MiAplicacionHaikuCodigo-1024x768.png" alt="MiAplicacionHaikuCodigo" width="840" height="630" /></a> Haz click en la imagen para verlo en grande<br><br>Debemos saber que en la API de BeOS hay tres clases que nos van a servir.<br><ul><br> 	<li>BMenuBar, se trata de la barra en sí, que esta pegada a la ventana. Un BMenuBar contiene BMenus.</li><br> 	<li>BMenu, son los menús en sí. Un menú es un elemento que contiene acciones, organizadas como si fuera una lista. Los menús no definen acciones, pero sí su organización. Así, a un BMenu le tendremos que añadir BMenuItems u otro BMenus (menús anidados).</li><br> 	<li>BMenuItem, son las acciones de los menús. Cada BMenuItem tiene la capacidad de generar un BMessage nuevo, listo para ser procesado por nuestra aplicación.</li><br></ul><br>En la imagen se puede ver perfectamente<br><br><img class="alignnone size-full wp-image-503" src="https://files.adrianistan.eu/BMenu.png" alt="BMenu" width="632" height="386" /><br><br>Vamos a crear una barra de menú con dos menús, uno de ellos simple y otro con un menú anidado y un separador.<br><br><pre class="lang:c++ decode:true"><br>#include &lt;AppKit.h&gt;<br>#include &lt;InterfaceKit.h&gt;<br>#include &lt;InterfaceDefs.h&gt;<br><br>#define NEW_FILE 3<br>#define EXPORT_AS 5<br><br>class VentanaPrueba : public BWindow{<br>	public:<br>		VentanaPrueba() : BWindow(BRect(100,100,900,700),&quot;Mi ventana&quot;,B_TITLED_WINDOW,0){<br>			AddChild(CreateMenuBar());<br>		}<br>		bool QuitRequested(){<br>			be_app_messenger.SendMessage(B_QUIT_REQUESTED);<br>			return BWindow::QuitRequested();<br>		}<br>		void MessageReceived(BMessage* msg){<br>			switch(msg-&gt;what){<br>				default:<br>					BWindow::MessageReceived(msg);<br>			}<br>		}<br>		BMenuBar* CreateMenuBar(){<br>			BMenuBar* bar = new BMenuBar(BRect(0,0,100,20),&quot;MenuBar&quot;);<br>			<br>			BMenu* file = new BMenu(&quot;File&quot;);<br>			BMenu* help = new BMenu(&quot;Help&quot;);<br>			BMenu* exportMenu = new BMenu(&quot;Export&quot;);<br>			<br>			bar-&gt;AddItem(file);<br>			bar-&gt;AddItem(help);<br>			<br>			/* FILE */<br>			BMenuItem* newFile = new BMenuItem(&quot;New file&quot;,new BMessage(NEW_FILE));<br>			newFile-&gt;SetShortcut('N',B_COMMAND_KEY);<br>			file-&gt;AddItem(newFile);<br>			<br>			file-&gt;AddItem(exportMenu);<br>			file-&gt;AddSeparatorItem();<br>			<br>			BMenuItem* quit = new BMenuItem(&quot;Quit&quot;,new BMessage(B_QUIT_REQUESTED));<br>			quit-&gt;SetShortcut('Q',B_COMMAND_KEY);<br>			file-&gt;AddItem(quit);<br>			<br>			/* EXPORT */<br>			BMenuItem* exportAs = new BMenuItem(&quot;Export as...&quot;,new BMessage(EXPORT_AS));<br>			exportMenu-&gt;AddItem(exportAs);<br>			<br>			/* HELP */<br>			BMenuItem* helpVersion = new BMenuItem(&quot;Help&quot;,NULL);<br>			help-&gt;AddItem(helpVersion);<br>			<br>			return bar;<br>		}<br>};<br><br>class AplicacionPrueba : public BApplication{<br>	public:<br>			VentanaPrueba* ventana;<br>			AplicacionPrueba() : BApplication(&quot;application/x-aplicacion-prueba&quot;){<br>				ventana = new VentanaPrueba();<br>				ventana-&gt;Show();	<br>			}<br>};<br><br>int main(int argc, char** argv){<br>	AplicacionPrueba app;<br>	return app.Run();<br>}<br></pre><br><br>Y el resultado es el siguiente:<br><br><img class="alignnone size-full wp-image-505" src="https://files.adrianistan.eu/BMenuBar.png" alt="BMenuBar" width="396" height="225" /><br><br>Como vemos, <em>SetShortcut</em> hace que los menús sean seleccionables con combinaciones de teclado. Hay que tener en cuenta que en BeOS, la tecla que en Windows normalmente Ctrl, es Alt. Así operaciones como copiar y pegar con Alt+C y Alt+V. Para responder al evento solo hace falta escuchar en la función <em>MessageReceived</em>. En el caso de B_QUIT_REQUESTED, el mensaje ya está implementado en la función <em>QuitRequested</em>.