Seguimos aprendiendo en el blog sobre interesantes proyectos hechos para Rust. Ya hemos visto <a href="https://blog.adrianistan.eu/2016/11/20/usando-iron-web-framework-rust/">Iron</a>, <a href="https://blog.adrianistan.eu/2017/01/17/tutorial-piston-programa-juegos-rust/">Piston</a> y <a href="https://blog.adrianistan.eu/2017/01/27/tutorial-neon-combina-node-js-rust/">Neon</a>. Hoy veremos <a href="https://maud.lambda.xyz/">Maud</a>, un potente motor de plantillas que se centra en la eficiencia. Maud se compara a otras soluciones como Razor, ERB, Liquid,  Handlebars o Jade pero esta vez escribiremos nuestro HTML en Rust. ¿Locura? No, y de hecho funciona de forma bastante transparente. Vamos a verlo en acción<br><br><a href="https://files.adrianistan.eu/screenshot-lambda.xyz-2017-01-27-22-07-51.png"><img class="size-full wp-image-700" src="https://files.adrianistan.eu/screenshot-lambda.xyz-2017-01-27-22-07-51.png" alt="" width="605" height="374" /></a> Comparativa de velocidad de diferentes motores. Maud es el más rápido (menos es mejor)<br><h2>Instalando Maud</h2><br>Maud usa plugins del compilador, una característica que a día de hoy no está activado ni en el canal estable ni el canal beta, solamente en el canal nightly. Para obtener una copia de Rust nightly lo ideal es usar <a href="http://rustup.rs">Rustup</a>.<br><br>Una vez hecho eso, creamos un nuevo proyecto y añadimos las dependencias de Maud al fichero Cargo.toml.<br><br><pre class="lang:default decode:true"><br>maud = &quot;*&quot;<br>maud_macros = &quot;*&quot;<br></pre><br><br><h2>Una simple plantilla</h2><br>Ahora abrimos el archivo src/main.rs y vamos a empezar a usar Maud.<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>fn main(){<br>        let name = &quot;Adrián&quot;;<br>        let markup = html!{<br>            p { &quot;Hola, soy &quot; (name) &quot; y estoy usando Maud&quot;}<br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br><br></pre><br><br>La potencia de Maud se ve en la mega-macro <strong>html!</strong>. En esta macro escribiremos la plantilla que será compilada de forma nativa a Rust, lo que nos asegura una velocidad de ejecución excepcional. En este caso la salida será una etiqueta P de párrafo con la variable interpolada.<br><br><a href="https://files.adrianistan.eu/MaudP.png"><img class="aligncenter size-full wp-image-699" src="https://files.adrianistan.eu/MaudP.png" alt="" width="641" height="96" /></a>Simple, ¿no?<br><h2>PreEscaped y otros elementos básicos</h2><br>Por defecto en Maud todos el texto se convierte a HTML seguro. Es decir, no se pueden introducir etiquetas nuevas en el texto. Si por alguna razón necesitásemos añadir etiquetas nuevas podemos usar PreEscaped, que no realiza esta transformación de seguridad. Veamos el siguiente código:<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>use maud::PreEscaped;<br><br>fn main(){<br>        let name = &quot;Adrián&quot;;<br>        let markup = html!{<br>                p { &quot;Hola, soy &quot; (name) &quot; y estoy usando Maud&quot; }<br>                p { &quot;&lt;h5&gt;Esto no funcionará&lt;/h5&gt;&quot; }<br>                p { (PreEscaped(&quot;&lt;h5&gt;Esto sí funcionará&lt;/h5&gt;&quot;)) }<br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br><br></pre><br><br>El primer H5 se convertirá a código HTML seguro, es decir, no añadirá la etiqueta, en cambio se verá h5 en la web. Por contra con PreEscaped se añadirá la etiqueta h5 tal cual.<br><br>Los elementos son muy fáciles de añadir en Maud y por lo general no deberías usar PreEscaped salvo contadas ocasiones. Veamos como añadir más etiquetas.<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>fn main(){<br>        let name = &quot;Adrián&quot;;<br>        let markup = html!{<br>                p { &quot;Hola, soy &quot; (name) &quot; y estoy usando Maud&quot; }<br>                p {<br>                        &quot;Si la montaña no viene a Mahoma&quot;<br>                        br /<br>                        &quot;Mahoma va la montaña&quot;<br>                        small em &quot;Atribuido a Francis Bacon&quot;<br>                }<br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br><br></pre><br><br>En este ejemplo vemos como las etiquetas que no llevan texto como BR o INPUT debemos cerrarlas con una barra. Por otro lado es posible aglutinar varios niveles de etiquetas en una sola línea ( SMALL-&gt;EM-&gt;Texto).<br><h2>Atributos, clases e IDs</h2><br>En Maud es posible asignar atributos también, usando literales o variables. Para los atributos de texto la sintaxis es muy parecida a HTML.<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>fn main(){<br>        let name = &quot;Adrián&quot;;<br>        let amazon = &quot;http://www.amazon.com&quot;;<br>        let markup = html!{<br>                p { &quot;Hola, soy &quot; (name) &quot; y estoy usando Maud&quot; }<br>                p {<br>                        &quot;Este texto contiene enlaces a &quot;<br>                        a href=&quot;http://www.google.com&quot; &quot;Google&quot;<br>                        &quot; y a &quot;<br>                        a href=(amazon) &quot;Amazon&quot;<br>                }<br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br></pre><br><br>Además existen en HTML atributos vacíos. Es decir, atributos que con su sola presencia basta y normalmente no llevan valor asignado.<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>fn main(){<br>        let name = &quot;Adrián&quot;;<br>        let allow_editing = true;<br>        let markup = html!{<br>                p { &quot;Hola, soy &quot; (name) &quot; y estoy usando Maud&quot; }<br>                p contenteditable?[allow_editing] {<br>                }<br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br></pre><br><br>En este caso el atributo contenteditable se añade si la variable allow_editing es true. Si queremos añadir atributos vacíos en cualquier circunstancia podemos simplemente quitar [allow_editing] y dejar p contenteditable? {}.<br><br>Los IDs y las clases se añaden usando la sintaxis esperable, puntos y almohadillas.<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>fn main(){<br>        let name = &quot;Adrián&quot;;<br>        let markup = html!{<br>                p { &quot;Hola, soy &quot; (name) &quot; y estoy usando Maud&quot; }<br>                p.red.font-big#editor contenteditable? {<br>                }<br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br></pre><br><br><h2>Estructuras de control</h2><br>Maud soporta las estructuras de control básicas de Rust, if/else, if/let, for in y match.<br><br><pre class="lang:rust decode:true"><br>#![feature(plugin)]<br>#![plugin(maud_macros)]<br><br>extern crate maud;<br><br>fn main(){<br>        let loggedIn = false;<br>        let email = Some(&quot;mariscal@example.com&quot;);<br>        let fonts = [&quot;Arial&quot;,&quot;Times New Roman&quot;,&quot;Verdana&quot;];<br>        let markup = html!{<br>                @if loggedIn {<br>                        h1 { &quot;Has iniciado sesión&quot; }<br>                } @else {<br>                        h1 { &quot;Por favor, inicia sesión primero&quot; }<br>                }<br><br>                @if let Some(mail) = email {<br>                        p { &quot;Su email es &quot; (mail) }<br>                }<br>                ol {<br>                        @for font in &amp;fonts {<br>                                li (font)<br>                        }<br>                }<br><br>        };<br>        println!(&quot;{}&quot;, markup.into_string());<br>}<br></pre><br><br>Como vemos, Maud posee suficientes características para ser interesante. Maud además permite extender el motor para representar cualquier tipo de dato. Por defecto Maud mirá si está implementado std::fmt::Display pero si queremos añadir etiquetas extra este método no funcionará. En cambio si se implementa la trait maud::Render tendrás control total sobre como va a mostrar Maud las variables de ese tipo. En la crate <em>maud_extras</em> se encuentran implementaciones por ejemplo de Markdown para Maud.<br><br>Maud se integra además con web frameworks de Rust, en especial con Iron y con Rocket. Sin duda, una de mis crates favoritas.